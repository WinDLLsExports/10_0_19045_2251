                        step(1.0 + Epsilon, colorRgb) * positiveFactor);
            minfloat diffuseAmount, minfloat3 lightColor)
            minfloat specularShine, minfloat specularAmount, minfloat3 lightColor)
            minfloat3 lightColor)
            minfloat3 lightPosition, minfloat diffuseAmount,
            minfloat3 lightPosition, minfloat specularShine, minfloat specularAmount,
        ((colorRgb.g - colorRgb.b) / colorHsl.y) :
        (0.272 * intensity) * color.r
        (0.349 * intensity) * color.r
        (1 - 0.607 * intensity) * color.r
        (2.0 + (colorRgb.b - colorRgb.r) / colorHsl.y) :
        (4.0 + (colorRgb.r - colorRgb.g) / colorHsl.y);
        (flMax == colorRgb.g) ?
        (flMax == colorRgb.r) ?
        );
        * diffuseAmount * lightColor, 1);
        * diffuseAmount * spotLightColor, 1);
        : ((f < 1) ? (0.5 * b / (1 - f)) : 1);
        : 0;
        : b >= f ? 1
        : sum > 1.001 ? 1
        ? ((f > 0) ? (c / f) : 0)
        + (0.168 * intensity) * color.b);
        + (0.189 * intensity) * color.b);
        + (0.534 * intensity) * color.g
        + (0.769 * intensity) * color.g
        + (1 - 0.314 * intensity) * color.g
        + (1 - 0.869 * intensity) * color.b);
        + b.rgb * (1 - f.a));
        + f.rgb * (1 - b.a)
        0.0 :
        color *= destSat;
        color += sourceMaxVector;
        color += sourceMidVector * ((sourceMid - sourceMin) / (sourceMax - sourceMin));
        color = D2DBlendApplySourceLumToDest(color, destSat, D2DBlendGetLuminosity(lumSource));
        color = D2DBlendGetLuminosity(lumFallback).xxx;
        color,
        color[i] = (b[i] >= 1.0) ? 1.0 : (color[i] > 0.0) ? color2[i] : 0.0;
        D2DBlendColorDodgeComponent(uf.b, ub.b));
        D2DBlendColorDodgeComponent(uf.g, ub.g),
        D2DBlendColorDodgeComponent(uf.r, ub.r),
        D2DBlendHardMixComponent(uf.b, ub.b));
        D2DBlendHardMixComponent(uf.g, ub.g),
        D2DBlendHardMixComponent(uf.r, ub.r),
        D2DBlendSafeDivision(uf.b, ub.b));
        D2DBlendSafeDivision(uf.g, ub.g),
        D2DBlendSafeDivision(uf.r, ub.r),
        D2DBlendVividLightComponent(uf.b, ub.b));
        D2DBlendVividLightComponent(uf.g, ub.g),
        D2DBlendVividLightComponent(uf.r, ub.r),
        EncodeReflectanceModelAndTransparentNormal(reflectanceModel, normalHeight));
        float nDotH = max(dot(surfaceNormal, halfVector), 0);
        float3 halfVector = lightVector + eyeVector;
        focus, cosConeAngle, lightColor,
        halfVector = normalize(halfVector);
        lerp(((9 - 18 * uf) * ub + 5.76 * uf - 1.88) * ub,
        lerp(color0, color1, weights.x),
        lerp(color2, color3, weights.x),
        lerp(sourceLum + (((color - sourceLum.xxx) * factor2) / factor1),
        lightVector, exponent, eyeVector) * amount * lightColor;
        output = 0;
        output = pow(nDotH, exponent);
        pixelPosition, lightVector);
        pixelPosition, lightVector, spotLightColor);
        return b / f;
        return b == 0 ? 0 : 1;
        round(ub + (0.359375 - 0.001))), round(uf));
        specularShine, specularAmount, lightColor, minfloat3(0,0,1));
        specularShine, specularAmount, spotLightColor, minfloat3(0,0,1));
        step(0, lumDifference));
        step(factor1, factor2)),
        ub + (sqrt(ub) - ub) * (2 * uf - 1),
        weights.y
    )
    //
    //  - if the lightVector is in the inner cone, we'll get full power (1)
    //  - if the lightVector is in the outer cone, power will fade to 0
    //  - outside of the outer cone, power will be 0
    // (Math from D2D)
    // 0 -> Fully desaturated
    // 1 -> Original color
    // 2 -> Maximum possible value, not necessarily fully saturated
    // and https://www.w3.org/TR/SVG/filters.html#feColorMatrixValuesAttribute
    // Bit 0: a bool to store if this pixel is a fully transparent
    // Bit 1: Reflectance model. Blinn Phong (the default value) = 0, Physically Based Blinn Phong = 1
    // calculating floor(1 - (max - source)), which will result in a unit vector with a value
    // color is our output value:
    // Compute attenuated light color from the position and exponent
    // delay the wrapping until the sampling stage
    // Does not need alpha unpremultiplication
    // else                     return 1 - ((1 - dest) / source)
    // else               return dest + (sqrt(dest) - dest) * (2 * source - g_vectorOneMin16);
    // else             return 1 - 2 * (1 - source) * (1 - dest);
    // Extract the highest values for rgb's that are < 0 or > 1
    // Flip the Y axis, because the standard normal map tools assuming the Y
    // H
    // if (dest < 0.5)  return 2 * source * dest;
    // if (dest <= 9/64)   return ((9 * g_vectorOneMin16 - 18 * source) * dest + 5.76 * source - 1.88 * g_vectorOneMin16) * dest;
    // if (source + dest <= 1)  return 0;
    // if (source < 0.5)  return dest * (1 + (1 - dest) * (2 * source - 1))
    // if (source == 1)         return 1;
    // If the signedMod is negative, we must fix it up to wrap it into
    // If we had a tie for max or min, we want to disambiguate. It doesn't matter which value we
    // In D2D, if amount is
    // in texture coordinate is pointing up, but our Y are pointing down.
    // in the box from (0, 0) to (1, 1), and passing by (0.5, 0.5)
    // instructions, so we do the following instead:
    // is reduced much.
    // L
    // lerp is used to simulate if/else conditions.
    // Magic numbers for hashing the coordinates
    // Math from https://www.w3.org/TR/filter-effects/#grayscaleEquivalent
    // Math from https://www.w3.org/TR/filter-effects/#saturateEquivalent
    // Math from https://www.w3.org/TR/filter-effects/#sepiaEquivalent
    // note: it is ok if some colorU channels are zero because those failed quotients will not be chosen below
    // O_A = F_A * (1 - B_A) + B_A
    // O_PRGB = f(F_RGB, B_RGB) * F_A * B_A + F_RGB * (1 - B_A) + B_RGB * (1 - F_A) 
    // of one for the source's max component.
    // out-of-gamut processing
    // pick as the tie breaker, so we use saturate(sourceMaxVector.rgb - sourceMaxVector.gbr),
    // positive space.
    // Premultiply the RGB channels
    // Probability Theory and Mathematical Statistics, August 1998.
    // RGB to luminance factors from D2D
    // S
    // Similar calculation for min:
    // so the alpha channel is not opaque
    // The theroy is from a paper On generating random numbers, with help of y= [(a+x)sin(bx)] mod 1",
    // The weights will be always be between 0 and 0.5. If they are 0, we should
    // Then cut off the light based on the spotlight cone:
    // these two values into vectors, allowing for the comparisons for both to be done in parallel.
    // This accomplishes the following without branching (14 instructions vs. 20):
    // This accomplishes the following without branching:
    // This builds two contiguous polynomials forming an 'S' shape
    // This computes a specular component, meant to be blended atop a diffuse layer,
    // This is just trying to do (sourceMax - sourceMin) > 0 && destSat > 0, but that takes too many
    // This line of code is from https://www.shadertoy.com/view/4dS3Wd. It uses a very high frequency sin
    // to produce a periodic change between pixels. And then take the fractal part as a random number.
    // TODO: Do this up-front on the CPU (MSFT:3579391)
    // use 0,0,1 for the eye vector since this function is used for Image Lighting
    // Use a single componentwise comparison to select per-channel results.
    // use the close pixel, so we put the close pixel in xy.
    // Use this magic number to adjust the frequency of the white noise. When moving slowly, the artifact
    // W.J.J. Rey, 22nd European Meeting of Statisticians and the 7th Vilnius Conference on
    // We can calculate the mid-value vector and value once the min and max vector are known:
    // We can just take the abs of the signedMod, as this mirrors around 0.
    // We follow D2D's way of handling alpha = 0
    // We need to calculate the min and max of the hueSource and satSource. To save instructions, pack
    // We need to figure out which componenet contributed to the max value. We do this by
    // which guarauntees only one component has a 1:
    [unroll]
    {
    }
    color = dest + lumDifference.xxx;
    color = RestrictGamut(color, sourceLum);
    color = UnPremultiply(color);
    color.rgb *= color.a;
    color.rgb = (color.a == 0) ? float3(0, 0, 0) : (color.rgb / color.a);
    color.rgb = (color.rgb < 0.5f) ? lowResult : highResult;
    colorHsl.x = (colorHsl.y == 0.0) ?
    colorHsl.y = flMax - flMin;
    colorHsl.z = dot(colorRgb, g_luminosityWeights);
    const float COORD_SCALING = 0.81f;
    const float Epsilon = 1e-10;
    const minfloat3 vectorOneMin = minfloat3(1, 1, 1);
    else
    float a1 = -a2;
    float a2 = 2 * c2;
    float b1 = s;
    float b2 = 4 - 3 * s;
    float c2 = s - 1;
    float cosDirection = saturate(dot(-lightVector, lightTargetVector));
    float focus, float2 cosConeAngle,
    float luminance = dot(color.rgb, minfloat3(0.2125f, 0.7154f, 0.0721f));
    float result = lerp(lerp(sample00, sample10, factor.x), lerp(sample01, sample11, factor.x), factor.y);
    float s = 1 - (3.0f / 4.0f) * contrast;
    float sample00 = Hash(pixel00Coord);
    float sample01 = Hash(pixel01Coord);
    float sample10 = Hash(pixel10Coord);
    float sample11 = Hash(pixel11Coord);
    float sum = f + b;
    float2 coord = inputCoord * COORD_SCALING * freq + offset;
    float2 dispSelected = saturate(float2(displacement[selectX], displacement[selectY]));
    float2 factor = coord - pixel00Coord;
    float2 invTextureSize = GetInvTextureSizeFromSamplerDataExt(samplerDataExt);
    float2 min = uvBounds.xy;
    float2 pixel00Coord = floor(coord - 0.5f) + 0.5f;
    float2 pixel01Coord = float2(pixel00Coord.x, pixel11Coord.y);
    float2 pixel10Coord = float2(pixel11Coord.x, pixel00Coord.y);
    float2 pixel11Coord = pixel00Coord + 1;
    float2 signedMod = fmod(uv - uvBounds.xy, size * 2);
    float2 signedWeights = uvTexture - uvClosePixel;
    float2 size = uvBounds.zw - uvBounds.xy;
    float2 textureSize = GetTextureSizeFromSamplerDataExt(samplerDataExt);
    float2 uv,
    float2 uvClosePixel = floor(uvTexture) + 0.5;
    float2 uvFarPixel = uvClosePixel + sign(signedWeights);
    float2 uvs,
    float2 uvTexture = uv * textureSize;
    float2 weights;
    float2 wrapped = abs(signedMod);
    float3 lightColor, out float3 pixelPosition,
    float3 lightPosition, float3 lightTargetVector,
    float3 lightVector;
    float3 normal = normalize(normalHeight.xyz * 2 - 1);
    float3 output;
    float3 pixelPosition;
    float3 spotLightColor;
    float4 color0 = tex.Sample(textureSampler, float2(uvs.x, uvsWrapped.y));
    float4 color0 = tex.Sample(textureSampler, float2(uvsWrapped.x, uvs.y));
    float4 color0 = tex.Sample(textureSampler, uvsWrapped.xy);
    float4 color1 = tex.Sample(textureSampler, float2(uvs.x, uvsWrapped.w));
    float4 color1 = tex.Sample(textureSampler, float2(uvsWrapped.z, uvs.y));
    float4 color1 = tex.Sample(textureSampler, uvsWrapped.zy);
    float4 color2 = tex.Sample(textureSampler, uvsWrapped.xw);
    float4 color3 = tex.Sample(textureSampler, uvsWrapped.zw);
    float4 output;
    float4 samplerData,
    float4 samplerDataExt
    float4 samplerDataExt,
    float4 signedMod = fmod(uv - min.xyxy, size.xyxy);
    float4 uvBounds = GetUVBoundsFromSamplerData(samplerData);
    float4 uvs = float4(uvClosePixel, uvFarPixel) * invTextureSize.xyxy;
    float4 uvsWrapped = CalcWrappedUV(uvs, samplerData, samplerDataExt, /*out*/ weights);
    float4 wrapped = lerp(signedMod + size.xyxy, signedMod, step(0, signedMod));
    for (int i = 0; i < 3; i++)
    if ((sourceMax - sourceMin) * destSat > 0)
    if (dot(surfaceNormal, lightVector) > 0)
    if (f == 0)
    int reflectanceModel,
    lightVector = normalize(lightPosition - pixelPosition);
    minfloat ambientAmount, minfloat diffuseAmount, minfloat specularShine, minfloat specularAmount,
    minfloat c = f + 0.5 * (b - 1);
    minfloat destLum = D2DBlendGetLuminosity(dest);
    minfloat destSat = maxSD.y - minSD.y;
    minfloat diffuseAmount, minfloat3 lightColor)
    minfloat factor1 = destSat - destLum;
    minfloat factor2 = 1 - sourceLum;
    minfloat flMax = max(colorRgb.r, max(colorRgb.g, colorRgb.b));
    minfloat flMin = min(colorRgb.r, min(colorRgb.g, colorRgb.b));
    minfloat focus, minfloat2 cosConeAngle,
    minfloat gray = dot(color.rgb, grayFactor);
    minfloat lumDifference = sourceLum - destLum;
    minfloat sourceLum = D2DBlendGetLuminosity(source);
    minfloat sourceMax = maxSD.x;
    minfloat sourceMid = dot(sourceMidVector, hueSource);
    minfloat sourceMin = minSD.x;
    minfloat specularShine, minfloat specularAmount,
    minfloat t = max(max(t3.x, t3.y), t3.z);
    minfloat2 blue = minfloat2(hueSource.b, satSource.b);
    minfloat2 green = minfloat2(hueSource.g, satSource.g);
    minfloat2 maxSD = max(red, max(green, blue));
    minfloat2 minSD = min(red, min(green, blue));
    minfloat2 red = minfloat2(hueSource.r, satSource.r);
    minfloat3 color = D2DBlendApplyHueSatLum(f.rgb, ub.rgb, ub.rgb, ub.rgb);
    minfloat3 color = D2DBlendApplyHueSatLum(ub.rgb, uf.rgb, ub.rgb, ub.rgb);
    minfloat3 color = D2DBlendGetLuminosity(uf) < D2DBlendGetLuminosity(ub) ? uf : ub;
    minfloat3 color = D2DBlendGetLuminosity(uf) > D2DBlendGetLuminosity(ub) ? uf : ub;
    minfloat3 color = dest + lumDifference.xxx;
    minfloat3 color = lerp(2 * ub * uf, 2 * lerp(ub, 1, uf) - 1, round(uf));
    minfloat3 color = lerp(2 * uf * ub, 2 * lerp(uf, 1, ub) - 1, round(ub));
    minfloat3 color = lerp(min(ub, 2 * uf), max(ub, 2 * uf - 1), round(uf));
    minfloat3 color = lerp(ub * (1 + (1 - ub) * (2 * uf - 1)),
    minfloat3 color = max((1 - f.a) * b.rgb + f.rgb, (1 - b.a) * f.rgb + b.rgb);
    minfloat3 color = minfloat3(
    minfloat3 color = minfloat3(0, 0, 0);
    minfloat3 color = saturate(UnPremultiply(b).rgb + 2 * UnPremultiply(f).rgb - 1);
    minfloat3 color = uf + ub - 1;
    minfloat3 color;
    minfloat3 color2 = color / uf;
    minfloat3 colorHsl;
    minfloat3 colorNeutralRGB = luminance.xxx;
    minfloat3 dest = UnPremultiply(b).rgb;
    minfloat3 highResult = color.rgb * (color.rgb * a2 + b2) + c2;
    minfloat3 lightColor)
    minfloat3 lightColor, minfloat3 eyeVector)
    minfloat3 lightPosition, minfloat3 lightTargetVector,
    minfloat3 lightVector)
    minfloat3 lightVector, minfloat exponent, minfloat amount,
    minfloat3 lightVector, minfloat exponent, minfloat3 eyeVector)
    minfloat3 lowResult = color.rgb * (color.rgb * a1 + b1);
    minfloat3 negativeFactor = -colorRgb / (colorNeutralRGB - colorRgb);
    minfloat3 positiveFactor = (1.0 - colorRgb) / (colorNeutralRGB - colorRgb);
    minfloat3 source = UnPremultiply(f).rgb;
    minfloat3 sourceMaxVector = floor(vectorOneMin - (sourceMax.xxx - hueSource));
    minfloat3 sourceMidVector = vectorOneMin - sourceMaxVector - sourceMinVector;
    minfloat3 sourceMinVector = floor(vectorOneMin - (hueSource - sourceMin.xxx));
    minfloat3 t3 = max( (1.0 - step(0, colorRgb)) * negativeFactor, 
    minfloat3 ub = UnPremultiply(b).rgb;
    minfloat3 uf = UnPremultiply(f).rgb;
    minfloat4 result;
    normal.y = -normal.y;
    normalHeight = UnPremultiply(normalHeight);
    out float2 weights
    out float3 lightVector, out float3 spotLightColor)
    out float3 pixelPosition, out float3 lightVector)
    out float4 outputNormalTangentSpace)
    output.a = max(output.r, max(output.g, output.b));
    output.rgb *= output.a;
    output.rgb = CalculateBlinnPhongLitPixelSpecularUnpremultiplied(surfaceNormal,
    outputNormalTangentSpace = float4(GetSurfaceNormal(normalHeight),
    pixelPosition = float3(pixelXY.xy, 0.0f);
    PreparePointVectors(pixelXY, lightPosition,
    PrepareSpotVectors(pixelXY, lightPosition, lightTargetVector,
    result.a = color.a;
    result.b = minfloat(
    result.g = minfloat(
    result.r = minfloat(
    return (1 - dest.a) * src + (1 - src.a) * dest;
    return (1 - dest.a) * src + dest;
    return (1 - dest.a) * src + src.a * dest;
    return (1 - dest.a) * src;
    return (1 - src.a) * dest;
    return (f < 0.5)
    return (f < 1.0) ? (b / (1.0 - f)) : ceil(b);
    return CalculateLitPixelSpecular(surfaceNormal, lightVector,
    return clamp(uv, uvBounds.xy, uvBounds.zw);
    return color;
    return colorHsl;
    return D2DBlendBasicRgb(f, b, abs(UnPremultiply(f).rgb - UnPremultiply(b).rgb));
    return D2DBlendBasicRgb(f, b, color);
    return D2DBlendBasicRgb(f, b, saturate(color));
    return D2DBlendBasicRgb(f, b, saturate(UnPremultiply(b).rgb - UnPremultiply(f).rgb));
    return D2DBlendBasicRgb(f, b, saturate(UnPremultiply(f).rgb + UnPremultiply(b).rgb - 1));
    return D2DBlendBasicRgb(f, b, saturate(UnPremultiply(f).rgb + UnPremultiply(b).rgb));
    return D2DBlendBasicRgb(f, b, UnPremultiply(f).rgb * UnPremultiply(b).rgb);
    return D2DBlendLuminosityRgb(b, f);
    return dest.a * src + (1 - src.a) * dest;
    return dest.a * src;
    return dot(g_luminosityWeights, color);
    return f + b - f * b;
    return f.rgb * (1 - b.rgb) + b.rgb;
    return f.rgb + b.rgb - 2 * f.rgb * b.rgb;
    return float2(uvHorizontal.x, uvVertical.y);
    return float4(ambientAmount, diffuseAmount, specularShine, specularAmount);
    return float4(CalculateLitPixelDiffuse(surfaceNormal, lightVector)
    return float4(result.xxx, 1);
    return frac(1e4f * sin(17.0f * p.x + p.y * 0.1f) * (0.1f + abs(sin(p.y * 13.0f + p.x))));
    return lerp(
    return lerp(color0, color1, weights.x);
    return lerp(color0, color1, weights.y);
    return lerp(colorRgb, colorNeutralRGB, max(0, t));
    return lerp(sourceLum + (((color - sourceLum.xxx) * sourceLum) / destLum),
    return max(dot(surfaceNormal, lightVector), 0);
    return min((1 - f.a) * b.rgb + f.rgb, (1 - b.a) * f.rgb + b.rgb);
    return minfloat4(0, 0, 0, luminance);
    return minfloat4(gray, gray, gray, color.a);
    return minfloat4(lerp(gray.rrr, color.rgb, amount), color.a);
    return mul(color, colorMatrix4x4) + colorOffset;
    return normal;
    return normalHeight.w * heightMapScale;
    return output;
    return Premultiply(color);
    return Premultiply(D2DColorMatrixStraight(UnPremultiply(color), colorMatrix4x4, colorOffset));
    return Premultiply(D2DSepiaStraight(UnPremultiply(color), intensity));
    return reflectanceModel * 2 + (any(normalHeight) ? 1 : 0);
    return result;
    return samplerDataExt.zw;
    return saturate(func * f.a * b.a
    return src + (1 - src.a) * dest;
    return src + dest;
    return src.a * dest;
    return src;
    return sum < 0.999 ? 0
    return uv;
    return uvBounds.zw - abs(wrapped - size);
    return uvToDisplace + (dispSelected - 0.5) * scale * GetInvTextureSizeFromSamplerDataExt(samplerDataExt);
    return wrapped + min.xyxy; 
    return WrapUV2(uv, samplerData);
    return WrapUV4(uv.xyxy, samplerData).xy;
    return WrapUV4(uvs, samplerData);
    SamplerState textureSampler,
    sourceMaxVector = saturate(sourceMaxVector - sourceMaxVector.gbr);
    sourceMinVector = saturate(sourceMinVector - sourceMinVector.gbr);
    spotLightColor *= pow(cosDirection, focus);
    spotLightColor *= smoothstep(cosConeAngle.y, cosConeAngle.x, cosDirection);
    spotLightColor = lightColor;
    Texture2D tex,
    weights = abs(signedWeights);
  eb 0x%p 'p';g  -- terminate Process
  eb 0x%p 't';g  -- terminate Thread
  g                    -- Go (continue)
 * pow(
 : packoffset(c
 : register(b0)
 = D2DBlend
 = D2DComposite
 = D2DContrast(
 = D2DDistantDiffuse(
 = D2DDistantSpecular(
 = D2DGrayscale(
 = D2DLuminanceToAlpha(
 = D2DPointDiffuse(
 = D2DPointSpecular(
 = D2DSaturation(
 = D2DSpotDiffuse(
 = D2DSpotSpecular(
 = minfloat4(
 = Premultiply(
 = Premultiply(minfloat4(
 = saturate(
 = SceneLightingParameters(
 = UnPremultiply(
 = WhiteNoise(
 Microsoft Corporation. All rights reserved.
 Operating System
 or regular debugging.
 Windows
!02<e<v<
!This program cannot be run in DOS mode.
#   define minp(type) MINP_PREFIX##type
#   define minp(type) type
#define COMMON_HLSL
#define D2DLIGHTING_HLSL
#define minfloat minp(float)
#define minfloat2 minp(float2)
#define minfloat2x2 minp(float2x2)
#define minfloat3 minp(float3)
#define minfloat3x2 minp(float3x2)
#define minfloat3x3 minp(float3x3)
#define minfloat4 minp(float4)
#define minfloat4x4 minp(float4x4)
#else
#endif
#if !defined(COMMON_HLSL)
#if !defined(D2DLIGHTING_HLSL)
#if defined(MINP_PREFIX)
#include "
#include "Common.hlsl"
$0k0z0
$PhXH
%hs!%p: 
%hs(%d) tid(%x) %08X %ws
%hs(%u)\%hs!%p: 
(caller: %p) 
(No kernel debugger is present.) Respond with:
).rgb, 
)_^[]
)PhP7
)PhXH
***   %s%ls%sSource: `%ls:%ld`
*** Assertion failed: %ls%ls%ls
,4B4X4i4
.?AV<lambda_5caec47860cbb9ad654244740ea931d5>@@
.?AV<lambda_5dc08213cb74b9a833340c9410586074>@@
.?AV<lambda_6604e86240abfa1bd81cdabb2d0569ea>@@
.?AV<lambda_8da701d7bd608867fe2ccf81a118328c>@@
.?AV<lambda_8f3337e07c8c4f79ad139134132c2f1b>@@
.?AV<lambda_98dc175ebec9e0c41e0208a169137e3a>@@
.?AV<lambda_af99df7639788a764efe3b91ec4ea663>@@
.?AV<lambda_b306f4cd683d8ca256a465a653a09d75>@@
.?AV<lambda_ba2c660fd9487eafba7ff191f91abea1>@@
.?AV<lambda_cafa38e17f315aa8cbe58a52d698b71a>@@
.?AV<lambda_f734f85d8543779c8a08289b84a137f5>@@
.?AV<lambda_fb0bfdd47ef1e5b6398fc4284b2e8b5d>@@
.?AV<lambda_ff74d4201639c4a26394d475f3c20713>@@
.?AVbad_alloc@std@@
.?AVexception@std@@
.?AVOriginatedException@Composition@UI@Windows@@
.?AVout_of_range@std@@
.?AVResultException@wil@@
.?AVtype_info@@
.00cfg
.a = D2DBlendAlpha(
.a));
.b * 
.CRT$XCA
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XLA
.CRT$XLZ
.CRT$XPA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.data
.data$brc
.data$r$brc
.edata
.gfids
.giats
.idata
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.P6GXPBXPAX@Z
.r * 
.rdata
.rdata$brc
.rdata$r$brc
.rdata$sxdata
.rdata$T$brc
.rdata$zzzdbg
.rgb * 
.rsrc$01
.rsrc$02
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.text
.text$di
.text$mn
.text$x
.text$yd
.tls$
.tls$ZZZ
.x * 
.xdata$x
.xyz, 
.y * 
.z * 
//-----------------------------------------------
//     and 2 v coordinates, in z and w.
// Alpha premultiplication and un-premultiplication
// Blend functions, in order of reference webpage
// Blend premultiplied f and b together with the color from the color function
// Converts an RGB color to an HSL color. The output vector has .xyz = HSL
// Copyright (C) Microsoft. All rights reserved.
// D2DCompositeBoundedSourceCopy not supported because we
// don't have a notion of input bounds.
// Generated file, do not edit.
// Helper constants:
// Helpers
// HLSL implementation of D2D blend functions.
// HLSL implementation of D2D composite effect modes.
// HLSL implementation of the D2D saturation effect.
// If clamping is not the same in both directions
// Macro for minimum-precision types (min10float, min16float)
// Must match dwmcore-side CommonFragments_PSLib version
// Not being used until we add functionality for image lighting with normals.
// Premultiplied-alpha version
// Restricts the gamut of colorRgb with the given luminance to a 0-1 range.
// returns 2 u coordinates, in x and z
// See: http://msdn.microsoft.com/en-us/library/windows/desktop/hh706313.aspx
// See: http://msdn.microsoft.com/en-us/library/windows/desktop/hh706320.aspx
// should then be weighted by the output weights.
// Straight-alpha version
// The default normal is <0,0,1>.
// These coordinates can be used to sample the texture. The texture samples
// This function applies the provided luminosity value to the dest, replacing dest's luminosity.
// This function generates a new RGB output, taking its hue, saturation, and luminosity from the three RGB inputs.
// This is the default normal encoded in premultiplied RGBA8888 for use in SceneLighting.
// TODO: Dissolve
// We pass in destSat as an optimization, so we don't need to recalculate it:
: :8:P:
:!;3;
:!<k<
:":8:>:C:J:c:
:#;0;=;
:$;I;k;
:&;[;
:):B:
:/:7:D:M:X:`:j:r:}:
:;:U:c:u:
:[:~:
:0:`:d:h:l:p:t:x:|:
:9:\:
:c;m;
:deque<T> too long
:L;P;X;`;x;
; ;$;(;,;0;4;8;<;@;D;H;L;P;T;X;\;`;d;h;l;p;t;x;|;
;!<j<
;#;a;
;#<1<A<G<^<
;#<1<A<G<_<e<
;$<8<@<H<P<X<h<t<|<
;&;2;=;I;
;(;/;Q;W;p;x;
;,;4;@;`;l;
;+<U<f<o<x<
;2;Q;a;g;s;
;C;[;
;D;_;
;K;Q;u;|;
;t;@<`<j<
? ?$?(?,?0?4?8?<?@?D?H?L?P?T?X?\?`?t?x?
?$?*?0?6?<?B?H?R?X?^?d?j?p?v?
?$?,?p?
?$?+?
?$?d?
?_Xbad_function_call@std@@YAXXZ
?_Xlength_error@std@@YAXPBD@Z
?_Xout_of_range@std@@YAXPBD@Z
?2?U?x?
?333333
?8?D?d?l?t?|?
?A?S?l?|?
?U?[?h?s?
@.reloc
@.rsrc
[%hs(%hs)]
[%hs]
__CxxFrameHandler3
__std_terminate
_CxxThrowException
_except_handler4_common
_initterm
_initterm_e
_o___std_exception_copy
_o___std_exception_destroy
_o___std_type_info_destroy_list
_o___stdio_common_vsnprintf_s
_o___stdio_common_vsprintf_s
_o___stdio_common_vswprintf
_o__cexit
_o__CIcos
_o__CIpow
_o__CIsin
_o__CIsqrt
_o__configure_narrow_argv
_o__create_locale
_o__crt_atexit
_o__errno
_o__execute_onexit_table
_o__initialize_narrow_environment
_o__initialize_onexit_table
_o__invalid_parameter_noinfo
_o__invalid_parameter_noinfo_noreturn
_o__itoa_s
_o__ltoa_s
_o__purecall
_o__register_onexit_function
_o__seh_filter_dll
_o__wcsicmp_l
_o_ceil
_o_terminate
`.data
{Dj<Y
~h_^]
+K0+S0
< <$<(<,<0<4<8<<<@<D<H<L<P<T<X<l<
< <$<(<,<0<4<8<D<H<L<P<
<!=?=Z=
<#=z=
<,<W<y<
</=C=i=}=
<<<D<L<T<\<d<l<t<
<-<8<H<P<]<c<k<p<
<7<d<
<C=Q=a=g=s=
<D=|=
<E=]>s>
= =*=
= =8=P=
="=,=`=g=y=
=">E>
=$=,=4=<=D=L=T=\=d=l=x=
=(=6=>=R=]=
=.=c=
=:>@>|>
=@=o=
=0=8=D=d=p=
=0>z>
=2=U=x=
=A=f=
=k>u>
=M>T>
> >D>L>T>\>d>l>t>|>
>!>1>7>F>
>">1>y>
>$>,>8>X>`>l>
>)>E>
>,>0>H>`>
>.?:?]?
>.?Q?v?
>->9>U>d>
>4>a>
>9?h?
>A>U>\>
>S>a>q>w>
0 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0l0p0t0x0|0
0 0$0(0,0004080<0@0T0X0
0"0U0
0$000P0\0|0
0)0.030i0
0)0?0X0
0;0W0
0=0I0|0
001U1
030G0
030N0i0
040904B0
041l1
071u1
0C1y1
0L0\0h0p0
0P0T0X0\0s0
0Q0p0|0
1 - UnPremultiply(
1 1$1(1,1014181<1@1D1H1L1P1T1X1\1`1h1
1 1*141>1H1R1\1f1p1z1
1!1Z1
1"1'1@1E1R1
1$1,141<1D1L1T1\1d1p1
1(101d1t1
1(2C2U2t2
1)111
10.0.19041.546
10.0.19041.546 (WinBuild.160101.0800)
101H1`1t1
1'1`1g1`4
151C2~2
161C1
1c1q1
1o2_3H4y4
1U1}1
2 2$2(2,2024282<2@2D2H2L2P2T2X2\2`2d2h2l2p2t2x2|2
2 2@2H2T2t2
2 2_2j2
2"2L2S2l2
2#2`2l2
2$2.282B2j2
2$2D2P2p2|2
2%3I3
2(2X2\2`2d2h2l2p2t2x2|2
2)2@2
2*333C3J3[3b3
2,3d3
2?3F3
2_2q2+3j3
202b2
242l2
2n3>4
2W2z2
3 34383L3P3d3h3|3
3 465P5s5
3!31373C3z3
3#3=3M3W3f3{3
3&3-343;3C3K3S3_3h3m3s3}3
3(3H3P3\3|3
3)4H4r4
3@4U6[6^7
384c4q4
3A516A6f6
3H3L3P3T3X3\3`3d3h3l3p3t3x3|3
3X3l3|3
4 4$4(4,4044484<4@4D4H4\4`4t4
4 4$4(4,4044484<4@4D4H4L4P4T4X4\4`4d4h4l4p4t4x4|4
4(4H4d4h4p4t4|4
4?4H4O4U4[4
434A4Q4q4
444<4H4h4t4|4
4-4C4Y4j4
4A5n5~5
4B4g4
4O5h5
4S4w4"5
5 5$5(5,5054585<5@5D5H5L5P5T5X5\5`5x5
5 5$5,505
5 6@6V6y6
5 6<6a6
5 7g7
5$5D5L5T5\5d5p5x5
5;6i6
5?5G5
5@5D5H5L5P5T5X5\5`5d5h5l5p5t5x5|5
5'535
5-5s5
566a6
5ineI
5L6q6
5ntel
6 686P6
6 6A6
6$6,646@6`6l6
6*7Q7m7
6@6b6
6@6X6
6B6e6
6H6N6c6t6
6P6v6
6P7c7
7 7$7(7,7074787<7@7D7H7L7P7T7X7\7`7d7h7l7p7t7x7|7
7!71777C7m7
7"7+747J7S7\7e7z7
7$7,7`7p7|7
7&8X8
7*8M8
7.8b8}8
7.s:>j
7/8P8f8
7+7M7d7m7s7x7
738=8a8
777H7r7y7
79|~X>
797N7
7a8u8
7M7S7
7P7h7
8 8,8L8X8x8
8&9^9z9
8(<.<
8(8@8X8p8
8*8H8b8
8`8h8r8~8
848;8~8
858X8
888<8@8D8H8L8P8T8X8\8`8d8h8l8p8t8x8|8
8-8d8
8PhXH
8wJG>iR
9 9$9(9,9094989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
9"9C9|9
9$90989W9l9
9&9=9L9h9
9(:8:D:L:
9,989X9`9h9p9x9
9/iL>
9;:O:Z:a:
9_(s-j
9+93999G9S9p9u9
9=9U9_9}9
909H9`9x9
96:k:
9B9e9~9
9B9w9
9G9t9
9I:[:y:
9J:*;
A graph source parameter with a border effect can only be used once.
A graph source parameter with a transform can only be used once.
A(+A$
A(+A$]
A,+A(j
A@+A<
A4+A0
A4+A0j
AffineTransform2D's source must be a source parameter.
AlphaAmplitude
AlphaDisable
AlphaExponent
AlphaMode
AlphaOffset
AlphaSlope
AmbientAmount
Angle
Animatable property refers to an effect not in the graph.
api-ms-win-core-com-l1-1-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-2.dll
api-ms-win-core-errorhandling-l1-1-3.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-interlocked-l1-1-0.dll
api-ms-win-core-kernel32-legacy-l1-1-0.dll
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-libraryloader-l1-2-1.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-1.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-winrt-error-l1-1-0.dll
api-ms-win-core-winrt-l1-1-0.dll
api-ms-win-core-winrt-string-l1-1-0.dll
api-ms-win-crt-private-l1-1-0.dll
api-ms-win-crt-runtime-l1-1-0.dll
api-ms-win-crt-string-l1-1-0.dll
ArithComp
Azimuth
bad allocation
Blend
BlueAmplitude
BlueDisable
BlueExponent
BlueOffset
BlueSlope
BlurAmount
Border
BorderEffect's source must be a source parameter.
BorderMode
Break, Go (continue), terminate Process, or terminate Thread (bgpt)? 
c_defaultNormalHeight
c_defaultSurfaceNormal
C4+C0
CallContext:[%hs] 
cbuffer 
ClampInput
ClampOutput
CloseHandle
CMILCOMBase::InternalAddRef
Coefficients
Color
ColorBurn
ColorDodge
ColorMatrix
ColorMatrix4x4
ColorMatrixEffect
ColorOffset
COMMON.HLSL
Common.hlsl
CompanyName
CompileEffectDescription
Composite
const 
Contrast
CoTaskMemFree
CreateEffectDescription
CreateEventW
CreateMutexExW
CreateSemaphoreExW
CrossFade
D$ Pj hP8
D2DBlend.hlsl
D2DBLEND.HLSL
D2DBORDER.HLSL
D2DColorMatrix.hlsl
D2DCOLORMATRIX.HLSL
D2DColorMatrixPremultiplied
D2DColorMatrixStraight
D2DCOMPOSITE.HLSL
D2DComposite.hlsl
D2DContrast.hlsl
D2DCONTRAST.HLSL
D2DDISPLACEMENTMAP.HLSL
D2DLIGHTING.HLSL
D2DLighting.hlsl
D2DLUMINANCETOALPHA.HLSL
D2DLuminanceToAlpha.hlsl
D2DSaturation.hlsl
D2DSATURATION.HLSL
D2DSepia.hlsl
D2DSEPIA.HLSL
D2DSepiaPremultiplied
D2DSepiaStraight
D3DCompile
d3dcompiler_47.dll
D3DReflectLibrary
Darken
DarkerColor
DbgPrintEx
DbgPrompt
DebugBreak
DeleteCriticalSection
DeserializeEffectDescription
DestinationAtop
DestinationIn
DestinationOut
DestinationOver
Difference
DiffuseAmount
DistantDiffuse
DistantSpecular
Division
Duplicate effect name.
Effect is too complex.
EffectOptimization
Elevation
EnterCriticalSection
Exception
Exclusion
export float2 BorderEffectClamp(float2 uv, float4 samplerData)
export float2 BorderEffectCombine(float2 uvHorizontal, float2 uvVertical)
export float2 BorderEffectMirror(float2 uv, float4 samplerData)
export float2 BorderEffectWrap(float2 uv, float4 samplerData)
export float2 BorderEffectWrapBilinear(float2 uv, float4 samplerData)
export minfloat4 
Exposure
ExposureValue
ExtendX
ExtendY
F(+F$
F4+F0
FailFast
FileDescription
FileVersion
FindResourceA
FLightTarget
float Hash(float2 p)
float2 DisplacementMap(float2 uvToDisplace, minfloat4 displacement, float4 samplerDataExt, minfloat scale, uint selectX, uint selectY)
float2 GetInvTextureSizeFromSamplerDataExt(float4 samplerDataExt)
float2 WrapUV2(float2 uv, float4 samplerData)
float4 CalcWrappedUV(
float4 SampleWrappedTexture(
float4 SampleWrappedTextureUOnly(
float4 SampleWrappedTextureVOnly(
float4 SceneLightingParameters(minfloat4 normalHeight,
float4 WhiteNoise(minfloat2 inputCoord, minfloat2 freq, minfloat2 offset)
float4 WrapUV4(float4 uv, float4 samplerData)
Flood
Focus
FormatMessageW
FreeLibrary
Frequency
Function: 
G,+G$
G,+G(
G,A+G(
Gains
GammaXfer
GaussianBlur
GetCurrentProcess
GetCurrentProcessId
GetCurrentThread
GetCurrentThreadId
GetLastError
GetModuleFileNameA
GetModuleHandleExW
GetModuleHandleW
GetProcAddress
GetProcessHeap
GetSystemTimeAsFileTime
GreenAmplitude
GreenDisable
GreenExponent
GreenOffset
GreenSlope
H(+H$
HardLight
HardMix
HeapAlloc
HeapFree
HeightMapInterpolationMode
HeightMapKernelSize
HeightMapScale
HueRotation
'i' is only supported with debug builds.
InitializeConditionVariable
InitializeCriticalSection
InitializeCriticalSectionAndSpinCount
InitializeSListHead
inline float CalculateLitPixelDiffuse(minfloat3 surfaceNormal,
inline float EncodeReflectanceModelAndTransparentNormal(int reflectanceModel, minfloat4 normalHeight)
inline float GetSurfaceHeight(float4 normalHeight, float heightMapScale)
inline float3 CalculateBlinnPhongLitPixelSpecularUnpremultiplied(minfloat3 surfaceNormal,
inline float3 GetSurfaceNormal(float4 normalHeight)
inline float4 CalculateLitPixelSpecular(minfloat3 surfaceNormal,
inline minfloat D2DBlendAlpha(minfloat f, minfloat b)
inline minfloat D2DBlendColorDodgeComponent(minfloat f, minfloat b)
inline minfloat D2DBlendGetLuminosity(minfloat3 color)
inline minfloat D2DBlendHardMixComponent(minfloat f, minfloat b)
inline minfloat D2DBlendSafeDivision(minfloat f, minfloat b)
inline minfloat D2DBlendVividLightComponent(minfloat f, minfloat b)
inline minfloat3 D2DBlendApplyHueSatLum(minfloat3 hueSource, minfloat3 satSource, minfloat3 lumSource, minfloat3 lumFallback)
inline minfloat3 D2DBlendApplySourceLumToDest(minfloat3 dest, minfloat destSat, minfloat sourceLum)
inline minfloat3 D2DBlendBasicRgb(minfloat4 f, minfloat4 b, minfloat3 func)
inline minfloat3 D2DBlendColorBurnRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendColorDodgeRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendColorRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendDarkenRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendDarkerColorRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendDifferenceRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendDivisionRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendExclusionRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendHardLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendHardMixRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendHueRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLightenRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLighterColorRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLinearBurnRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLinearDodgeRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLinearLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendLuminosityRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendMultiplyRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendOverlayRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendPinLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendSaturationRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendScreenRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendSoftLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendSubtractRgb(minfloat4 f, minfloat4 b)
inline minfloat3 D2DBlendVividLightRgb(minfloat4 f, minfloat4 b)
inline minfloat3 RestrictGamut(minfloat3 colorRgb, minfloat luminance)
inline minfloat3 RgbToHsl(minfloat3 colorRgb)
inline minfloat4 D2DCompositeDestinationAtop(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeDestinationIn(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeDestinationOut(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeDestinationOver(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeMaskInvert(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositePlus(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceAtop(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceCopy(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceIn(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceOut(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeSourceOver(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DCompositeXor(minfloat4 src, minfloat4 dest)
inline minfloat4 D2DDistantDiffuse(float3 surfaceNormal, minfloat3 lightVector,
inline minfloat4 D2DDistantSpecular(float3 surfaceNormal, minfloat3 lightVector,
inline minfloat4 D2DGrayscale(minfloat4 color)
inline minfloat4 D2DPointDiffuse(float3 surfaceNormal, minfloat3 pixelXY,
inline minfloat4 D2DPointSpecular(float3 surfaceNormal, minfloat3 pixelXY,
inline minfloat4 D2DSaturation(minfloat4 color, minfloat amount)
inline minfloat4 D2DSepiaPremultiplied(minfloat4 color, minfloat intensity)
inline minfloat4 D2DSepiaStraight(minfloat4 color, minfloat intensity)
inline minfloat4 D2DSpotDiffuse(float3 surfaceNormal, minfloat3 pixelXY,
inline minfloat4 D2DSpotSpecular(float3 surfaceNormal, minfloat3 pixelXY,
inline void PreparePointVectors(float3 pixelXY, float3 lightPosition,
inline void PrepareSpotVectors(float3 pixelXY,
InternalName
InterpolationMode
Invalid animatable property mapping.
Invalid blur border mode.
Invalid effect input.
Invalid float value
invalid hash bucket count
Invalid number of sources.
invalid vector<T> subscript
Invert
IsDebuggerPresent
IsProcessorFeaturePresent
jIntensity
kernel32.dll
kernelbase.dll
L$<_^[3
LeaveCriticalSection
LegalCopyright
lerp(
lib_4_0_level_9_3_ps_only
LightColor
LightCosConeAngle
Lighten
LighterColor
LightPosition
LightTargetVector
LightVector
LimitingConeAngle
LinearBurn
LinearDodge
LinearLight
LinearXfer
list<T> too long
LoadLibraryW
LoadResource
Local\SM0:%d:%d:%hs
LockResource
LogHr
lstd::exception: %hs
LuminanceToAlpha
Luminosity
M_>|~
Malformed animatable property name.
Malformed effect name.
Malformed named input name.
map/set<T> too long
MaskInvert
Matrix
memcmp
memcpy
memmove
memset
Microsoft
Microsoft Composition Effects
Microsoft Corporation
minfloat
minfloat2
minfloat3
minfloat3x2
minfloat4
minfloat4 D2DColorMatrixPremultiplied(minfloat4 color, minfloat4x4 colorMatrix4x4, minfloat4 colorOffset)
minfloat4 D2DColorMatrixStraight(minfloat4 color, minfloat4x4 colorMatrix4x4, minfloat4 colorOffset)
minfloat4 D2DContrast(minfloat4 color, minfloat contrast)
minfloat4 D2DLuminanceToAlpha(minfloat4 color)
minfloat4 Premultiply(minfloat4 color)
minfloat4 UnPremultiply(minfloat4 color)
minfloat4x4
Msg:[%ws] 
msvcp_win.dll
Multiple animatable properties animate the same value.
Multiplier
Multiply
Multiply defined animatable property.
No more than four graph source parameters are supported.
No more than three graph source parameters with white noise effect are supported.
Noise.hlsl
NOISE.HLSL
Non-finite floating-point value.
Non-tree shaped effect graph.
ntdll.dll
NtQuerySystemInformation
Null animatable property name.
Null effect input.
O8T>[
Offset
onecore\internal\sdk\inc\wil\opensource/wil/resource.h
onecoreuap\windows\dwm\common\shared\milcom.cpp
onecoreuap\windows\dwm\effects\compiler\effectgenerator.cpp
onecoreuap\windows\dwm\effects\compiler\effectinstance.cpp
onecoreuap\windows\dwm\effects\compiler\flattenedeffectgraph.cpp
onecoreuap\windows\dwm\effects\compiler\graphicseffectgraphtraversal.cpp
onecoreuap\windows\dwm\effects\compiler\shaderincluderesolver.cpp
Opacity
OpenSemaphoreW
OriginalFilename
Output semantic can be changed only once.
Output_Normal_TangentSpace
OutputDebugStringW
Overlay
P9K8t
'PhXH
PinLight
PixelShader.hlsl
PointDiffuse
PointSpecular
PPhx7
ProductName
ProductVersion
Property value out of bounds
PSBody
PSConstants
Qj8VQ
QjsVQ
QQhx7
QQSVW
QQSVWj
QQVWj
QSh0B
QSVWhPU
QSVWj
QueryPerformanceCounter
qwGrayscale
R0V0\0`0f0j0r0v0|0
RaiseException
RaiseFailFastException
RedAmplitude
RedDisable
RedExponent
RedOffset
RedSlope
ReflectanceModel
ReleaseMutex
ReleaseSemaphore
ResetEvent
return 
ReturnHr
RoGetActivationFactory
RoOriginateError
RoOriginateErrorW
row_major 
rRich
RtlCaptureStackBackTrace
RtlDisownModuleHeapAllocation
RtlDllShutdownInProgress
sample
Saturation
SceneLighting
SceneLightingEffect cannot be a source to GaussianBlurEffect.
Screen
Sepia
SerializeEffectDescription
SetEvent
SetLastError
SetUnhandledExceptionFilter
Sharpness
SizeofResource
SleepConditionVariableCS
SoftLight
SourceAtop
SourceCopy
SourceIn
SourceOut
SourceOver
Specified property cannot be animated.
Specified property does not exist or cannot be animated.
SpecularAmount
SpecularExponent
SpecularShine
SpotDiffuse
SpotSpecular
static const float3 c_defaultSurfaceNormal = float3(0.0f, 0.0f, 1.0f);
static const minfloat3 g_luminosityWeights = minfloat3(0.30, 0.59, 0.11);
static const minfloat3 grayFactor = minfloat3(0.2126, 0.7152, 0.0722);
static const minfloat4 c_defaultNormalHeight = minfloat4(0.5f, 0.5f, 1.0f, 1.0f);
string too long
StringFileInfo
Subtract
SVWj@
SVWRQ
t h<,
t$$SSP
t$<WP
t$pVQ
t.;8u
Temperature
TempTint
TerminateProcess
TerminateProcessOnMemoryExhaustion
TerminateThread
t-hlU
TransformMatrix
Translation
Tried to AddRef an object which has previously been freed (refcount went to 0).
u.PVh
Unexpected effect input type.
Unexpected effect property value.
Unexpected property type.
Unexpected variable scope.
UnhandledExceptionFilter
Unknown exception
Unknown input parameter.
UnPremultiply(
Unrecognized response.
Unsupported alpha mode.
Unsupported blend mode.
Unsupported BorderEffect edge mode.
Unsupported composite mode.
Unsupported effect property type.
Unsupported effect type.
VarFileInfo
vector<T> too long
VividLight
VQPWV
VS_VERSION_INFO
VVPh8V
VWQQ3
WaitForSingleObject
WaitForSingleObjectEx
WakeAllConditionVariable
Weight
WerRegisterMemoryBlock
WhiteNoise
WhiteNoise_XY
WilError_03
Windows.Foundation.PropertyValue
WindowsCreateString
WindowsCreateStringReference
WindowsDeleteString
WindowsDuplicateString
WindowsGetStringRawBuffer
WindowsSubstringWithSpecifiedLength
wLhH6
wuceffects
wuceffects.dll
wuceffects.pdb
X[_^]
XAlphaMask
XForm
XYZ_Light0Space
Y__^[
yHPhXH
