 A^_^
 A^A\_
 A_A\_
 A_A^_
 A_A^_^]
 A_A^A\
 A_A^A\_^
 A_A^A]A\_
 A_A^A]A\_^]
 and backup manifest
 H3E H3E
 http://www.microsoft.com/windows0
 Microsoft Corporation. All rights reserved.
 Microsoft Operations Puerto Rico1&0$
 Microsoft Operations Puerto Rico1'0%
 Operating System
 Windows
!(wil::verify_bool(CopyFileW(srcPath.GetChars(), destPath.GetChars(), 0)))
!(wil::verify_bool(hKeepRunningThread))
!(wil::verify_bool(QueryServiceStatus(service.get(), &serviceStatus)))
!(wil::verify_bool(versionSize > 0))
!0H!t$ H
!AddAccessAllowedAceEx(acl, ACL_REVISION, CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, KEY_READ, packageSid)
!CreatePrivateObjectSecurityEx( oldSecurityDescriptor, securityDescriptorToAppend, &newSecurityDescriptor, nullptr, TRUE, SEF_DACL_AUTO_INHERIT | SEF_DEFAULT_GROUP_FROM_PARENT | SEF_DEFAULT_OWNER_FROM_PARENT | SEF_AVOID_OWNER_CHECK, nullptr, &mapping)
!InitializeAcl(acl, requiredSize, ACL_REVISION)
!InitializeSecurityDescriptor(securityDescriptorToAppend, SECURITY_DESCRIPTOR_REVISION)
!l$ 3
!SetSecurityDescriptorControl(newSecurityDescriptor, SE_DACL_AUTO_INHERIT_REQ, SE_DACL_AUTO_INHERIT_REQ)
!SetSecurityDescriptorDacl(securityDescriptorToAppend, TRUE, acl, FALSE)
!This program cannot be run in DOS mode.
":NmO
"Microsoft Time Source Master Clock0
"Microsoft Window
"system" applyFilter="Yes">
"user">
#@8{8t
$`2X`F
$Microsoft Ireland Operations Limited1
%|fUN<
%CSIDL_LOCAL_APPDATA%\Microsoft\Windows\Notifications
%CSIDL_LOCAL_APPDATA%\Packages\$\SystemAppData
%hs!%p: 
%hs(%d) tid(%x) %08X %ws
%hs(%u)\%hs!%p: 
%Microsoft Windows Production PCA 2011
%Microsoft Windows Production PCA 20110
%ProgramData%\Microsoft\Windows\AppRepository
%ProgramData%\Microsoft\Windows\AppRepository\CheckPoint.VPN_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\f5.vpn.client_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\FileManager_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\JuniperNetworks.JunosPulseVpn_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\Microsoft.MoCamera_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\SonicWALL.MobileConnect_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\windows.immersivecontrolpanel_*_cw5n1h2txyewy.xml
%ProgramData%\Microsoft\Windows\AppRepository\winstore_*_cw5n1h2txyewy.xml
%PROGRAMDATA%\Microsoft\Windows\AppxProvisioning.xml
%ProgramFiles%\WindowsApps\
%s file does not exist
%s file exists
%s for user %s is known to CapAuth
%s for user %s isn't known to CapAuth (needs Registration)
%s key not found, skipping GatherDataForProcessAllUserStorePackages
%s package is paused so its package root %s will be excluded
%s service status = 0x%x
%s\%s
%s\%s%s
%s_%s_%s_%s
%SystemRoot%\System32\
%WINDIR%\System32\AppxProvisioning.xml
%ws not found yet, filling entry
%ws: %ws
&8rKs#
(_^][
(caller: %p) 
(lastError != ERROR_FILE_NOT_FOUND)
)Microsoft Root Certificate Authority 20100
)onecore\base\appmodel\runtime\src\systemmetadatainternal.cpp
*cursor == L'\0'
*isPackageEndOfLife
,'!T[
,45rTznX0lCJdFgP1NgKPJscHxGueerKGk4X4KXxqhMU=0Z
,D9>t
... Package %ws is all-user installed so no need to write its upgrade key
... Package %ws is being end of lifed so it's being written to the EndOfLife key
... Package %ws is dev mode. Writing to upgrade keys
... Package %ws is LOB so no need to write its upgrade key
... Package %ws is NOT being end of lifed so it's being written to the Downlevel Installed key
... Package %ws is not installed. Nothing to do
... Package %ws is OEM so no need to write its upgrade key
... Package's root is %ws
... Unable to process recovery info for package 0x%x. Assume this app is fully on system volume
.?AVexception@@
.?AVResultException@wil@@
.00cfg
.CRT$XCA
.CRT$XCL
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIAA
.CRT$XIZ
.data
.data$brc
.data$r$brc
.edata
.gfids
.giats
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.L9}8t7M
.pdata
.rdata
.rdata$brc
.rdata$zETW0
.rdata$zETW1
.rdata$zETW2
.rdata$zETW9
.rdata$zzzdbg
.recovery
.rsrc$01
.rsrc$02
.text
.text$di
.text$mn
.text$mn$00
.text$x
.text$yd
.xdata
.xdata$x
.xn--
/OfflineSoftwareHive:"
:%|fUu3
:|I}0<
;E@wB
??0exception@@QEAA@AEBV0@@Z
??0exception@@QEAA@XZ
??1exception@@UEAA@XZ
??1type_info@@UEAA@XZ
?terminate@@YAXXZ
@.data
@.reloc
@.rsrc
@8,1u
@8{0t
@8|$Au
@8=@,
@8={,
@8y(t
@97t<A
@A^_]
@A_A^_
@A_A^_^]
@A_A^A\_^
@A_A^A\_^[]
@A_A^A]_^
@A_A^A]A\_
@A_A^A]A\_^[
@A_A^A]A\_^]
@FamilyName
@FullName
@IsLOBApp
@L9}@tyD
@PackageType
@ProvisionSourceIsBundle
@SUVWATAUAVAWH
@SUVWAVAWH
@SVWH
@USVATAUAVAWH
@USVWATAUAVAWH
@USVWATAUAVH
@USVWATAUAWH
@USVWATAVAWH
@USVWAUAVH
@USVWAVAWH
@USVWAVH
@USVWH
@USWH
@UVWATAUAVAWH
@UVWAVAWH
@UVWH
@UWATAVAWH
@UWAVH
@VWAVH
@VWAWH
@WAVAWH
[ UVWH
[%hs(%hs)]
[%hs]
[Desktop Only] Failed to find cellular modem in the descover phase.
[Desktop Only]Package family %ws is end-of-lifed
\$ E3
\$ UH
\$ UVWAVAWH
\$pE3
\* [*]</pattern>
\*.xml
\\?\UNC\
\Applications\
\AppxManifest.xml
\AppxMetadata\AppxBundleManifest.xml
\Autogen
\Frameworks\
\InfusedApps
\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage
\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Families
\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Packages
\microsoft.system.package.metadata
\OSRollbackPackages.txt
\Packages\
\PluginExecutedFixStateRepository
]</pattern>
]8H!]0H!]@H
]HD8}8
]HfA;
__C_specific_handler
__CxxFrameHandler3
__dllonexit
_amsg_exit
_Classes
_CxxThrowException
_initterm
_lock
_onexit
_purecall
_unlock
_vsnprintf_s
_vsnwprintf
_wcsicmp
_wcsnicmp
_XcptFilter
` UAVAWH
`.rdata
`A_A^]
`A_A^_^]
`A_A^A\^]
`A_A^A]A\_^]
{OX,*
|$ AVH
|$ E3
|$DE3
|$PL9t$Hu
|hK,_
|lFfe
}@fD9}0t&H
}0H+}(H
}bgk#!F
}bwu3
}HD8}8
</objectSet></exclude>
</objectSet></include>
</objectSet></locationModify>
</objectSet></merge>
</objectSet></unconditionalExclude>
</rules></migXml>
<?xml version="1.0" encoding="utf-8"?><xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns:m="http://schemas.microsoft.com/appx/2013/appxprovisionpackage" xmlns:xs="http://www.w3.org/2001/XMLSchema"><xs:element name="AppxProvisionList">  <xs:complexType>    <xs:all>      <xs:element name="EndOfLife" type="CT_EndOfLife" minOccurs="0"/>      <xs:element name="Provisioned" type="CT_Provisioned" minOccurs="0"/>    </xs:all>  </xs:complexType>  <xs:unique name="Package_FamilyName">    <xs:selector xpath="m:EndOfLife/m:Package"/>    <xs:field xpath="@FamilyName"/>  </xs:unique>  <xs:unique name="Package_FullName">    <xs:selector xpath="m:Provisioned/m:Package"/>    <xs:field xpath="@FullName"/>  </xs:unique></xs:element><xs:complexType name="CT_EndOfLife">  <xs:sequence>    <xs:element name="Package" maxOccurs="unbounded">      <xs:complexType>        <xs:attribute name="FamilyName" type="ST_FamilyName" use="required"/>      </xs:complexType>    </xs:element>  </xs:sequence></xs:complexType><xs:complexType name="CT_Provisioned">  <xs:sequence>    <xs:element name="Package" maxOccurs="unbounded">      <xs:complexType>        <xs:attribute name="FullName" type="ST_FullName" use="required"/>        <xs:attribute name="PackageType" type="ST_PackageType"/>        <xs:attribute name="ProvisionSourceIsBundle" type="xs:boolean"/>        <xs:attribute name="IsLOBApp" type="xs:boolean"/>      </xs:complexType>    </xs:element>  </xs:sequence></xs:complexType><xs:simpleType name="ST_FamilyName">  <xs:restriction base="xs:string">    <xs:minLength value="17"/>    <xs:maxLength value="64"/>  </xs:restriction></xs:simpleType><xs:simpleType name="ST_FullName">  <xs:restriction base="xs:string">    <xs:minLength value="30"/>    <xs:maxLength value="127"/>  </xs:restriction></xs:simpleType><xs:simpleType name="ST_PackageType">  <xs:restriction base="xs:string">    <xs:enumeration value="resource"/>    <xs:enumeration value="framework"/>    <xs:enumeration value="bundle"/>  </xs:restriction></xs:simpleType></xs:schema>
<@/t5L
<@\t=fB
<exclude><objectSet>
<include><objectSet>
<locationModify script="MigXmlHelper.RelativeMove(&apos;%ProgramFiles%\WindowsApps&apos;,&apos;%ProgramFiles%\WindowsApps\SharedLimitedTime&apos;)"><objectSet>
<locationModify script="MigXmlHelper.RelativeMove(&apos;%windir%\InfusedApps&apos;,&apos;%ProgramFiles%\WindowsApps\SharedLimitedTime\InfusedApps&apos;)"><objectSet>
<merge script="MigXmlHelper.DestinationPriority()"><objectSet>
<merge script="MigXmlHelper.SourcePriority()"><objectSet>
<migXml xmlns=""><rules context=
<P/u(
<pattern type="File">
<pattern type="Registry">
<String too big>
<unconditionalExclude><objectSet>
>5@1I5
>ARI8u
>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0
>http://www.microsoft.com/pki/certs/MicTimStaPCA_2010-07-01.crt0
040904B0
0A^_]
0A^_^
0A__^
0A_A^_
0A_A^_^]
0A_A^A\
0A_A^A\_^
0A_A^A\_^[]
0A_A^A]A\_
0A_A^A]A\_^]
0x%x: Could not get path to provisioning XML -- not performing EOL and provisioned-package cleanup
1(0&0
1,0*0
10.0.19041.1
10.0.19041.1 (WinBuild.160101.0800)
100701213655Z
111019184142Z
1234567890abcdefghjkmnpqrstvwxyzABCDEFGHJKMNPQRSTVWXYZ
190502212436Z
190906204119Z
1http://www.microsoft.com/PKI/docs/CPS/default.htm0@
200502212436Z0p1
201204204119Z0
20191207005713Z
20191207010511.262Z0
20191208005713Z0t0:
229879+4541120
250701214655Z0|1
261019185142Z0
48~Q6}n
5fD9g
6}^co.
8A^_^[
90v,H
9A98u6A9x
9N4tN
9N4tW
9O$tQ
9O4t>
9O4tB
9O4tN
9r0tAA
9r0t-H!t$ H
a tSH
A!4$I
A(;A,H
A(t&H
A,9A(
A^_^[]
A^A\]
A^A\_^]
A^A]]
A^A]_^[]
A^A]A\_]
A^A]A\_^[]
A_A]A\_]
A_A]A\_^[]
A_A^]
A_A^_^[]
A_A^_^]
A_A^A\
A_A^A\_]
A_A^A\_^
A_A^A]_]
A_A^A]A\]
A_A^A]A\^[]
A_A^A]A\_
A_A^A]A\_^[]
A_A^A]A\_^]
A_A^A]A\_^][
A8_8t
A9~(v-
A9~0u
AcquireSRWLockExclusive
AcquireSRWLockShared
AddAccessAllowedAceEx
AddPackageRegistryKeyToArray(fullName, &bundleFullNames)
AddPackageRegistryKeyToArray(fullName, &packageFullNames)
AddUplevelPackageToDelete(subKey, keysToDelete)
ADVAPI32.dll
AllowRegistryKeyReadForPackage failed: [%s]0x%x
allUserApplicationsKey.CopyTree(packageToWrite, mainPackageKey)
allUserApplicationsKey.DeleteSubKeyTree(keysToDelete[i]->GetChars())
allUserApplicationsKey.OpenIfExists(HKEY_LOCAL_MACHINE, allUserStoreApplicationsPath.GetChars(), KEY_READ)
allUserApplicationsKey.OpenSubKey(subKey, KEY_READ, &mainPackageKey)
allUserApplicationsKey.SetUInt32Value(regIuiPolicyCheckedString, 1)
allUserStoreKey.CreateSubKey( AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE | WRITE_DAC, &deprovisionedKey)
allUserStoreKey.GetKeySecurity(DACL_SECURITY_INFORMATION, allUserStoreSD)
allUserStoreKey.Open( HKEY_LOCAL_MACHINE, effectiveAllUserStorePath, KEY_READ | KEY_WRITE | WRITE_DAC)
allUserStoreKey.Open(HKEY_LOCAL_MACHINE, allUserStorePath.GetChars(), KEY_READ)
allUserStoreKey.Open(HKEY_LOCAL_MACHINE, offlineAllUserStorePath.GetChars(), KEY_READ)
allUserStoreKey.OpenSubKey( s_Applications, KEY_READ | KEY_WRITE | WRITE_DAC, &allUserApplicationsKey)
allUserStoreKey.OpenSubKey( s_EndOfLife, KEY_READ | KEY_WRITE | WRITE_DAC, &endOfLifeKey)
allUserStoreKey.OpenSubKey( s_Staged, KEY_READ | KEY_WRITE | WRITE_DAC, &stagedKey)
allUserStoreKey.OpenSubKey(s_Staged, KEY_READ, &allUserStagedKey)
allUserStoreKey.OpenSubKey(userSid, KEY_READ, &userKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::allUserApplicationsString, KEY_READ, &allUserApplicationsKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::deprovisionedString, KEY_READ, &deprovisionKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::inboxApplicationsString, KEY_READ, &inboxApplicationsKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::stagedApplicationsString, KEY_READ, &stagedKey)
allUserStoreKey.OpenSubKeyIfExists(AppxAllUserStore::upgradeApplicationsString, KEY_READ, &upgradeKey)
allUserStoreKey->OpenSubKey(AppxAllUserStore::deprovisionedString, KEY_READ, &deprovisionKey)
api-ms-win-appmodel-runtime-l1-1-1.dll
api-ms-win-core-com-l1-1-0.dll
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-heap-obsolete-l1-1-0.dll
api-ms-win-core-io-l1-1-0.dll
api-ms-win-core-kernel32-legacy-l1-1-0.dll
api-ms-win-core-libraryloader-l1-1-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-processenvironment-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-registry-l1-1-0.dll
api-ms-win-core-rtlsupport-l1-1-0.dll
api-ms-win-core-string-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-core-threadpool-l1-2-0.dll
api-ms-win-core-version-l1-1-0.dll
api-ms-win-core-winrt-error-l1-1-0.dll
api-ms-win-core-winrt-l1-1-0.dll
api-ms-win-core-winrt-string-l1-1-0.dll
api-ms-win-eventing-provider-l1-1-0.dll
api-ms-win-security-base-l1-1-0.dll
api-ms-win-security-provider-l1-1-0.dll
api-ms-win-security-sddl-l1-1-0.dll
api-ms-win-service-management-l1-1-0.dll
api-ms-win-service-winsvc-l1-1-0.dll
AppDataVolumeKey
AppDataVolumeName
AppDB
appdb.dat
AppendPackagePathAndApplyTrustLabel(offlinePackagePath.GetChars(), applicationPath, offlineSoftwareHive, cmdLineBuilder)
APPID
Applications
applicationsKey.GetUInt32Value(appxUpgradeNeededValueName, &appxUpgradeNeededValue)
applicationsKey.GetUInt32Value(noReRegisterOnUpgradeValueName, &noReRegisterOnUpgradeValue)
applicationsKey.GetUInt64Value(downlevelOSVersionValueName, &this->downlevelOSVersion)
applicationsKey.SetUInt32Value(appxUpgradeNeededValueName, this->appxUpgradeNeeded ? 1 : 0)
applicationsKey.SetUInt32Value(noReRegisterOnUpgradeValueName, this->noReRegisterOnUpgrade ? 1 : 0)
applicationsKey.SetUInt64Value(downlevelOSVersionValueName, this->downlevelOSVersion)
applicationsPathBuilder.AppendString(Common::Deployment::applicationsDir)
applicationsPathBuilder.AppendString(infusedAppsFolder.GetChars())
Applying downlevel stub preference %d for package %ws
ApplySuccessFailed
ApplyTrustLabel(cmdLineBuilder.GetChars())
ApplyTrustLabelToPackages failed 0x%x
ApplyTrustLabelToPackagesUnderRegistryKey(&packageFamilyKey, applicationPath, offlineSoftwareHive, cmdLineBuilder)
ApplyTrustOffline.exe
AppModelPackageRepository
AppModelRoot
AppReadiness
AppsEOL
Appx Migration Plugin called RtlGetDeviceFamilyInfoEnum: downlevelOSVersion=0x%llx
Appx Migration Plugin called SRCheckIntegrity(%s): Entrypoint not found (0x%x)
Appx Migration Plugin called SRCheckIntegrity(%s): Module (%s) not present
Appx Migration Plugin called SRCheckIntegrity(%s): Module not loaded (0x%x)
Appx Migration Plugin version number is %d.%d.%d.%d
Appx Migration Plugin will not perform re-registration of Packages (OSupgradeInPlace)
Appx Migration Plugin will perform re-registration of Packages (OSswap)
Appx Upgrade Migration Plugin
AppX*
AppxAllUserStore
AppxAllUserStore::GetAllUserApplicationsFullPath(&allUserStoreApplicationsPath)
AppxAllUserStore::GetAllUserStoreFullPath(&allUserStorePath)
AppxAllUserStore::GetAllUserStoreFullPath(&allUserStorePathBuffer)
AppxAllUserStore::GetEndOfLifeApplicationsFullPath(&endOfLifePath)
AppxAllUserStore::GetInboxApplicationsFullPath(&inboxPackagesBuffer)
AppxAllUserStore::GetStagedApplicationsFullPath(&allUserStoreStagedPath)
AppxAllUserStore::GetUpgradeApplicationsFullPath(&upgradePath)
AppxAllUserStore::SetPackageOverrideSetupPhaseHelper(packageFamilyName.GetChars(), AppxAllUserStore::c_setupPhase_PostShell)
AppxCleanupOrphanPackages
AppxCleanupOrphanPackages()
AppxCleanupSystemAppsMigratedToFOD
AppxCleanupSystemAppsMigratedToFOD()
AppxDeploymentClient.dll
AppxDestagePackage
appxFactory->CreateBundleManifestReader(manifestStream.Get(), bundleManifestReader.GetAddressOf())
AppxManifest.xml
AppxMetadata\AppxBundleManifest.xml
AppxPackageVolumes
AppxPreRegisterAllInboxPackages
AppxPreRegisterAllInboxPackages failed: 0x%x
AppxPreRegisterPackage
AppxProvisioning.xml not found in programdata folder, trying system32 location
AppxProvisionList
AppxRoot
AppxStateChange
AppxSvc
AppxUpgradeMigration discontinuing plug-in timeout extension.
AppxUpgradeMigration executing longer than expected.
AppXUpgradeMigration exiting.
AppXUpgradeMigration signaling extension thread.
AppxUpgradeMigration::AppxUpgradeMigration: cellular apps was already EOL
AppxUpgradeMigration::AppxUpgradeMigration: cellular apps was already EOL %lu
AppxUpgradeMigration::AppxUpgradeMigration: failed reading EOL reg vaue
AppxUpgradeMigration::AppxUpgradeMigration: Failed to write cellular already EOL reg key value
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: CLSIDFromString error = %8.8X
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Enter
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Exit
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: failed DevObjOpenDevRegKey error = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: failed NetCfgInstanceId error = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Failed to write cellular reg key value
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: found only one interface, skipping check
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: Found wireless WAN
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: foundCellularModem = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: has modem = %lu
AppxUpgradeMigration::CheckForCellularModemInstalledOrFoundBefore: index = %lu
AppxUpgradeMigration::Discover called
AppxUpgradeMigration::Discover done (0x%x)
AppxUpgradeMigration::FoundCellularModemInstalled: failed to find a modem from the 'gather' phase
AppxUpgradeMigration::FoundCellularModemInstalled: Found a modem from a prior run = %lu.
AppxUpgradeMigration::FoundCellularModemInstalled: Found a modem from the 'gather' phase
AppxUpgradeMigration::FoundCellularModemInstalled: value doesn't exist
AppxUpgradeMigration::Gather called
AppxUpgradeMigration::IsWirelessWanInterfaceType ConvertInterfaceGuidToLuid error = %lu
AppxUpgradeMigration::IsWirelessWanInterfaceType GetIfEntry2 error = %lu
AppxUpgradeMigration::IsWirelessWanInterfaceType mib.MediaType = %lu
AppxUpgradeMigration::IsWirelessWanInterfaceType mib.PhysicalMediumType = %lu
AppxUpgradeMigration:EOL-Messaging/MobilePlans
AppxUpgradeMigrationPlugin.dll
APPXUPGRADEMIGRATIONPLUGIN.dll
AppxUpgradeMigrationPlugin.pdb
AppxUpgradeNeeded
arm64
ATAVAWH
ATL$__a
ATL$__m
ATL$__z
AutoCheckIntegrity
Autogen
autogenDirectoryPath.SetValueFromString(this->singleInstanceStore.GetChars())
backupManifestPathBuilder.AppendString(backupManifestDir.GetString())
backupManifestPathBuilder.AppendString(L".xml")
backupManifestPathBuilder.AppendString(L"\\")
backupManifestPathBuilder.AppendString(package)
BH9l$xt}
bstrOnlineFilePath.CopyFromString(onlineFilePath)
bstrOnlineRegistryPath.CopyFromString(onlineRegistryPathBuffer.GetChars())
bstrPath.CopyFromString(path.GetChars())
bstrSisPath.CopyFromString(sisPath)
bundle
Bundle
Bundle %ws is being written to the downlevel installed key
BundleFullName
bundleInfoRootKey.CreateSubKey(bundleFullName, KEY_READ | KEY_WRITE, &bundleKey)
bundleInfoRootKey.OpenSubKey(bundleFullName, KEY_READ, &bundleKey)
bundleKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
bundleKey.OpenSubKey(packageFullName, KEY_READ, &packageKey)
BundleManifestInfo
bundleManifestReader->GetPackageInfoItems(&packages)
bundlesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
BX9A4t
C @8}Wu
C9fD9?u-
callContext
CallContext:[%hs] 
Calling ApplyTrustLabel
Calling DeleteOSRollbackPackagesRegistry
Calling SavePackageListFromFileToRegistry
CallRtlGetDeviceFamilyInfoEnumIfFunctionAvailable(nullptr, &deviceFamily, nullptr)
Cannot find package %ws in SIS, not writing to Staged Key
CellularAppsRemoved
cfD9eP
CheckIfLessPreferredPackageShouldBePreservedUsingGatheredData(packageFullName, packageFamilyName, &preservePackage)
CheckOrFixStateRepositoryViaExport called to %s
CheckOrFixStateRepositoryViaExport done %s. Disposition: %d
CheckRepository(Fix) reports Disposition=%d, #ErrorsCorrected=%I64u
Chttp://www.microsoft.com/pkiops/crl/MicWinProPCA2011_2011-10-19.crl0a
Cleaning up orphan packages from downlevel OS
Cleaning up SystemApps migrated to FOD
CloseHandle
CloseServiceHandle
CloseThreadpoolTimer
CLSIDFromString
cmdLine.get() != nullptr
cmdLineBuilder.AppendChar(L' ')
cmdLineBuilder.AppendChar(L'\"')
cmdLineBuilder.AppendString(applicationPath)
cmdLineBuilder.AppendString(offlineSoftwareHive)
cmdLineBuilder.AppendString(offlineSoftwareHiveParam)
cmdLineBuilder.AppendString(packagePath)
CoCreateInstance
CoCreateInstance( __uuidof(AppxBundleFactory), NULL, CLSCTX_INPROC_SERVER, __uuidof(IAppxBundleFactory), &appxFactory)
CoCreateInstance( __uuidof(OpcFactory), NULL, CLSCTX_INPROC_SERVER, __uuidof(IOpcFactory), &opcFactory)
CoGetApartmentType
com1.
com2.
com3.
com4.
com5.
com6.
com7.
com8.
com9.
Common::Deployment::Configuration::GetPackageRepositoryRoot(&this->packageRepository)
Common::Deployment::GetPackageIDFromPackageMoniker( existingFullName, nullptr, &existingPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( packageFullName, nullptr, &currentPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( provisionedInstalledPackageFullName, nullptr, &existingPackageID)
Common::Deployment::GetPackageIDFromPackageMoniker( uplevelProvisionedPackage, nullptr, &provisionedPackageID)
Common::Deployment::GetVersionlessNameFromPackageFullName( fullName, &versionlessName)
Common::Deployment::GetVersionlessNameFromPackageFullName( packageFullName, &versionlessName)
Common::Deployment::GetVersionlessNameFromPackageFullName(packageFullName, &versionlessName)
Common::Deployment::ManifestCache::UpdateOptions(Common::Deployment::ManifestCache::Options_ReloadAllInbox)
Common::Deployment::SaveWindowsAppsPackageListToFile(filename.GetChars())
Common::DirectoryExists(autogenDirectoryPath.GetChars(), &folderExists)
Common::DirectoryExists(folderPath, &folderExists)
Common::DirectoryExists(metadataFolder.GetChars(), &metadataExistsInPackageRoot)
Common::DirectoryExists(metadataFolderInSharedLimitedTime.GetChars(), &packageExistsInSharedLimitedTime)
Common::DirectoryExists(systemMetadataDirectoryForPackage, &systemMetadataForPackageExists)
Common::FileExists(applyTrustLabelAppFullPath.GetChars(), &fileExists)
Common::FileExists(fileName.GetChars(), &fileExists)
Common::FileExists(recoveryFileFullPath.GetChars(), &recoveryFileExists)
Common::FileExists(sourceBackupManifestFilePathBuilder.GetChars(), &sourceFileExists)
Common::FileExists(targetBackupManifestFilePath.GetChars(), &targetFileExists)
Common::StateSeparation::GetPackageRepositoryPackagesPath(nullptr, &packageRepositoryPackagesKeyPath)
Common::StateSeparation::GetPersistedRegKeyPath(Common::StateSeparation::AppModelRoot, &s_StubPreference, 1, &stubPreferenceKeyPath)
Common::StateSeparation::GetPersistedRegKeyPath(Common::StateSeparation::AppxStateChange, subkeys, ARRAYSIZE(subkeys), &fullPath)
Common::String::CaseInsensitiveStartsWith(subKey, L"S-", &isUserSid)
CompanyName
CompareStringOrdinal
Completed AppxPreRegisterAllInboxPackages
Completed EnsureAppRootPermissions - processed %i of %i directories.
Completed EnsureFamiliesRegistryKeyPermissions
Completed EnsureRegistryKeyPermissions
Completed EnumAndAddPackagesNotKnownToCapAuth
Completed FixStateRepositoryIntegrity -- was already run so no action needed.
Completed FixStateRepositoryIntegrity successfully.
Completed RepairPackageRepositoryKeyInHKLM
Completed RepairPackageRootFolderPathInRepositoryRegistryKey
Completed RepairStateRepository successfully.
context->ExpandEnvironmentVariables(pathBstr, &expandedPath)
context->get_WorkingDir(&workingDir)
context->GetOfflineFileLocation(expandedPath, &offlinePath)
context->GetOfflineStatus(&offlineExecution)
ConvertInterfaceGuidToLuid
ConvertStringSidToSid(packageContentsCapabilitySid, &packageContentsSid)
ConvertStringSidToSidW
CopyFile(sourceBackupManifestFilePath.GetChars(), targetBackupManifestFilePath.GetChars(), FALSE)
CopyFileW
CopyRegistryKeyWithoutAcls(allUserStoreKey, pluginAllUserStoreKey)
CopyRegistryKeyWithoutAcls(packageStateKey, stateChangeKey)
CopyRegistryKeyWithoutAcls(sourceSubKey, destinationSubKey)
CopyRegistryKeyWithoutAcls(stubPreferenceKey, stubPreferenceKeyCopy)
CoTaskMemAlloc
CoTaskMemFree
Could not open %ws: 0x%x -- not performing EOL and provisioned-package cleanup
CreateAppxProvisionFactory(&appxProvisionFactory)
created
createdKey->SetStringValue(AppxAllUserStore::regAppDataVolumeKeyString, value.GetChars())
createdKey->SetStringValue(AppxAllUserStore::regAppDataVolumeNameString, value.GetChars())
createdKey->SetStringValue(AppxAllUserStore::regPackageVolumeKeyString, value.GetChars())
createdKey->SetStringValue(AppxAllUserStore::regPackageVolumeNameString, value.GetChars())
CreateEventW
CreateFileW
CreateMutexExW
CreatePrivateObjectSecurityEx
CreateProcessW
CreateSemaphoreExW
CreateThread
CreateThreadpoolTimer
CreateTopLevelKeys(offlineExecution)
CreateWellKnownSid
currentContextId
currentContextMessage
currentContextName
currentPackage->packageFullName.SetValueFromString(packageFullName)
D!t$$H
d$ E3
D$ E3
D$ fD
D$(E3
d$@@8
D$@E3
D$@fD
D$`E3
D$`L9d$Xu
D$0E3
D$8E3
D$HE3
D$pE3
D$pfD98t
D$PH;
D$PH9\$Hu
D$T9p
D$X t,L
D$X9F4
D$xE3
D$XL9d$Pu
D;}(r
D;A,sOA
D;G,s)H
D8|$@
D8|$@u(L
D8|$@u\L
D8|$Xt
D8d$@
D8d$0t8I
D8d$0u;L
D8eHt%H
D8ewtqL
D8l$0t
D8l$0t)L
D8l$0u[M
D8l$1
D8M8A
D8t$@t5L
D9 u:L
D9(uOH
D9|$D
D9|$Du
D90v.H
D9d$D
D9l$\v
DeleteCriticalSection
Deleted\
DeleteFileW
Deleting Uplevel all-user key %ws because downlevel had a more preferred version
Deprovisioned
deprovisionedKey.GetKeySecurity(DACL_SECURITY_INFORMATION, deprovisionedSD)
deprovisionKey.CopyTree(nullptr, this->pluginDeprovisionedKey)
deprovisionKey.KeyExists(familyName, packageDeprovisioned)
destination.CreateSubKey(subKeyName, KEY_READ | KEY_WRITE, &destinationSubKey)
destination.SetValue(nameBuffer.GetChars(), valueBuffer.GetBufferPtr(), valueLength, valueType)
DestroyPrivateObjectSecurity
Determining if no re-registration of packages is needed failed with 0x%x. We will just default to re-registering all apps.
DeviceIoControl
DEVOBJ.dll
DevObjCreateDeviceInfoList
DevObjDestroyDeviceInfoList
DevObjEnumDeviceInfo
DevObjGetClassDevs
DevObjGetClassDevs(deviceInfoList.get(), &GUID_DEVCLASS_NET, nullptr, DOGCF_PRESENT, nullptr, 0)
DevObjOpenDevRegKey
Did not find cached migration XML, generating new one
DirectoryPaths::CreateFullFileName(destDirectory, findFileData.cFileName, &destPath)
DirectoryPaths::CreateFullFileName(sourceDirectory, findFileData.cFileName, &srcPath)
DisableThreadLibraryCalls
DiscoverFailed
DllCanUnloadNow
DllGetClassObject
Doesn't match stub preference while %ws does
Downlevel OS already had package %ws registered for user %ws, writing to UserSid Key
Downlevel OS already had package %ws registered, not writing to Staged Key
DownlevelGather
DownlevelInstalled
downlevelInstalledKey->SetUInt32Value(AppxAllUserStore::regValueIsDevModeApp, 1)
DownlevelOSVersion
DownlevelPackageRepositoryRoot
DownlevelPackageRoot
E(=csm
E;f(r
E8=csm
effectivePath.SetValueFromString(expandedPath)
effectivePath.SetValueFromString(offlinePath)
EH=csm
Eh=csm
eHfD9eP
Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z
Ehttp://crl.microsoft.com/pki/crl/products/MicTimStaPCA_2010-07-01.crl0Z
Ehttp://www.microsoft.com/pkiops/certs/MicWinProPCA2011_2011-10-19.crt0
EndOfLife
endOfLifeKey.GetKeySecurity(DACL_SECURITY_INFORMATION, endOfLifeSD)
endOfLifeKey.Open(HKEY_LOCAL_MACHINE, endOfLifePath.GetChars(), KEY_READ)
EnsureACLOnObject(SE_FILE_OBJECT, fullFilePath.GetChars(), packageContentsSid.get())
EnsureACLOnObject(SE_FILE_OBJECT, targetPath.GetChars(), packageContentsSid.get())
EnsureACLOnObject(SE_REGISTRY_KEY, perUserACLPathBuffer.GetChars(), packageContentsSid.get())
EnsureAppRootPermissions(offlineMode)
EnsureAppxDeploymentClientDllLoaded(&deploymentClientModule)
EnterCriticalSection
EnumAndAddPackagesNotKnownToCapAuth(userSid, packagesToReRegister.Get())
EnumAndAddSubKeysToStringVector(&inboxPackagesKey, packagesToReRegister.Get(), s_PackagesToReRegister)
EnumAndAddSubKeysToStringVector(&userPackagesToRegisterKey, packagesToReRegister.Get(), s_PackagesToReRegister)
EnumerateAndCachePackagesInAllUserStoreUsingGatheredData()
EnumerateUsersAndPopulateUserSids()
Enumerating pre-Win10 packages registered to %s but not known to CapAuth
EnumKey for [%s] failed: 0x%x
eolPackages->GetCurrent(&package)
error != ERROR_NO_MORE_FILES
Error getting effective rights from ACL for %ws - 0x%x
Error getting SD for %ws - 0x%x
Error retrieving IRepositoryManager 0x%x
Error retrieving IRepositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa
ERROR_INSUFFICIENT_BUFFER != fnGetStagedPackagePathByFullName(packageFullName.GetRawBuffer(nullptr), &packageRootLength, nullptr)
Erroring adding to ACL to %ws - 0x%x
Erroring setting new SD for %ws - 0x%x
EtwEventRegister
EtwEventUnregister
EtwEventWrite
EventRegister
EventSetInformation
EventUnregister
EventWriteTransfer
everyoneSid.Initialize(Common::Deployment::EveryoneSid.chars, Common::Deployment::EveryoneSid.length)
EX;0r
Ex=csm
EX=csm
Exception
Exclude infused apps failed with 0x%x. Ignoring this error.
Exclude leftover invalid registries failed with 0x%x. Ignoring this error.
Exclude leftover manifest files failed with 0x%x. Ignoring this error.
ExcludeFiles
excludeFilesKey.CreateSubKey(fileName.GetChars(), KEY_READ | KEY_WRITE, &fileKey)
excludeFilesKey.OpenSubKey(file, KEY_READ, &fileKey)
ExcludeInfusedApps
excludeInfusedAppsKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
excludeInfusedAppsKey.OpenSubKey(package, KEY_READ, &packageKey)
ExcludePackageRootIfNecessaryUsingGatheredData(existingFullName, familyName.GetChars(), checkIfLessPreferredShouldBePreserved)
ExcludePackageRootIfNecessaryUsingGatheredData(existingFullName, packageFamilyName->GetChars(), checkIfLessPreferredShouldBePreserved)
ExcludePackageRootIfNecessaryUsingGatheredData(packageFullName, familyName.GetChars(), checkIfLessPreferredShouldBePreserved)
ExcludePackageRootIfNecessaryUsingGatheredData(packageFullName, packageFamilyName->GetChars(), checkIfLessPreferredShouldBePreserved)
ExcludePackagesWithinKeyUsingGatheredData(&stagedKey, &allUserStoreStagedPath)
ExcludePackagesWithinKeyUsingGatheredData(&userSidKey, &fullPathToUserSidKey)
Excluding InfusedApps folder %ws
EXD;0r
exists
Expanded Path value: %s, value length: %u
Expanded SIS path: %s
ExpandEnvironmentStrings(appRepositoryPath, appRepositoryExpandedPath, ARRAYSIZE(appRepositoryExpandedPath)) == 0
ExpandEnvironmentStrings(appRepositoryPath, expandedPath, ARRAYSIZE(expandedPath)) == 0
ExpandEnvironmentStringsW
ext-ms-onecore-appmodel-staterepository-internal-l1.dll
ext-ms-win-security-capauthz-l1-1-1.dll
F0D8#ubD8c
f9,Au
f9,Ku
f9<Au
f9<Bu
f94{u
f94Cu
f94Ku
fA9,@u
fA9<@u
Failed looking for a cellular modem
Failed processing bundle %s with 0x%x. Ignoring failure to continue with processing
Failed processing framework package %s with 0x%x. Ignoring failure to continue with processing
Failed Processing inbox or devmode package for user with 0x%x. Ignoring failure to continue with processing
Failed processing main package %s with 0x%x. Ignoring failure to continue with processing
Failed processing optional package %s with 0x%x. Ignoring failure to continue with processing
Failed Processing package for user with 0x%x. Ignoring failure to continue with processing
Failed processing resource package %s with 0x%x. Ignoring failure to continue with processing
Failed querying CapAuth for user=%s package=%s: 0x%X
Failed to ApplyTrustLabel - CreateProcess Failed - 0x%x - %s
Failed to ApplyTrustLabel - GetExitCodeProcess Failed - 0x%x - %s
Failed to ApplyTrustLabel - InitializeProcThreadAttributeList Failed - 0x%x - %s
Failed to ApplyTrustLabel - UpdateProcThreadAttribute Failed - 0x%x - %s
Failed to ApplyTrustLabel offline to Plugin Staged Packages - 0X%x
Failed to ApplyTrustLabel offline to Plugin Staged User Acquired Packages - 0X%x
Failed to ApplyTrustLabel offline to PreInstalled Packages - 0X%x
Failed to create per-machine keys 0x%x
Failed to create reg key %ws with 0x%x
Failed to enumerate all users with 0x%x
Failed to enumerate downlevel installed packages for the user %ws with 0x%x, will re-install all apps
Failed to enumerate packages for the user %ws with 0x%x
Failed to exclude file %ws in XML Writer: 0x%x
Failed to exclude registry %ws in XML Writer: 0x%x
Failed to get junction target for : %ws - 0x%x
Failed to get Registry key value [%s]
Failed to get WorkingDir 0x%x
Failed to include directory %ws in XML Writer: 0x%x
Failed to include directory %ws, file %ws in XML Writer: 0x%x
Failed to include registry %ws in XML Writer: 0x%x
Failed to include registry key %ws, value %ws in XML Writer: 0x%x
Failed to merge registry %ws in XML Writer: 0x%x
Failed to merge registry key %ws, value %ws in XML Writer: 0x%x
Failed to move directory %ws to backup folder in XML Writer: 0x%x
Failed to open reg key %ws with 0x%x
Failed to PerformApplySuccessOnlinePerMachineTasks with 0x%x
Failed to process all installed packages with 0x%x
Failed to process all user store packages with 0x%x
Failed to process AppxProvisioning XML for end of life packages 0x%x. Proceeding as if AppxProvisioning XML does not exist so user acquired apps get processed
Failed to process bundle manifest packages: 0x%x. Excluding Bundle.
Failed to processing all packages during AppxUpgradeMigration ApplySuccess with 0x%x
Failed to repair reg value [%s] for package %s, hr: 0x%x
Failed to set the FlushInboxCachedManifests in the AppxAllUserStore with 0x%x
Failed to update registry ACLs for '%s': 0x%x.
Failed to write oem uninstalled packages for user %ws with 0x%x
Failed to write out migration XML with 0x%x
Failed to write packages to re-register for user %ws with 0x%x
Failed to write provisioned packages to staged list with 0x%x
Failed with 0x%08lx reading %ws value PackageStatus, assuming package has no in-place update pending
Failed with 0x%x to set %ws key value
FailFast
failureCount
failureId
failureType
FallbackError
false
familiesKey.OpenSubKey(familyName.GetChars(), KEY_ALL_ACCESS, &packageKey)
FamilyName
familyName->GetLength() == familyNameLength
familyName->SetLength(familyNameLength)
familyName->SetValue(fullName, nameLength)
familyNameBuffer.SetValueFromString(familyName.GetChars())
familyNameBuffer.SetValueFromString(packageFamilyName)
familyNameBuilder.AppendString(cursor)
fD9 t
fD9$^u
fD9$Au
fD9$Wu
fD9$yu
fD9&u
fD9(t
fD9,Vu
fD9+tRH
fD9+ts
fD9+u
fD9<Au
fD90t,
fD98t
fD9eHt
fD9ePt>D8eH
fD9mHA
fD9mHt#H
fD9t]
fD9u 
fD9u@u
fD9u0u_H
fD9u8
fE9,Au
fE9,Pu
fF9$Bu
File %s in working dir: %s
File: %ws
FileDescription
fileKey.GetStringValue(s_Path, &filePath)
fileKey.SetStringValue(s_Path, fullFilePath.GetChars())
fileName
fileName.SetLength(fileName.GetLength() - wcslen(L".xml"))
fileName.SetValueFromString(findFileData.cFileName)
fileNameBuilder.AppendChar('\\')
fileNameBuilder.AppendString(expandedPath)
filenameBuilder.AppendString(OSRollbackPackagesFilename)
fileNameBuilder.AppendString(stateRepositoryMachineDatabase)
fileNameBuilder.AppendString(stateRepositoryWalFile)
filenameBuilder.AppendString(workingDir)
FileVersion
FindClose
FindFirstFileW
findMethod(packageInfoCollection.GetAddressOf())
FindNextFileW
Finished AppxUpgradeMigration ApplySuccess for %s with 0x%x
Finished AppxUpgradeMigration ApplySuccess offline with 0x%x
Fixing
FixStateRepositoryIfPossible called
FixStateRepositoryIfPossible completed Disposition=%d
FixStateRepositoryIfPossible failed (0x%x) Disposition=%d
FixStateRepositoryIfPossible(disposition)
FixStateRepositoryIntegrity(repositoryManager)
FixStateRepositoryIntegrityCompleted
FixStateRepositoryOrResetMaintenance already executed
FixStateRepositoryOrResetMaintenance called
FixStateRepositoryOrResetMaintenance done
FixStateRepositoryOrResetMaintenance()
FixStateRepositoryViaExport(disposition)
FixStateRepositoryViaRepositoryManager called
FixStateRepositoryViaRepositoryManager done. Disposition %d
FixStateRepositoryViaRepositoryManager(disposition)
FlushInboxCachedManifests
folderPathBuilder.AppendString(backupFolderNameWithSlash)
folderPathBuilder.AppendString(fullName)
folderPathBuilder.AppendString(L"\\")
folderPathBuilder.AppendString(systemMetadataFolder)
folderPathBuilder.AppendString(this->singleInstanceStore.GetChars())
FormatMessageW
Found cached migration XML
Found Ghosts Entries: %d. Repaired Ghost Entries: %d.
Found IRepositoryManager
Found IRepositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa
Found path value [%s] that needs repair: %s
Framework
framework
frameworkPackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
frameworksPathBuilder.AppendString(Common::Deployment::frameworksDir)
frameworksPathBuilder.AppendString(infusedAppsFolder.GetChars())
FreeLibrary
fullFilePath->SetValue( moduleFullPath, static_cast<ULONG>(lastBackslash + 1 - moduleFullPath))
fullFilePathBuilder.AppendString(expandedSystem32Path)
fullFilePathBuilder.AppendString(findFileData.cFileName)
fullFilePathBuilder.AppendString(L"\\")
fullFilePathBuilder.AppendString(packagePath)
fullFilePathBuilder.AppendString(path)
fullFilePathBuilder.AppendString(this->packageRepository.GetString())
fullFilePathBuilder.AppendString(this->singleInstanceStore.GetChars())
FullName
fullName.Initialize(packageFullName)
fullNameAsString.Initialize(packageFullName)
fullNameBuffer.SetValueFromString(fullName)
fullNameBuffer.SetValueFromString(fullNameToWrite)
function
FX9G4t;
Gather.FixStateRepositoryOrResetMaintenance.Failed
GatherDataForExcludeAllInfusedApps()
GatherDataForExcludeAllInfusedAppsInFolder(applicationsFolder.GetChars())
GatherDataForExcludeAllInfusedAppsInFolder(frameworksFolder.GetChars())
GatherDataForExcludeAllInfusedAppsInFolder(packagesFolder.GetChars())
GatherDataForExcludeLeftoverManifestFiles()
GatherDataForProcessAllBundleResourceAndOptionalPackages()
GatherDataForProcessAllInstalledPackages()
GatherDataForProcessAllMainAndFrameworkPackages()
GatherDataForProcessAllUserStorePackages()
GatherDataForProcessBundleManifestPackages(packageFullName)
GatherDataForProcessPackagesForUser(this->userSids.At(i)->GetChars())
GatherDataForWriteOutPerMachineMigrationXml()
GatherDownlevelData()
GatherFailed
Gathering bundle manifest data for %s
Gathering data for bundle %s
Gathering data for main or framework package %s
Gathering data for optional package %s
Gathering data for resource package %s
Gathering data for user package %s
Gathering install state for package %s
Gathering packages installed for user %s
GatherInstallStateForAllPackages()
GatherInstallStateForPackage(packageManager.Get(), package, packageFullName, installStateRootKey)
GatherPackageDataForUser(packageManager.Get(), package, packageFullName, userSid, packageKey)
GatherSingleInstanceStoreDirectories()
GenerateSystemMigrationXml(xmlStream)
GetCurrentProcess
GetCurrentProcessId
GetCurrentThreadId
GetEffectiveRegistryPath(RegistryHive::HKLM, allUserStorePathBuffer.GetChars(), offlineMode, effectiveAllUserStorePathBuffer, effectiveAllUserStorePath)
GetEffectiveRegistryPath(RegistryHive::HKLM, packageRepositoryPackagesKeyPath, offlineMode, effectivePackageRepositoryPackagesKeyPathBuffer, effectivePackageRepositoryPackagesKeyPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, offlineExecution, effectivePluginKeyPathBuffer, effectivePluginKeyPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, offlineExecution, effectivePluginPathBuffer, effectivePluginPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, offlineMode, effectivePluginPathBuffer, effectivePluginPath)
GetEffectiveRegistryPath(RegistryHive::HKLM, stubPreferenceKeyPath, offlineExecution, effectiveStubPreferenceKeyPathBuffer, effectiveStubPreferenceKeyPath)
GetEffectiveRegistryPath(RegistryHive::HKU, perUserRegistryPathBuffer.GetChars(), offlineMode, effectivePerUserRegistryPathBuffer, effectivePerUserRegistryPath)
GetEffectiveRegistryPath(RegistryHive::HKU, userPath.GetChars(), offlineMode, effectiveUserPathBuffer, effectiveUserPath)
GetEffectiveRightsFromAclW
GetExitCodeProcess
GetFamilyNameFromFullName(fullName, &familyName)
GetFamilyNameFromFullName(packageFullName, &familyName)
GetFamilyNameFromFullName(packageFullName, &packageFamilyName)
GetFamilyNameFromFullName(subKey, &packageFamilyName)
GetFamilyNameFromFullName(WindowsGetStringRawBuffer(packageFullName, nullptr), &packageFamilyName)
GetFileAttributesW
GetFileVersionInfoEx(FILE_VER_GET_LOCALISED | FILE_VER_GET_NEUTRAL, appxUpgradeMigrationPluginFileName, 0, versionSize, versionData)
GetFileVersionInfoExW
GetFileVersionInfoSizeExW
GetIfEntry2
GetInboxOrDevModePackageRootForUser(package, manifestPath)
GetInstalledBundleForUser(packageFamilyName, userSid, &bundleName)
GetIsInboxPackageUsingGatheredData(packageFullName, &isInboxPackage)
GetIsPackageDeprovisionedInAllUserStoreUsingGatheredData(familyName.GetChars(), false , &packageDeprovisioned)
GetIsPackageDeprovisionedInAllUserStoreUsingGatheredData(packageFamilyName, false , &packageDeprovisioned)
GetIsStubPreferredForPackageFamilyUsingGatheredData(familyName.GetChars(), &preferStubForFamily)
GetIsStubPreferredForPackageFamilyUsingGatheredData(packageFamilyName, &preferStub)
GetIsStubPreferredForPackageFamilyUsingGatheredData(packageFamilyName.GetChars(), &downlevelPreference)
GetIsStubPreferredForPackageFamilyUsingGatheredData(packageFamilyName->GetChars(), &preferStubForFamily)
GetLastError
GetMetadataFolderForPackage(fullName, false , &metadataFolder)
GetMetadataFolderForPackage(fullName, true , &metadataFolderInSharedLimitedTime)
GetModuleFileName failed 0x%x -- unable to create full file path for %s
GetModuleFileNameW
GetModuleHandleW
GetNamedSecurityInfoW
GetOfflineFilePath(packagePath.GetChars(), &offlinePackagePath)
GetOfflineFilePath(this->singleInstanceStore.GetChars(), &offlineSystemSisPath)
GetOfflineRegistryPath(hive, path, &resultBuffer)
GetOfflineRegistryPath(RegistryHive::HKLM, allUserStorePath.GetChars(), &offlineAllUserStorePath)
GetOfflineRegistryPath(RegistryHive::HKLM, allUserStorePathBuffer.GetChars(), &offlineAllUserStorePathBuffer)
GetOfflineRegistryPath(RegistryHive::HKLM, c_messagingKeyPath, &offlineAppxRegKeyPath)
GetOfflineRegistryPath(RegistryHive::HKLM, Common::Deployment::AppXRegKeyPath.chars, &offlineAppxRegKeyPath)
GetOfflineRegistryPath(RegistryHive::HKLM, pluginRegistryKeyPath, &regPath)
GetOfflineRegistryPath(RegistryHive::HKLM, softwareHive, &offlineSoftwareHive)
GetPackageDirectoryExistsUsingGatheredData(fullName, &exists)
GetPackageDirectoryExistsUsingGatheredData(packageFullName, &exists)
GetPackageInstallState(packageManager, fullName, nullptr , &packageInstallState)
GetPackageInstallState(packageManager, fullNameAsString, userSid, &packageInstallState)
GetPackageIsStubUsingGatheredData(packageFullName, &packageIsStub)
GetPackageIsStubUsingGatheredData(provisionedInstalledPackageFullName, &provisionedInstalledPackageIsStub)
GetPersistedRegistryLocationW
GetPluginHasExecutedOffline(executedOffline)
GetPluginHasExecutedOffline: %d for context %ws
GetPluginHasExecutedOfflineValueName(valueName)
GetPluginRelativeFullPath(L"", &manifestPathBuffer)
GetProcAddress
GetProcessHeap
GetServiceStatus(serviceName, &status)
GetStagedPackagePathByFullName
GetStubPreferenceFromKey(stubPreferenceKey, familyName.GetChars(), &packageIsStub)
GetStubPreferenceFromKey(stubPreferenceKey, packageFamilyName, &uplevelProvisionedPackageIsStub)
GetStubPreferenceFromKey(stubPreferenceRootKey, packageFamilyName, stubPreferred)
GetStubPreferenceFromKey(uplevelStubPreferenceKey, packageFamilyName.GetChars(), &uplevelPreference)
GetStubPreferenceKey(KEY_READ | KEY_WRITE, uplevelStubPreferenceKey)
GetStubPreferenceKey(KEY_READ, stubPreferenceKey)
GetSystem32FullPath(applyTrustLabelApplication, &applyTrustLabelAppFullPath)
GetSystemSisManifestPathFromPackageFullName( bundleFullName, &manifestPath)
GetSystemSisManifestPathFromPackageFullName( packageFullName, &manifestPath)
GetSystemSisManifestPathFromPackageFullName(packageToWrite, &packageManifestPath)
GetSystemTimeAsFileTime
GetSystemWindowsDirectory(systemWindowsDirectory, ARRAYSIZE(systemWindowsDirectory)) == 0
GetSystemWindowsDirectoryW
GetTickCount
GetTickCount64
Getting single instance store path failed with %x, switching to use legacy location
Getting stub preference key with offlineExecution: %d
Getting stub preference key. stubPreferenceKeyPath:  %ws
GetVersionInfo(&osVersion)
H UATAUAVAWH
h UAVAWH
H!\$0H!\$(H!\$ 3
H!\$83
H!\$8H!\$0H!\$(H!\$ 3
H!\$8H!\$0H!\$(H!\$ L
H!]@H
H!|$x
H!k(H!k0H!k8H!k@3
H!t$x
H!u0H
H_^[]
H9]@L
H9D$xv
HA_A^_^][
hA_A^A]A\_^][
HA1o7w
Has same main package as %ws
HasCellularModem
HasModem
HcD$ H
HeapAlloc
HeapFree
HKCU\
HKLM\
hrActivateInstance
hrAllUserStoreKeySetKeySecurity
hrAppendFullName
hrApplyTrustLabelToPackages
hrApplyTrustLabelToPluginStagedPackages
hrApplyTrustLabelToPluginStagedUserAcquiredPackages
hrApplyTrustLabelToPreInstalledPackages
hrAppxPreRegisterPackage
hrCleanupOrphanPackages
hrCleanupSystemAppsMigratedToFOD
hrCopyBackupManifestForEndOfLifePackagesIfNecessary
hrCopyMetadataIfRequired = CopyMetadataIfRequired()
hrCreateKey
hrCreatePerMachineKeys
hrCreateProvisionStreamingReaderFromFile
hrDeleteOSRollbackPackagesRegistry
hrDeprovisionedKeySetKeySecurity
hrEndOfLifeKeySetKeySecurity
hrEnsureAutogenDeleted
hrEnsureFamiliesRegistryKeyPermissions
hrEnsureRegistryKeyPermissions
hrEnumBundles
hrEnumerate
hrEnumerateUsersAndPopulateUserSids
hrEnumFamilies
hrEnumFrameworks
hrEnumMainPackages
hrEnumOptionalPackages
hrEnumPackages
hrEnumResourcePackages
hrEnumSubfolders
hrEnumSubkeys
HResult
hresult
HResult
hresult
HRESULT_FROM_WIN32(enumResult)
HRESULT_FROM_WIN32(GetLastError())
hrExcludeAllInfusedApps
hrExcludeFile
hrExcludeKey
hrExcludeLeftoverInvalidRegistries
hrExcludeLeftoverManifestFiles
hrGatherData
hrGetPackageIDFromPackageMoniker
hrGetProvisionXmlPath
hrGetTarget
hrGetValue
hrGetWorkingDir
hrIncludePath
hrIncludeRegistryKey
hrIncludeRegistryValue
hrInitializeUpgradeData
hrIterateBundles
hrIterateOptionalPackages
hrIteratePackages
hrIterateResourcePackages
hrMarkUplevelProvisionedPausedPackagesAsStaged = MarkUplevelProvisionedPausedPackagesAsStaged()
hrMergeRegistryKey
hrMergeRegistryValue
hrMovePathToBackupFolder
hrOpenKey
hrOpenPackagesToRemove
hrPluginAppxKeyOpen
hrPluginAppxKeyOpenAppxAllUserStore
hrPluginAppxKeyOpenSubKeyApplications
hrPluginOpenPackagesToCheckForStagingCompletion
hrPluginOpenPackagesToReRegister
hrPopulateAppxProvisionXmlLists
hrPreRegister
hrPreRegisterAllPackages
hrProcessAllInstalledPackages
hrProcessAllUserStorePackages
hrProcessBundleManifestPackages
hrProcessInboxOrDevModePackageForUser
hrProcessPackage
hrProcessPackageForUser
hrProcessRecoveryData
hrProcessSingletonPackages
hrReadAppXMigrationStores
hrReIndexPackagesForFeatureLightUp = ReIndexPackagesForFeatureLightUp()
hrRemoveUplevelProvisionedUnneededPackages = RemoveUplevelProvisionedUnneededPackages()
hrRepairPackageRepository
hrRepairPackageRootFolderPath
hrRepairStateRepository
hrSavePackageListFromFileToRegistry
hrSetupPackagesForReRegistration
hrSetValue
hrStagedKeySetKeySecurity
hrUserPackagesToReRegisterKey
hrWrite
hrWriteAllUserStoreKeys
hrWriteFrameworkMap
hrWriteOutPerMachineMigrationXml
hrWriteOutPerUserMigrationXml
hrWritePackagesToReRegisterKeys
hrWriteResourceMap
hrWriteUninstalledKeys
http://schemas.microsoft.com/appx/2013/appxprovisionpackage
I0G1-0+
If the OS doesn't support packageManager2 interface then no resource and bundles can be installed--no bundles and resources to process. 
Ignoring error: Package %ws failed to ensure deleted Autogen: 0x%x
Ignoring error: Package %ws failed to preregister: 0x%x
Ignoring package %ws with unknown property type %x
InboxApplications
inboxPackagesKey.Open(HKEY_LOCAL_MACHINE, inboxPackagesBuffer.GetChars(), KEY_READ)
infusedPathBuilder.AppendString(Common::Deployment::infusedAppsDir)
infusedPathBuilder.AppendString(systemWindowsDirectory)
InitializeAcl
InitializeCmdLine(applicationPath, offlineSoftwareHive, cmdLineBuilder)
InitializeCriticalSection
InitializeCriticalSectionEx
InitializePackageRepositoryRoot()
InitializePluginRegistryKeys(offlineExecution, &appxKeyFound)
InitializeProcThreadAttributeList
InitializeSecurityDescriptor
InitializeSRWLock
InitializeSystemSisFullPath()
InitOnceBeginInitialize
InitOnceComplete
Inserting %ws since it was brought by a bundle %ws
InsertToPreferredMapUsingGatheredData( packageFullName, &packageFamilyName, packageIsStub, &this->combinedProvisionedMap, false, false, &comparison)
InsertToPreferredMapUsingGatheredData( packageFullName, &packageFamilyName, packageIsStub, &this->combinedProvisionedMap, false, true, &comparison)
InsertToPreferredMapUsingGatheredData( packageFullName, &packageFamilyName, packageIsStub, &this->combinedProvisionedMap, false, true, &packagePreferenceComparison)
InsertToPreferredMapUsingGatheredData( packageFullName, &versionlessName, packageIsStub, &this->frameworkMap, false)
InsertToPreferredMapUsingGatheredData(fullName, &familyNameBuffer, packageIsStub, &this->combinedProvisionedMap, true, false, &comparison)
InsertToPreferredMapUsingGatheredData(fullName, &versionlessName, packageIsStub, &this->frameworkMap, false)
InsertToPreferredMapUsingGatheredData(fullName, &versionlessName, packageIsStub, &this->resourceMap, false)
InsertToPreferredMapUsingGatheredData(packageFullName, &versionlessName, packageIsStub, &this->resourceMap, true)
InSingleInstanceStore
installedLocation.As(&installedLocationStorageItem)
installedLocationStorageItem->get_Path(path.GetAddressOf())
installedLocationStorageItem->get_Path(path.ReleaseAndGetAddressOf())
InstalledPackages
installedPackagesKey.CreateSubKey(s_Bundle, KEY_READ | KEY_WRITE, &bundlesKey)
installedPackagesKey.CreateSubKey(s_Framework, KEY_READ | KEY_WRITE, &frameworkPackagesKey)
installedPackagesKey.CreateSubKey(s_Main, KEY_READ | KEY_WRITE, &mainPackagesKey)
installedPackagesKey.CreateSubKey(s_Optional, KEY_READ | KEY_WRITE, &optionalPackagesKey)
installedPackagesKey.CreateSubKey(s_Resource, KEY_READ | KEY_WRITE, &resourcePackagesKey)
installedPackagesKey.OpenSubKey(s_Bundle, KEY_READ, &bundlesKey)
installedPackagesKey.OpenSubKey(s_Framework, KEY_READ, &frameworkPackagesKey)
installedPackagesKey.OpenSubKey(s_Main, KEY_READ, &mainPackagesKey)
installedPackagesKey.OpenSubKey(s_Optional, KEY_READ, &optionalPackagesKey)
installedPackagesKey.OpenSubKey(s_Resource, KEY_READ, &resourcePackagesKey)
InstallState
installStateKey.OpenSubKeyIfExists(provisionedPackageFullName, KEY_READ, &packageKey)
installStateRootKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
installStateRootKey.OpenSubKeyIfExists(packageFullName, KEY_READ, &packageKey)
InternalName
INVALID_HANDLE_VALUE == deviceInfoList.get()
IPHLPAPI.DLL
Is a framework package
Is a LOB app
Is a main or bundle package
Is a resource package
Is a top level package
Is being DROPPED because it is a de-provisioned package
Is higher version than %ws
Is less preferred than %ws
Is lower version than %ws
Is more preferred than %ws
Is same version as %ws
IsDebuggerPresent
IsDevModeApp
IsFixStateRepositoryAlreadyExecuted(alreadyExecuted)
IsFramework
IsInSingleInstanceStore(package, &inSingleInstanceStore)
IsLOBApp
IsPackageInEndOfLifeKey(endOfLifeMissingManifestFixablePackageFullNames[i], &isInEndOfLifeKey)
IsPackageRegistrationPreservedAcrossUpgrade()
IsPluginDeprovisionedPackage(&allUserStoreKey, packageFamilyName, &isDeprovisioned)
IsStub
IUIPolicyChecked
K SVWH
KERNEL32.dll
kernelbase.dll
key.Open(HKEY_LOCAL_MACHINE, effectiveStubPreferenceKeyPath, access)
key.OpenSubKeyIfExists(packageFamilyName, KEY_READ, &packageFamilyKey)
key.ValueExists(valueName.GetChars(), &hasExecutedOffline)
key->OpenSubKey(familyName, KEY_READ, &packageFamilyKey)
key->OpenSubKey(userSid, KEY_READ, &userSidKey)
keysToDelete.Add(uplevelPackageToDelete)
KfD9u0uvH
L!d$8L!d$0L!d$(L!d$ L
L!t$8H
L$ A+
L$ SUVWH
L$ SWH
L$ UVWATAUAVAWH
L$ VWAVH
L$(E3
L$@I+
l$\fD
L$`9L$Pu
L$`D;
L$`E3
L$`H3
L$0E3
L$0H3
L$8E3
L$8H3
L$hH3
L$PD9
L$XH+
L+x`r
L9{@u
L9{0t#H
L9|$8u
L9|$H
L9|$Hu
L9d$`u
L9ePuw
L9l$Hu
LastReturnValue
LcA<E3
Lct$$H
LeaveCriticalSection
Legal_Policy_Statement
LegalCopyright
lineNumber
Loading ext-ms-win-security-capauthz-l1-1-1.dll
LoadLibraryExW
LoadLibraryW
LoadUpgradeDataFromPluginKey()
Local\SM0:%d:%d:%hs
LocalFree
LocationModifyStringForInfusedApps
LocationModifyStringForWindowsApps
LOG_IF_FAILED(%S) failed with 0x%x
LogHr
lpt1.
lpt2.
lpt3.
lpt4.
lpt5.
lpt6.
lpt7.
lpt8.
lpt9.
m:AppxProvisionList
m:AppxProvisionList/m:EndOfLife/m:Package/@FamilyName
m:AppxProvisionList/m:Provisioned/m:Package/@FullName
m:EndOfLife
m:EndOfLife/m:Package
m:Package
m:Provisioned
m:Provisioned/m:Package
M0K0I
MACHINE
Main package
mainPackageKey.GetUInt32ValueIfExists(AppxAllUserStore::regValueIsLOBApp, &isLOBApp, &valueExists)
mainPackageKey.SetStringValue( AppxAllUserStore::regValuePath, packageManifestPath.GetStringRef())
mainPackageKey.SetUInt32Value(AppxAllUserStore::regValueIsLOBApp, 1)
mainPackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
MaintenanceLastPerformed
malloc
ManifestCacheOptions
manifestPackageID->GetPackageFullName(&packageFullName)
manifestPathBuilder.AppendChar(L'\\')
manifestPathBuilder.AppendString(&Common::Deployment::BundleManifestFileName)
manifestPathBuilder.AppendString(&Common::Deployment::ExtendedPathPrefix)
manifestPathBuilder.AppendString(&Common::Deployment::ManifestFileName)
manifestPathBuilder.AppendString(packageFullName)
manifestPathBuilder.AppendString(this->singleInstanceStore.GetChars())
Matches stub preference while %ws doesn't
memcmp
memcpy
memcpy_s
memmove
memmove_s
memset
message
messagingKey.GetUInt32Value(c_hasCellularModemValue, &hasModem)
messagingKey.OpenIfExists(HKEY_LOCAL_MACHINE, c_messagingKeyPath, KEY_READ)
messagingKey.OpenIfExists(HKEY_LOCAL_MACHINE, c_messagingKeyPath, KEY_WRITE)
messagingKey.SetUInt32Value(c_hasCellularModemValue, foundCellularModem)
metadataPathBuilder.AppendString(fullName)
metadataPathBuilder.AppendString(sisPath)
metadataPathBuilder.AppendString(systemMetadataFolder)
MHH!]@H
Microsoft
Microsoft Corporation
Microsoft Corporation1
Microsoft Corporation1&0$
Microsoft Corporation1)0'
Microsoft Corporation1.0,
Microsoft Corporation1200
Microsoft Time-Stamp PCA 2010
Microsoft Time-Stamp PCA 20100
Microsoft Time-Stamp Service
Microsoft Time-Stamp Service0
Microsoft Windows0
Microsoft.CommsPhone_8wekyb3d8bbwe
Microsoft.Messaging_8wekyb3d8bbwe
Microsoft.OneConnect_8wekyb3d8bbwe
Microsoft.Windows.AppxMigrationPlugin
Microsoft.Windows.SecondaryTileExperience_10.0.0.0_neutral__cw5n1h2txyewy
Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore\
MigrateDownlevelStubPreference()
MigXml
MigXmlWriter::Create(false , nullptr, &xmlWriter)
MigXmlWriter::Create(true , &this->pluginDownlevelGatherKey, &xmlWriter)
MigXmlWriter::GatherDataForEnvironmentStrings(this->pluginDownlevelGatherKey)
module
Msg:[%ws] 
msvcrt.dll
N0L0J
nameBuffer.SetCapacity(nameBufferLength)
nCipher NTS ESN:4DE9-0C5E-3E091+0)
NetCfgInstanceId
neutral
newBundleAndMainPackage->bundle.SetValueFromString(packageFullName)
newBundleAndMainPackage->mainPackage.SetValueFromString(packageFullName)
NewParser
No %s found - cannot apply trust labels
No Applications Plugin key found--downlevel had no OEM apps or newer all-user apps to copy over
No need to write Applications Key because uplevel provisioned package %ws is the most preferred version
No PackagesToCheckForStagingCompletion Plugin key found
No PackagesToRemove Plugin key found
No PackagesToReRegister Plugin key found
No Plugin Applications key found. Downlevel had no OEM apps or newer all-user apps to copy over
No Plugin key found--Discover/Gather failed 0x%x. Preregistering uplevel image's key
No Plugin key found--downlevel had no apps or Discover/Gather failed.
No Plugin Staged key found. As far as we know, user had no packages to ApplyTrustLabel
No Plugin Staged key found--Discover/Gather failed 0x%x. Preregistering uplevel image's key
No Plugin StagedUserAcquired key found. As far as we know, User had no packages
No Plugin StagedUserAcquired key found. As far as we know, user had no packages to ApplyTrustLabel
No work to do for DEFAULT user. Skipping.
NoReRegisterOnUpgrade
not found
Not generating migration XML on downlevel system since new packages can still be provisioned on uplevel image.  Migration XML will be generated during Discover on uplevel system.
Not Removing up-level provisioned deprovisioned Package because a user has it still installed: %ws
NtClose
NtCreateSection
ntdll.dll
NtMapViewOfSection
NtQueryWnfStateData
NtUnmapViewOfSection
NtUpdateWnfStateData
O0M0K
offlineFilePath->SetValueFromString(reinterpret_cast<PCWSTR>(bstrOfflineFilePath.Value()))
offlinePathBuilder.AppendChar(L'\"')
offlinePathBuilder.InsertChars(0, L" \"", 2)
offlineRegistryPath->SetValueFromString((reinterpret_cast<PCWSTR>(bstrOfflineRegistryPath.Value())) + hivePrefixLength)
oK0D$"<
OLEAUT32.dll
onecore\admin\appmodel\appxupgrademigrationplugin\src\appxupgrademigrationpluginclass.cpp
onecore\admin\appmodel\appxupgrademigrationplugin\src\migxmlwriter.cpp
onecore\admin\appmodel\appxupgrademigrationplugin\src\recoveryreader.cpp
onecore\admin\appmodel\common\alluserstorepaths.cpp
onecore\admin\appmodel\common\configuration.cpp
onecore\admin\appmodel\common\directorypaths.cpp
onecore\admin\appmodel\common\downlevelhelper.cpp
onecore\admin\appmodel\Common\ManifestCache.hpp
onecore\admin\appmodel\common\mountedfolder.cpp
onecore\admin\appmodel\common\packagefullnameutilities.cpp
onecore\admin\appmodel\common\PackageID.inl
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionpackage.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionpackageenumerator.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionreader.cpp
onecore\base\appmodel\appxprovisionpackage\src\appxprovisionwriter.cpp
onecore\base\appmodel\appxprovisionpackage\src\commonhelpers.cpp
onecore\base\appmodel\common\autocotaskmemstring.cpp
onecore\base\appmodel\common\bytebuffer.cpp
onecore\base\appmodel\common\pathhelpers.cpp
onecore\base\appmodel\common\registrykey.cpp
onecore\base\appmodel\common\stateseparation.cpp
onecore\base\appmodel\common\stringbuilder.cpp
onecore\base\appmodel\common\stringset.cpp
onecore\base\appmodel\common\widestring.cpp
onecore\internal\base\inc\appmodel\package\ProcessorArchitecture.hpp
onecore\internal\sdk\inc\wil\opensource\wil\resource.h
onecore\internal\sdk\inc\wil\Staging.h
opcFactory->CreateStreamOnFile( manifestPath.GetChars(), OPC_STREAM_IO_READ, NULL, FILE_ATTRIBUTE_NORMAL, &manifestStream)
OpenFileInMachineWorkingDirectory(PluginExecutedFixStateRepositoryFilename, false , &file)
OpenFileInMachineWorkingDirectory(PluginExecutedFixStateRepositoryFilename, true , &fileHandle)
Opening reg key HKEY_LOCAL_MACHINE\%s to enumerate
Opening reg key HKEY_USERS\%s to enumerate
Opening the effective stub preference key path: %ws
OpenPerUserClassesSubKey(userSid, appxMiniRepositoryFamiliesSubkey, offlineMode, &familiesKey)
OpenPerUserClassesSubKey(userSid, appxMiniRepositoryPackagesSubkey, offlineMode, &packagesKey)
OpenSCManagerW
OpenSemaphoreW
OpenServiceW
Optional
optionalPackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
OriginalFilename
originatingContextId
originatingContextMessage
originatingContextName
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running ApplySuccess.
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running Discover.
OS Upgrade running from an OS older than Win 8, so no work needed for Appx sub-system. Skip running Gather.
OSDATA\Software\
OSRollbackPackages
OutputDebugStringW
OverrideConfig
p AWH
p WATAUAVAWH
p WAVAWH
PA^_]
PA^_^
PA^A\_^]
PA_A^_
pA_A^_^]
PA_A^A\_^[]
pA_A^A\_^[]
pA_A^A]A\]
pA_A^A]A\_[]
PA_A^A]A\_^]
pA_A^A]A\_^]
Package
Package %ws destage completed with hr = 0x%x.
Package %ws does not exist in SIS. Don't carry it forward
Package %ws has an in-place update pending, can't move it away.
Package %ws is being end of lifed so its package root will be excluded
Package %ws is End Of Life and missing a backup manifest, but we could not fix this.
Package %ws is End Of Life and was missing a backup manifest, but we were able to replace the backup manifest.
Package %ws is not installed by any users. No need to preserve it
Package %ws is not needed, not writing to Staged Key
Package %ws will be preserved as uplevel OS image does not have any version of it and it has been installed by at least 1 user
Package family %ws does not exist in SIS. Don't carry it forward
Package family %ws is end-of-lifed
Package family not found yet, adding new entry
Package is being end of lifed so its package root will be excluded
Package is in paused state. This package will be treated the same as if it were staged
Package is LOB and will be carried forward.
Package is not uplevel provisioned or LOB and will be carried forward. Since it's downlevel provisioned, but not uplevel provisioned implies this is an OEM package
Package is uplevel provisioned.
Package root of %ws will be excluded as it is less preferred
package->get__PackageID(&packageId)
package->get_IsFramework(&isFramework)
package->get_NeedsSingletonRegistration(&needsSingletonRegistration)
package->get_PackageFullName(&packageFullName)
package->GetPackageFamilyName(&familyName)
package->GetPackageFullName(&fullName)
package->GetPackageId(&manifestPackageID)
package->GetPackageType(&packageType)
package->GetProperties(&packageProperty)
package8->get_IsStub(&isStub)
packageFamilyKey.CopyTree(nullptr, allUserApplicationsKey)
packageFamilyKey.GetUInt32ValueIfExists(s_PreferStub, &value, &valueExists)
packageFamilyKey.SetUInt32Value(s_PreferStub, downlevelPreference)
packagefamilyNameAsInternalString.Initialize( packageFamilyName, static_cast<ULONG>(wcslen(packageFamilyName)))
PackageFamilyNameFromFullName
packageFullName
packageFullNameKey.GetStringValue(s_Path, &packagePath)
packageFullNames->get_Size(&size)
packageFullNames->GetAt(index, packageFullName.GetAddressOf())
packageFullNamesToReRegister->Append(packageFullName)
packageId->get_FullName(packageFullName.GetAddressOf())
packageId->get_FullName(packageFullNameAsString.GetAddressOf())
packageInfo->get_Id(&packageId)
packageInfo->get_InstalledLocation(&installedLocation)
packageInfo->get_IsFramework(&isFrameworkValue)
packageInfoCollection->First(packageInfoIterator.GetAddressOf())
packageInfoIterator->get_Current(packageInfo.GetAddressOf())
packageInfoIterator->get_HasCurrent(&hasCurrent)
packageInfoIterator->MoveNext(&hasCurrent)
PackageInstallState
packageKey.GetStringValue(s_PackageRoot, &packageRoot)
packageKey.GetStringValue(s_Path, &packageFullPath)
packageKey.GetStringValueIfExists(AppxAllUserStore::regAppDataVolumeKeyString, &value, &valueExists)
packageKey.GetStringValueIfExists(AppxAllUserStore::regAppDataVolumeNameString, &value, &valueExists)
packageKey.GetStringValueIfExists(AppxAllUserStore::regPackageVolumeKeyString, &value, &valueExists)
packageKey.GetStringValueIfExists(AppxAllUserStore::regPackageVolumeNameString, &value, &valueExists)
packageKey.GetStringValueIfExists(s_BundleFullName, bundleFullName, &hasBundle)
packageKey.GetUInt32Value(s_InSingleInstanceStore, &inSingleInstanceStoreValue)
packageKey.GetUInt32Value(s_InstallState, &packageInstallState)
packageKey.GetUInt32Value(s_IsFramework, &isFrameworkValue)
packageKey.GetUInt32Value(s_PackageType, &packageType)
packageKey.GetUInt32ValueIfExists(s_IsStub, &isStubValue, &valueExists)
packageKey.SetKeySecurity(DACL_SECURITY_INFORMATION, newSecurityDescriptor)
packageKey.SetStringValue(pathValueName, expandedPath)
packageKey.SetStringValue(s_BundleFullName, bundleName.GetChars())
packageKey.SetStringValue(s_PackageRoot, manifestPath.GetChars())
packageKey.SetStringValue(s_Path, packageFullPath)
packageKey.SetUInt32Value(s_InSingleInstanceStore, inSingleInstanceStore ? 1 : 0)
packageKey.SetUInt32Value(s_InstallState, packageInstallState)
packageKey.SetUInt32Value(s_IsFramework, isFrameworkValue ? 1 : 0)
packageKey.SetUInt32Value(s_IsStub, isStub)
packageKey.SetUInt32Value(s_PackageType, packageType)
PackageList
packageManager->FindPackagesByUserSecurityId(userSidAsInternalString, collection)
packageManager->FindUsers(packageFullName, userInfoCollection.GetAddressOf())
packageManager->SetPackageStatusBlocking(packageFullName)
packageManager->SetupOutdatedPackagesForReRegistration(userSidString.Get(), packagesToReRegister.Get())
packageManager2.As(&packageManager)
packageManager2->FindPackagesByUserSecurityIdPackageFamilyNameWithPackageTypes( userSidAsInternalString, packagefamilyNameAsInternalString, Windows::Management::Deployment::PackageTypes_Bundle, collection)
packageManifestPath->InitializeFromString(manifestPath.GetChars())
packagePathBuilder.SetLength(packagePathBuilder.GetLength() - (ARRAYSIZE(appxBundleManifestRelativePath) - 1))
packagePathBuilder.SetLength(packagePathBuilder.GetLength() - (ARRAYSIZE(appxManifestRelativePath) - 1))
PackageRepositoryRoot
PackageRoot
packageRoot.SetLength(packageRootLength)
packageRoot.SetValueFromString(WindowsGetStringRawBuffer(path, NULL))
packageRootBuilder.AppendChar(L'\\')
packageRootBuilder.AppendString(Common::Deployment::ManifestFileName.chars)
packageRootBuilder.AppendString(package)
PackageRootFolder
Packages
packages->GetCurrent(&package)
packagesKey.Open(HKEY_LOCAL_MACHINE, effectivePackageRepositoryPackagesKeyPath, KEY_READ | KEY_WOW64_64KEY)
packagesKey.OpenSubKey(packageFullName.GetChars(), KEY_READ | KEY_WRITE, &packageKey)
packagesPathBuilder.AppendString(Common::Deployment::packagesDir)
packagesPathBuilder.AppendString(infusedAppsFolder.GetChars())
packageStatics->Find(&packages)
packageStatics->FindPackageFullNamesByUserSidAndPackageTypeAndTargetDeviceFamily( userSidAsHString.Get(), Windows::Internal::StateRepository::PackageType_Main, DEVICEFAMILYINFOENUM_WINDOWS_8X, &packageFullNames)
packageStatics->UpdateIsSingletonRegistered(packageId, false)
PackageStatus
PackagesToCheckForStagingCompletion
PackagesToCheckForStagingCompletion: %ws
packagesToCheckForStagingCompletion->Append(Microsoft::WRL::Wrappers::HStringReference(subKeyName).Get())
PackagesToRemove
PackagesToReRegister
packagesToReRegister->get_Size(&vectorCount)
packageSubKey->SetValueFromString(packageFullName)
packageSubKeyBuilder.AppendChar(L'\\')
packageSubKeyBuilder.AppendString(packageFamilyName)
packageSubKeyBuilder.AppendString(packageFullName)
packageSubKeyBuilder.AppendString(packageToWrite)
packageSubKeyBuilder.AppendString(userSid)
PackageType
PackageVolumeKey
PackageVolumeName
PartA_PrivTags
pathBstr.CopyFromString(path)
pathBuilder.AppendChar('\\')
pathBuilder.AppendChar(L'\\')
pathBuilder.AppendString(&RecoveryReader::recoveryExtension)
pathBuilder.AppendString(appRepositoryExpandedPath)
pathBuilder.AppendString(autogenDirectorySubPath)
pathBuilder.AppendString(familyName)
pathBuilder.AppendString(fullName)
pathBuilder.AppendString(L"\\")
pathBuilder.AppendString(packageFullName)
pathBuilder.AppendString(path)
pathBuilder.AppendString(path->GetString())
pathBuilder.AppendString(systemMetadataDirectoryForPackage)
pathBuilder.AppendString(systemMetadataFolder)
pathBuilder.AppendString(upgradePath.GetString())
pathBuilder.AppendString(userSid)
PerformApplySuccessPerMachineTasks(false )
PerformApplySuccessPerMachineTasks(true )
PerformApplySuccessPerUserTasks(userSidString, false )
PerformApplySuccessPerUserTasks(userSidString, true )
Performing AppxUpgradeMigration Plugin offline tasks
perUserACLPathBufferBuilder.AppendString(effectivePerUserRegistryPath)
perUserACLPathBufferBuilder.AppendString(L"USERS\\")
perUserInstalledKey.CreateSubKey(package, KEY_READ | KEY_WRITE, &perUserInstalledSubKey)
perUserInstalledSubKey.SetUInt32Value(lastReturnValueRegistryValueName, S_OK)
perUserRegistryPathBufferBuilder.AppendString(appContainerStorageRegistrySubKey)
perUserRegistryPathBufferBuilder.AppendString(registryClassesPrefix)
perUserRegistryPathBufferBuilder.AppendString(userSid)
perUserReRegistrationKey.CreateSubKey(mainPackageFullName, KEY_READ | KEY_WRITE, &perUserReRegistrationSubKey)
pL9ePtRD8
Plugin Appx key not found which should be present on up-level -- abandoning FixStateRepositoryIntegrity.
Plugin registry key after Gather:
Plugin sub key found -- we're on uplevel system during apply phase for system context. Generate MigXml for Discover.
Plugin sub key found -- we're on uplevel system during apply phase for user context. Skip running Discover.
pluginAppxKey.OpenSubKey( s_StagedUserAcquired, KEY_READ, &this->pluginStagedUserAcquiredKey)
PluginExecutedInOfflineMode
PluginHasExecutedOffline
preferredMap->Insert(packageFamilyName->GetChars(), newBundleAndMainPackage.Value())
preferredMap->Insert(packageLineageName->GetChars(), currentPackage)
preferredMap->Remove(packageLineageName->GetChars())
PreferStub
PreRegisterAllInboxPackages failed 0x%x
PreRegisterAllInboxPackages()
PreRegistering Staged package %ws
PreRegisterPackagesInRegistryKey(&stagedKey, PreRegisterOptions::ReIndex)
PreRegisterPackagesInRegistryKey(&this->pluginStagedKey)
PreRegisterPackagesInRegistryKey(&this->pluginStagedUserAcquiredKey)
PreRegisterUplevelImagePackages()
PreserveMetadataForPackage(fullName)
ProcessAllBundleResourceAndOptionalPackagesUsingGatheredData()
ProcessAllMainAndFrameworkPackagesUsingGatheredData()
ProcessBundleForUserUsingGatheredData( packageKey, packageFamilyName, userSid, &bundleFullName)
processElementMethod(packageInfo.Get(), packageFullNameAsString.GetRawBuffer(nullptr))
ProcessFrameworkUsingGatheredData(packageFullName)
Processing %s
Processing all installed packages
Processing all Packages for user %ws
Processing all user store packages
Processing appx provision XML
Processing DevMode or Inbox Package %ws for user %ws
Processing downlevel all-user framework package %ws 
Processing downlevel all-user provisioned package %ws 
Processing Package %ws
Processing package %ws for ApplyTrustLabel
Processing Package %ws for user %ws
Processing Staged package %ws for preregister
Processing Staged package %ws to copy metadata
ProcessMainOrBundlePackageUsingGatheredData(packageFullName)
ProcessPackagesForUserUsingGatheredData(this->userSids.At(i)->GetChars())
ProcessPackagesToApplyUsingGatheredData
ProcessPackagesToApplyUsingGatheredData completed successfully
ProcessPackagesToApplyUsingGatheredData()
ProcessResourcePackageUsingGatheredData(packageFullName)
ProcessSingletonPackagesHelperFailed
ProductName
ProductVersion
Provisioned
provisionedAttemptedPackageFamilies->InsertIgnoreDuplicates(packageFamilyName.GetChars())
provisionedInstalledPackageFullNames->Insert(familyNameBuffer.GetChars(), fullNameBuffer.GetChars())
provisionedPackages->GetCurrent(&package)
provisionedUninstalledPackageFullNames->InsertIgnoreDuplicates(bundleFullName)
provisionedUninstalledPackageFullNames->InsertIgnoreDuplicates(mainPackageFullName)
ProvisionSourceIsBundle
QueryApplicationCapabilitiesEx
QueryPerformanceCounter
QueryServiceStatus
R!s4Z
r~akow
RaiseException
rc != ERROR_INSUFFICIENT_BUFFER
RCV2E
ReadAppXMigrationStoresUsingGatheredData()
reader->GetListEnumerator( ProvisionPackageList_EndOfLife, &eolPackages)
reader->GetListEnumerator( ProvisionPackageList_Provisioned, &provisionedPackages)
ReadFile
Reading Appx Migration Stores failed with 0x%x. Ignoring this error so we attempt to write migration XML.
Reading provisioning XML from location: %ws
realloc
RecursiveCopyDirectoryExceptAutogen(metadataFolderInSharedLimitedTime.GetChars(), metadataFolder.GetChars())
RecursiveCopyDirectoryExceptAutogen(srcPath.GetChars(), destPath.GetChars())
Redmond1
RegCloseKey
RegCopyTreeW
RegCreateKeyExW
RegDeleteTreeW
RegDeleteValueW
RegEnumKeyExW
RegEnumValueW
RegGetKeySecurity
RegGetValueW
Registry key value [%s] does not exist. The package may not be fully registered yet.
Registry Package entry has invalid Path
registry.GetStringValue(s_PackageRepositoryRoot, MAX_EXTENDED_PATH, &this->packageRepository)
registry.GetStringValue(s_PackageRoot, MAX_EXTENDED_PATH, &this->singleInstanceStore)
registry.Open(HKEY_LOCAL_MACHINE, Common::Deployment::AppXRegKeyPath.chars, KEY_READ)
registry.Open(HKEY_LOCAL_MACHINE, offlineAppxRegKeyPath.GetChars(), KEY_READ)
registryKey->CreateSubKey(packageSubKey.GetChars(), KEY_READ | KEY_WRITE, subKey)
registryKey->IsNull()
registryKey->Open(HKEY_USERS, effectiveUserPath, KEY_READ | KEY_WOW64_64KEY)
registryKey->OpenSubKey(fullName, KEY_READ, &packageFullNameKey)
registryKey->OpenSubKey(subKeyName, KEY_READ, &subKey)
registryPathBuilder.AppendString(hivePrefix)
registryPathBuilder.AppendString(onlineRegistryPath)
regkey.DeleteValueIfExists(L"MaintenanceLastPerformed")
regkey.Open(HKEY_LOCAL_MACHINE, stateRepositoryRegistryStatusSubkey, KEY_READ | KEY_WRITE)
regkey.SetUInt32Value(stateRepositoryRegistryNameAutoCheckIntegrity, autoCheckIntegrityOptions_FixIntegrity)
RegOpenKeyExW
RegQueryInfoKeyW
RegQueryValueExW
RegSetKeySecurity
RegSetValueExW
ReleaseMutex
ReleaseSemaphore
ReleaseSRWLockExclusive
ReleaseSRWLockShared
Removed deprovisioned package %ws from uplevel key.
RemoveDirectoryW
Removing uplevel provisioned unneeded packages
Replacing path value [%s] with: %s
repositoryManager_4b7906ca_2e76_43c5_8532_306ad2ffbcfa->CheckIntegrity(Windows::Internal::StateRepository::Management::IntegrityOptions_Fix)
repositoryManager->CheckIntegrity(options, &integrityDisposition, &countOfErrorsCorrected)
repositoryManager->Repair(Windows::Internal::StringReference(userSid == nullptr ? L"" : userSid).Get(), ((userSid == nullptr) || (userSid[0] == L'\0')) ? Windows::Internal::StateRepository::Management::RepairOptions_NoUser : Windows::Internal::StateRepository::Management::RepairOptions_NoMachine, &found, &deleted)
ResetStateRepositoryMaintenance called
ResetStateRepositoryMaintenance done
ResetStateRepositoryMaintenance()
resource
Resource
resourcePackagesKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
result == 0
RETURN_HR_IF(%S) failed with 0x%x
RETURN_HR_IF_FALSE(%S) failed with 0x%x
RETURN_HR_IF_MSG(%S) failed with 0x%x. Message is below:
RETURN_IF_FAILED(%S) failed with 0x%x
RETURN_IF_FAILED_MSG(%S) failed with 0x%x. Message is below:
RETURN_IF_WIN32_BOOL_FALSE(%S) failed with 0x%x
RETURN_LAST_ERROR_IF(%S) failed with 0x%x
RETURN_LAST_ERROR_IF_NULL(%S) failed with 0x%x
ReturnHr
Rich"%
rMfD9?w
RoActivateInstance
RoGetActivationFactory
RoOriginateError
RoTransformError
RtlAcquireSRWLockExclusive
RtlAcquireSRWLockShared
RtlAllocateHeap
RtlCaptureContext
RtlCompareUnicodeString
RtlDeleteElementGenericTableAvl
RtlEnumerateGenericTableWithoutSplayingAvl
RtlFreeHeap
RtlGetDeviceFamilyInfoEnum
RtlGetVersion
RtlGetVersion failed with error code: 0x%x
RtlInitializeGenericTableAvl
RtlInitUnicodeString
RtlInsertElementGenericTableAvl
RtlIsGenericTableEmptyAvl
RtlIsStateSeparationEnabled
RtlLengthSid
RtlLookupElementGenericTableAvl
RtlLookupFunctionEntry
RtlNotifyFeatureUsage
RtlNtStatusToDosErrorNoTeb
RtlReAllocateHeap
RtlRegisterFeatureConfigurationChangeNotification
RtlReleaseSRWLockExclusive
RtlReleaseSRWLockShared
RtlSubscribeWnfStateChangeNotification
RtlUnregisterFeatureConfigurationChangeNotification
RtlUnsubscribeWnfNotificationWaitForCompletion
RtlVirtualUnwind
S-1-0-0
S-1-1-0
S-1-15-3-1024-3635283841-2530182609-996808640-1887759898-3848208603-3313616867-983405619-2501854204
S-1-5-18
Same package was already found
SaveUpgradeDataToPluginKey()
searchPathBuilder.AppendString(L"\\*")
searchPathBuilder.AppendString(offlineSystemSisPath.GetChars())
searchPathBuilder.AppendString(this->singleInstanceStore.GetChars())
searchString.SetValueFromString(sourceDirectory)
searchStringBuilder.AppendString(L"\\*")
searchStringBuilder.AppendString(L"\\*.xml")
searchStringBuilder.AppendString(packagePath)
searchStringBuilder.AppendString(this->packageRepository.GetString())
SelectionNamespaces
SetEntriesInAclW
SetEvent
SetFileAttributesW
SetFixStateRepositoryAlreadyExecuted()
SetLastError
SetNamedSecurityInfoW
SetPluginHasExecutedOffline succeeded for value-name: %ws.
SetPluginHasExecutedOffline()
SetSecurityDescriptorControl
SetSecurityDescriptorDacl
SetThreadpoolTimer
SetUnhandledExceptionFilter
SetupPhase
SharedLimitedTime metadata directory exists but metadata directory does not exist for %ws. Not copying files
SharedLimitedTime metadata directory exists: Preparing to copy metadata
SharedLimitedTime\
SisDirectory
sisDirectoryKey.CreateSubKey(subFolderName, KEY_READ | KEY_WRITE, &directoryKey)
sisDirectoryKey.OpenSubKeyIfExists(packageFullName, KEY_READ, &subKey)
SisPath
Skipping AppxPreRegisterAllInboxPackages
Skipping package root folder path value not in single instance store (for example, system apps): %s. Value length: %u
Skipping ProcessPackagesToApplyUsingGatheredData since it has already executed.
Sleep
Software
Software\
Software\Classes\ActivatableClasses
Software\Classes\AppX$
Software\Classes\Extensions
Software\Classes\Folder
Software\Classes\FolderTypes
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\$\ManifestLanguagesList
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Mappings
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Packages
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Families
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\Repository\Packages
Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\SystemAppData
Software\Classes\PackagedCom
SOFTWARE\Microsoft\Messaging
Software\Microsoft\Windows\CurrentVersion\AppContainer\Storage\$\ManifestLanguagesList
Software\Microsoft\Windows\CurrentVersion\AppHost\IndexedDB
Software\Microsoft\Windows\CurrentVersion\AppModel
Software\Microsoft\Windows\CurrentVersion\AppModel\StateChange
SOFTWARE\Microsoft\Windows\CurrentVersion\AppModel\StateRepositoryStatus
Software\Microsoft\Windows\CurrentVersion\AppSync
Software\Microsoft\Windows\CurrentVersion\Appx
Software\Microsoft\Windows\CurrentVersion\Appx\AppxAllUserStore
Software\Microsoft\Windows\CurrentVersion\AppX\ByteCodeQueue
Software\Microsoft\Windows\CurrentVersion\Appx\PackageVolumes
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Alarm
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\BackgroundCapability
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Badge
Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\Notifications\Tile
Software\Microsoft\Windows\CurrentVersion\DeviceCapabilities
Software\Microsoft\Windows\CurrentVersion\Explorer\AutoplayHandlers\Handlers
Software\Microsoft\Windows\CurrentVersion\PushNotifications
Software\RegisteredApplications
source.OpenSubKey(subKeyName, KEY_READ, &sourceSubKey)
sourceBackupManifestFilePathBuilder.AppendString(backupManifestFileExtension)
sourceBackupManifestFilePathBuilder.AppendString(endOfLifeMissingManifestFixablePackageFullNames[i])
sourceBackupManifestFilePathBuilder.AppendString(manifestPathBuffer.GetChars())
SRCheckIntegrity
srCheckIntegrity(options, &disposition)
Staged
stagedKey.GetKeySecurity(DACL_SECURITY_INFORMATION, stagedSD)
stagedKey.Open( HKEY_LOCAL_MACHINE, allUserStoreStagedPath.GetChars(), KEY_READ | KEY_WRITE | WRITE_DAC)
stagedKey.Open(HKEY_LOCAL_MACHINE, allUserStoreStagedPath.GetChars(), KEY_READ)
StagedUserAcquired
Starting AppxPreRegisterAllInboxPackages
Starting AppxUpgradeMigration Plugin during Apply Success
Starting AppxUpgradeMigration Plugin during Discover for %s
Starting AppxUpgradeMigration Plugin during Gather
Starting EnsureAppRootPermissions
Starting EnsureFamiliesRegistryKeyPermissions
Starting EnsureRegistryKeyPermissions
Starting EnumAndAddPackagesNotKnownToCapAuth
Starting FixStateRepositoryIntegrity.
Starting ProcessPackagesToApplyUsingGatheredData
Starting RepairPackageRepositoryKeyInHKLM
Starting RepairPackageRootFolderPathInRepositoryRegistryKey
Starting RepairStateRepository for %s.
StateChange
StateRepository
staterepository-machine.srd
stringArray->Add(packageSubKey)
stringBufferToModify->SetValueFromString(packageFullName)
StringCchCopy(packageFullNameChunk, packageFullNameChunkLength, trimmedChunk)
StringCchLengthW(expandedPath, Common::String::MaxLength, &expandedPathLength)
StringCchLengthW(expandedSisPath, Common::String::MaxLength, &sisPathLength)
StringCchPrintfW(pathname.get(), pathnameLength, L"%s\\%s%s", workingDir.get(), subdir, filename)
StringFileInfo
stringVector->Append(Microsoft::WRL::Wrappers::HStringReference(subKeyName).Get())
StubPreference
subFolderActionFunction(findFileData.cFileName, fullFilePath.GetChars())
subKey->SetStringValue(AppxAllUserStore::regValuePath, *packagePath)
SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
Successful delay-load of GetStagedPackagePathByFullName
Successfully finished processing all packages during AppxUpgradeMigration ApplySuccess
Successfully finished processing all packages during AppxUpgradeMigration Discover
Successfully finished processing all users and packages during AppxUpgradeMigration Gather
SVWATAUAVAWH
SVWAVH
system
SYSTEM\Setup\Upgrade\Appx
systemMetadataDirectoryForPackage.IsNull()
t"D8=$
t$ UWAVH
t$ UWAWH
t$ WATAUAVAWH
t$ WAVAWH
t$ WH
T$$D!t$ H
T$`fA;
t$`uFE3
T$8L+
t$HE3
t$PE3
T$PE3
t$pfD
T$PL;
t$PL9|$Hu
t$XE3
t%H9x
t?H9X
t'@8|$0u
t[f9+tV
t\H!\$HH
t_L9h
t+H9^
t3H9X
t9L9h
tAfA9(t;H
targetBackupManifestFilePathBuilder.AppendChar('\\')
targetBackupManifestFilePathBuilder.AppendString(appRepositoryExpandedPath)
targetBackupManifestFilePathBuilder.AppendString(backupManifestFileExtension)
targetBackupManifestFilePathBuilder.AppendString(endOfLifeMissingManifestFixablePackageFullNames[i])
td@8=
TerminateProcess
tffD9&t`H
Thales TSS ESN:148C-C4B9-20661%0#
this->allUserFrameworkSet.InsertIgnoreDuplicates(subKey)
this->allUserPackages.InsertIgnoreDuplicates(subKey)
this->AppxPreRegisterAllInboxPackages
this->AppxPreRegisterPackage
this->context->ExpandEnvironmentVariables(bstrPath, &bstrExpandedPath)
this->context->ExpandEnvironmentVariables(bstrSisPath, &bstrExpandedSisPath)
this->context->get_WorkingDir(&workingDir)
this->context->GetOfflineFileLocation( bstrOnlineFilePath.Value(), &bstrOfflineFilePath)
this->context->GetOfflineRegistryLocation( bstrOnlineRegistryPath.Value(), &bstrOfflineRegistryPath)
this->deploymentClientDllModule
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyEndOfLifePackageFamilyName)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyMessagingEndOfLifePackageFamilyName)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(desktopOnlyMobilePlansEndOfLifePackageFamilyName)
this->endOfLifePackageFamilyNameSet.InsertIgnoreDuplicates(familyName)
this->excludeFilesSet.InsertIgnoreDuplicates(filePath.GetChars())
this->excludeInfusedAppsFolderSet.InsertIgnoreDuplicates(packageFullPath.GetChars())
this->excludePackageFullNameSet.InsertIgnoreDuplicates(fullName)
this->excludePackageFullNameSet.InsertIgnoreDuplicates(packageFullName)
this->excludeRegistriesSet.InsertIgnoreDuplicates(fullPath.GetChars())
this->GetContext()->get_UserSidString(&userSid)
this->GetContext()->GetOfflineStatus(&offlineExecution)
this->includeMetadataSet.InsertIgnoreDuplicates(metadataPath.GetChars())
this->lobProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates( familyNameBuffer.GetChars())
this->lobProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(packageFamilyName.GetChars())
this->noReRegisterOnUpgrade
this->oemProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(packageFamilyName.GetChars())
this->pluginAllUserStoreKey.CopyTree(nullptr, allUserStoreKey)
this->pluginAllUserStoreKey.CreateSubKey( AppxAllUserStore::deprovisionedString, KEY_READ | KEY_WRITE | WRITE_DAC, &this->pluginDeprovisionedKey)
this->pluginAllUserStoreKey.CreateSubKey( s_DownlevelInstalled, KEY_READ | KEY_WRITE, &this->pluginDownlevelInstalledKey)
this->pluginAllUserStoreKey.CreateSubKey( s_EndOfLife, KEY_READ | KEY_WRITE, &this->pluginEndOfLifeKey)
this->pluginAllUserStoreKey.CreateSubKey( s_Staged, KEY_READ | KEY_WRITE, &this->pluginStagedKey)
this->pluginAllUserStoreKey.CreateSubKey( s_Upgrade, KEY_READ | KEY_WRITE, &this->pluginUpgradeKey)
this->pluginAllUserStoreKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &perUserInstalledKey)
this->pluginAllUserStoreKey.OpenSubKey(s_Staged, KEY_READ, &this->pluginStagedKey)
this->pluginApplicationsKey.CreateSubKey( packageSubKey.GetChars(), KEY_ALL_ACCESS, &mainPackageKey)
this->pluginApplicationsKey.OpenSubKey(subKey, KEY_READ, &packageFamilyKey)
this->pluginAppxKey.Create(HKEY_LOCAL_MACHINE, pluginRegistryKeyPath, KEY_ALL_ACCESS)
this->pluginAppxKey.CreateSubKey( allUserStoreRegistryKeyName, KEY_READ | KEY_WRITE, &this->pluginAllUserStoreKey)
this->pluginAppxKey.CreateSubKey( s_Applications, KEY_READ | KEY_WRITE, &this->pluginApplicationsKey)
this->pluginAppxKey.CreateSubKey( s_PackagesToCheckForStagingCompletion, KEY_READ | KEY_WRITE, &this->pluginPackagesToCheckForStagingCompletionKey)
this->pluginAppxKey.CreateSubKey( s_PackagesToRemove, KEY_READ | KEY_WRITE, &this->pluginPackagesToRemoveKey)
this->pluginAppxKey.CreateSubKey( s_PackagesToReRegister, KEY_READ | KEY_WRITE, &this->pluginPackagesToReRegisterKey)
this->pluginAppxKey.CreateSubKey( s_StagedUserAcquired, KEY_READ | KEY_WRITE, &this->pluginStagedUserAcquiredKey)
this->pluginAppxKey.CreateSubKey(s_Applications, KEY_READ | KEY_WRITE, &applicationsKey)
this->pluginAppxKey.CreateSubKey(s_DownlevelGather, KEY_ALL_ACCESS, &this->pluginDownlevelGatherKey)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageRepositoryRoot, &this->packageRepository)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageRepositoryRoot, backupManifestDir)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageSisRoot, &this->singleInstanceStore)
this->pluginAppxKey.GetStringValue(s_DownlevelPackageSisRoot, packageRoot)
this->pluginAppxKey.GetUInt32Value(c_hasCellularModemValue, &hasModem)
this->pluginAppxKey.Open(HKEY_LOCAL_MACHINE, effectivePluginPath, KEY_ALL_ACCESS)
this->pluginAppxKey.OpenSubKey(s_Applications, KEY_READ, &applicationsKey)
this->pluginAppxKey.OpenSubKey(s_DownlevelGather, KEY_READ, &this->pluginDownlevelGatherKey)
this->pluginAppxKey.SetBinaryValue(migXmlRegValueName, migXml, (SysStringLen(migXml) + 1) * sizeof(OLECHAR))
this->pluginAppxKey.SetStringValue(s_DownlevelPackageRepositoryRoot, this->packageRepository.GetChars())
this->pluginAppxKey.SetStringValue(s_DownlevelPackageSisRoot, this->singleInstanceStore.GetChars())
this->pluginAppxKey.SetUInt32Value(s_ProcessPackagesToApplyUsingGatheredData, 1)
this->pluginAppxKey.ValueExists(s_ProcessPackagesToApplyUsingGatheredData, &valueExists)
this->pluginDownlevelGatherKey.CreateSubKey(allUserStoreRegistryKeyName, KEY_READ | KEY_WRITE, &pluginAllUserStoreKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_BundleManifestInfo, KEY_READ | KEY_WRITE, &bundleInfoRootKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_ExcludeFiles, KEY_READ | KEY_WRITE, &excludeFilesKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_ExcludeInfusedApps, KEY_READ | KEY_WRITE, &excludeInfusedAppsKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_InstalledPackages, KEY_READ | KEY_WRITE, &installedPackagesKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_PackageInstallState, KEY_READ | KEY_WRITE, &installStateRootKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_SisDirectory, KEY_READ | KEY_WRITE, &sisDirectoryKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_StateChange, KEY_READ | KEY_WRITE, &stateChangeKey)
this->pluginDownlevelGatherKey.CreateSubKey(s_StubPreference, KEY_READ | KEY_WRITE, &stubPreferenceKeyCopy)
this->pluginDownlevelGatherKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &userKey)
this->pluginDownlevelGatherKey.OpenSubKey(allUserStoreRegistryKeyName, KEY_READ, &allUserStoreKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_BundleManifestInfo, KEY_READ, &bundleInfoRootKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_InstalledPackages, KEY_READ, &installedPackagesKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_PackageInstallState, KEY_READ, &installStateKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_PackageInstallState, KEY_READ, &installStateRootKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_SisDirectory, KEY_READ, &sisDirectoryKey)
this->pluginDownlevelGatherKey.OpenSubKey(s_StateChange, KEY_READ, &stateChangeKey)
this->pluginDownlevelGatherKey.OpenSubKey(userSid, KEY_READ, &userKey)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_ExcludeFiles, KEY_READ, &excludeFilesKey)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_ExcludeInfusedApps, KEY_READ, &excludeInfusedAppsKey)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_PackageInstallState, KEY_READ, &installStateRootKey)
this->pluginDownlevelGatherKey.OpenSubKeyIfExists(s_StubPreference, KEY_READ, &stubPreferenceRootKey)
this->pluginPackagesToCheckForStagingCompletionKey.CreateSubKey( packageFullName, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToRemoveKey.CreateSubKey( provisionedPackageFullName, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToRemoveKey.CreateSubKey( uplevelProvisionedPackage, KEY_READ | KEY_WRITE, &packageKey)
this->pluginPackagesToReRegisterKey.CreateSubKey(userSid, KEY_READ | KEY_WRITE, &perUserReRegistrationKey)
this->stagedOnlyManifestPackageFullNameSet.InsertIgnoreDuplicates(packageFullName)
this->uplevelProvisionedPackageFamilyNameSet.InsertIgnoreDuplicates(familyName.GetChars())
this->uplevelProvisionedPackageMap.Insert( familyNameBuffer.GetChars(), fullNameBuffer.GetChars())
this->userSids.Add(userSid)
threadId
tjD9|$Pvc
tLD8eHt?H
tlH9x
TlP0X
tmfD9"tgH
TOC8uJ
TotalTimeTaken
Translation
u HcA<H
u@H!]@M
U0S0Q
UATAUAVAWH
UATAVH
UAUAVH
UAVAWH
UAVAWI
Unable to clean-up orphan packages: 0x%x
Unable to clean-up SystemApps migrated to FOD: 0x%x
Unable to clear IsSingletonRegisteredFlags: 0x%x
Unable to copy backup manifest for end of life packages if necessary: 0x%x
Unable to copy metadata: 0x%x
Unable to DeleteOSRollbackPackagesRegistry: 0x%x
Unable to Mark up-level provisioned paused packages as staged: 0x%x
Unable to pre register packages: 0x%x
Unable to re index packages for feature light up: 0x%x
Unable to Remove up-level provisioned unneeded packages: 0x%x
Unable to repair Package Repository registry key values for packages: 0x%x
Unable to repair PackageRootFolder values for packages: 0x%x
Unable to repair StateRepository for %s: 0x%x
Unable to SavePackageListFromFileToRegistry: 0x%x
Unable to set security descriptor for all user store key with 0x%x
Unable to set security descriptor for deprovisioed key with 0x%x
Unable to set security descriptor for end of life key with 0x%x
Unable to set security descriptor for staged key with 0x%x
Unable to set up packages for re-registration: 0x%x
Unable to update families registryKey ACLs: 0x%x
Unable to write all user store keys 0x%x
Unexpected failure from ExpandEnvironmentStrings on string %s. Buffer size %u characters. Required size %u characters
Unexpected failure from ExpandEnvironmentVariables on string %s
UnhandledExceptionFilter
unknown
Unnecessary. Skipping EnumAndAddPackagesNotKnownToCapAuth
UpdateProcThreadAttribute
Upgrade
upgradeKey.Open(HKEY_LOCAL_MACHINE, upgradePath.GetChars(), KEY_READ | KEY_WRITE)
upgradeKey.OpenSubKey(userSid, KEY_READ, &userSidKey)
upgradeKey.SetUInt64Value(timeElapsedValueName, timeElapsed)
upgradeKey->SetUInt32Value(AppxAllUserStore::regValueIsDevModeApp, 1)
Uplevel OS image has a version of package %ws. No need to preserve it
Uplevel Provisioned package: %ws found in appxprovisioning.xml
uplevelPackageToDelete->SetValueFromString(fullNameKey)
uplevelStubPreferenceKey.CreateSubKey(packageFamilyName.GetChars(), KEY_READ | KEY_WRITE, &packageFamilyKey)
userInfo.Get()->get_InstallState(&installStateValue)
userInfo->get_UserSecurityId(userInfoSid.Address())
userInfoCollection->First(userInfoIterator.GetAddressOf())
userInfoIterator->get_Current(userInfo.GetAddressOf())
userInfoIterator->get_HasCurrent(&hasCurrent)
userInfoIterator->MoveNext(&hasCurrent)
userInfoSid.GetLpcwstr(&userAsLpcwstr)
userKey.CreateSubKey(packageFullName, KEY_READ | KEY_WRITE, &packageKey)
userKey.OpenSubKey(packageFullName, KEY_READ, &packageKey)
userPathBuilder.AppendString(registryClassesPrefix)
userPathBuilder.AppendString(subKey)
userPathBuilder.AppendString(userSid)
USERS\
userSid->SetValueFromString(subKey)
userSidAsInternalString.Initialize(userSid, static_cast<ULONG>(wcslen(userSid)))
userSidKey.KeyExists(packageFullName, isPackageEndOfLife)
USVWATAUAVAWH
USVWATAUAWH
USVWATAVAWH
USVWAVH
USWATAUAVAWH
UVATAVAWH
UVWATAUAVAWH
UVWATAVH
UVWAVAWH
UWATAUAVH
UWATAUAWH
UWATAVAWH
UWATH
UWAUAVAWH
UWAVH
UWAWH
uzH9A
valueBuffer.SetCapacity(valueBufferLength)
valueNameBuilder.AppendString(pluginHasExecutedOfflineValueName)
valueNameBuilder.AppendString(userSid ? userSid.get() : L"")
VarFileInfo
VerQueryValueW
version="1.0" encoding="utf-8"
versionData.IsNull()
VS_VERSION_INFO
VWATAVAWH
VWAUAVAWH
VWAVH
WaitForSingleObject
WaitForSingleObjectEx
WaitForThreadpoolTimerCallbacks
Washington1
WATAUAVAWH
WATAVH
WATAWH
WAVAWH
wcscmp
wcsrchr
wcsstr
wilResult
WilStaging_02
Windows.Foundation.Collections.IIterator`1<String>
Windows.Foundation.Collections.IVector`1<String>
Windows.Foundation.Collections.IVectorView`1<String>
Windows.Internal.StateRepository.Management.RepositoryManager
Windows.Internal.StateRepository.Package
Windows.Management.Deployment.Internal.PackageManagerInternal
Windows.Management.Deployment.PackageManager
Windows.MiracastView_6.3.0.0_neutral_neutral_cw5n1h2txyewy
Windows::Foundation::ActivateInstance( Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_Management_Deployment_Internal_PackageManagerInternal).Get(), &packageManager)
Windows::Foundation::ActivateInstance( Windows::Internal::StringReference(RuntimeClass_Windows_Internal_StateRepository_Management_RepositoryManager).Get(), &repositoryManager)
Windows::Foundation::ActivateInstance(acid.Get(), &inspectable)
Windows::Foundation::ActivateInstance(strActivatableClassId.Get(), &packageManager)
Windows::Foundation::Collections::Internal::Vector<HSTRING>::Make(&packagesToCheckForStagingCompletion)
Windows::Foundation::Collections::Internal::Vector<HSTRING>::Make(&packagesToReRegister)
Windows::Foundation::GetActivationFactory( Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_Internal_StateRepository_Package).Get(), &packageStatics)
Windows::Foundation::GetActivationFactory(acid.Get(), &packageStatics)
WindowsCreateString
WindowsCreateStringReference
WindowsDeleteString
WindowsDuplicateString
WindowsGetStringRawBuffer
WindowsStringHasEmbeddedNull
WriteAllProvisionedUninstalledPackageKeysToListUsingGatheredData( userSid, provisionedInstalledPackageFullNames, &provisionedUninstalledPackageFullNames)
WriteDeprovisionListToPluginAllUserStoreUsingGatheredData()
WriteFile
WriteOutRegistryIncludeRules( MigXmlRules::perMachineRegistryRules, ARRAYSIZE(MigXmlRules::perMachineRegistryRules), true, xmlWriter)
WriteOutRegistryIncludeRules( MigXmlRules::perUserRegistryRules, ARRAYSIZE(MigXmlRules::perUserRegistryRules), false, xmlWriter)
WritePackageAlreadyInstalledForUserKey(userSid, fullNameToWrite)
WritePackageAlreadyInstalledForUserKey(userSid, package)
WritePackageRegistryKey( packageElement->GetKey(), bundleFullName, userSid, &this->pluginStagedKey, s_Staged)
WritePackageRegistryKey( packageElement->GetKey(), mainPackageFullName, userSid, &this->pluginStagedKey, s_Staged)
WritePackageRegistryKey( packageFamilyName, bundleFullName->GetChars(), userSid, &this->pluginDownlevelInstalledKey, s_DownlevelInstalled)
WritePackageRegistryKey( packageFamilyName, fullNameToWrite, userSid, &this->pluginUpgradeKey, s_Upgrade, &createdKey)
WritePackageRegistryKey( packageFamilyName, packageFullName, userSid, &this->pluginDownlevelInstalledKey, s_DownlevelInstalled)
WritePackageRegistryKey( packageFamilyName, packageFullName, userSid, &this->pluginStagedKey, s_Staged)
WritePackageRegistryKey( packageFamilyName.GetChars(), packageFullName, userSid, &this->pluginStagedUserAcquiredKey, s_Staged)
WritePackageRegistryKey( packageFullName, userSid, &this->pluginEndOfLifeKey, s_EndOfLife)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, &this->pluginDownlevelInstalledKey, s_DownlevelInstalled, packageRoot.GetString(), &downlevelInstalledKey)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, &this->pluginUpgradeKey, s_Upgrade, packageRoot.GetString(), &upgradeKey)
WritePackageRegistryKeyWithPath( packageFamilyName, packageFullName, userSid, registryKey, keyName, manifestPath.GetString(), createdKey)
WritePackagesToCheckPostUpgradeToSetupKeyUsingGatheredData()
Writing %ws Key %ws
Writing %ws Key %ws\%ws
Writing Applications Key %ws
Writing Downlevel all-user key %ws to uplevel key
Writing out to exclude file %ws in XML Writer.
Writing out to include directory %ws in XML Writer.
Writing out to include directory %ws, file %ws in XML Writer.
Writing out to include registry key %ws in XML Writer.
Writing out to include registry key %ws, value %ws in XML Writer.
Writing out to merge registry key %ws in XML Writer.
Writing out to merge registry key %ws, value %ws in XML Writer.
Writing out to move directory %ws to backup folder in XML Writer for OS downgrade.
Writing out to registry %ws in XML Writer.
Writing Package to PackagesToCheckForStagingCompletion Key: %ws
Writing up-level provisioned deprovisioned Package to PackagesToRemove Key: %ws
Writing up-level provisioned package to PackagesToRemove Key: %ws
x ATAVAWH
x AVH
x UATAUAVAWH
x=D9u
x2D8d$@u+L
x86a64
xA_A^A]A\_^[]
xmD8|$@ufD
xmlns:m="http://schemas.microsoft.com/appx/2013/appxprovisionpackage"
Y@H9;u+L
z.9Wv
