 ----- ----
      
      -
      - 
           
 -         - 
                              
        %s = %s;
        %s = %s[%d];
        %s = asm {
        %s = NULL;
        // No embedded %s
     NO
    %s
    // %s
    {
    }
    },
    3
    asm {
    lib_4_0_ps_%u_%u
    lib_4_0_ps_2_x
    lib_4_0_vs_%u_%u
    lib_4_0_vs_2_x
    N/A
    NULL,
    oMask
    oStencilRef
    pass 
    preshader
    ps_%u_%u
    ps_2_sw
    ps_2_x
    ps_3_sw
    tx_%u_%u
    u
    vs_%u_%u
    vs_2_sw
    vs_2_x
    vs_3_sw
    YES
   %c%c%c%c
   o%-4u %-3u 
   oDepth
   primID
  // 
 - note that the target doesn't support texture sampling intrinsics
 - note that the target doesn't support textures
 - note that the target doesn't support UAVs
  special
 - Try reducing number of constant branches, take bools out of structs/arrays or move them to the start of the struct
 - Try reducing number of constants referenced
 - Try reducing number of loops, take loop counters out of structs/arrays or move them to the start of the struct
  v%-4u %-3u 
 !"#$%
 !"#$%&'(
 !"#$%&'()*+
 !"#$%&'()*+,-
 !"#$%&'()*+,-./012
 !"#$%&'()*+,-./01234567
 !"#$%&'()*+,-./0123456789:;<=>?@
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
 !"#$%&'().
 !"#$%&'()+++++++++++++++++++++++++++++++++++++++++++*
 !###########################"###############
 !;<=> !
 !@"@
 !+,`
 !1234zw
 "%s"
 $@#@
 %-20s
 %c%-4u
 %u, %u, %u
 (%.9g
 (%u texture, %u arithmetic)
 (@*@
 (ordinal)
 (second)
 : %s
 : packoffset(c%u.%c)
 : register(%c%u)
 ;@5@
 ;~Dr
 ;~Tr
 ??? 
 [unused]
 { nonuniform }
 + %d]
 = "%s"
 = { 
 = { "%s"
 0/0014181<1@1D1H1L1P1T1X1\1`1d1h1l1
 0'0.0e0
 0H0p0
 0L0x0
 0x%x
 bool
--- Compilation status for library function '%s' ---
 const
 constant 
 domain_isoline
 domain_quad
 domain_tri
 expr
 float
 fp%u[%u][%u] = {
 ft%u = {
 inout
 l(%f)
 line 
' line %d)
 lineadj 
 linear 
 linear centroid 
 linear noperspective 
 linear noperspective centroid 
 linear noperspective sample 
 linear sample 
 linestrip 
 Microsoft Corporation. All rights reserved.
 min10float
 min12int
 min16float
 min16int
 min16uint
 min8uint
 oDepthGE
 oDepthLE
 Operating System
 output_line
 output_point
 output_triangle_ccw
 output_triangle_cw
 partitioning_fractional_even
 partitioning_fractional_odd
 partitioning_integer
 partitioning_pow2
 patch1 
 patch10 
 patch11 
 patch12 
 patch13 
 patch14 
 patch15 
 patch16 
 patch17 
 patch18 
 patch19 
 patch2 
 patch20 
 patch21 
 patch22 
 patch23 
 patch24 
 patch25 
 patch26 
 patch27 
 patch28 
 patch29 
 patch3 
 patch30 
 patch31 
 patch32 
 patch4 
 patch5 
 patch6 
 patch7 
 patch8 
 patch9 
 point 
 pointlist 
 Program Database
 Reg   Size
 row_major
 SVW3
 SVWj
 t,VW
 t4Sh
 triangle 
 triangleadj 
 trianglestrip 
 tTWh
 tX=SFI0t
 u[h`
 uint
 unaligned
 undefined 
 void
 volatile
 vPos
 vPSize
 Windows
 x%i[%i], %d
!"#$!%&'(%&'(%)*+,)-./0-./0-1234
!&)+-/135
!0E0_0
!1_1f1
!T$`#
!This program cannot be run in DOS mode.
"""""
"""""""
""""""""
""""""""""
"""""""""""
"""""""""""""""""""""
""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""
"%&'%[
"%s" with respect to "%s"
"2)2N2U2s2z2
"t"hH`
#######
########
###########
#################
#####################
#######################
########################
##########################
################################
##Internal error##
#} #M$
#0*0f0
#0E0c0q0w0
#D$ #
#D$,P
#D$l#L$@#D$ #
#hlsl_full_path
#hlsl_full_path must be the first content in a source file
-#INF
#L$@#D$ #
#L$`#D$8
#L$0;
#L$H#D$L
#line 
#line %u
#line %u %.*s
#M #E$
#pragma def (%s, %s, %g, %g, %g, %g)
'#pragma def' is no longer supported on DX10+ and 10level9 targets.  Use compatibility mode to allow compilation for now.
#pragma feature(%s) must appear before any local declaration
#pragma pack_matrix()
#pragma pack_matrix(column_major)
#pragma pack_matrix(row_major)
#pragma ruledisable "%s"
#pragma warning (disable:%d)
#pragma warning (error:%d)
#pragma warning (once:%d)
#t$0;
#T$P#|$T
#t$P#T$T
$""""
$%"#'(*,.02
$%%&&'''())**++++,,,,-----------..////0011223344555666666789:;<=>?@ABCD
$`<`u
$`<`u<
$`<`u1
$0)0.050:0A0H0M0T0Y0`0
$0< t!
$0< tzj
$0< u
$0-060
$070J0l0
$CBufferForClipPlane_%u
$clip_outputs
$Element
$Globals
$Invalid
$IsAnyDeriv(x)/dz -> $IsAnyDeriv(dx/dz) <| SR.GenDerivatives_Unary
$IsAnyShift(x, and(31, y)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
$IsAnyShift(x, and(y, 31)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
$IsAtomicAllocConsume(a, res) -> append_arg(all_sources(o, a)) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsAtomicAllocConsume(a, res) -> append_arg(all_sources(o, a)) <| SMR.DataFlagAnalysis_PlaceHolder
$IsBasicOrImmAtomic(a, res, addr, op) -> append_arg(all_sources(o, a), a, addr, op) <| SMR.DataFlagAnalysis_PlaceHolder
$IsBasicOrImmAtomic(a, res, addr, op) -> append_arg(all_sources(o, a), addr, op) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsLoop(a) -> append_sources() (loop predicate linkage) <| SMR.DataFlagAnalysis_PlaceHolder
$IsMultiWriteOut(a, chain) -> append_sources(a) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsMultiWriteOut(a, chain) -> append_sources(a) <| SMR.DataFlagAnalysis_PlaceHolder
$IsMultiWriteOut(a, chain) -> append_sources(a) <| SMR.RangeDataAnalysis
$IsResLoad(uav, a, addr, offs, mask) -> append_arg(all_sources(o, a), addr, offs) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsResLoad(uav, a, addr, offs, mask) -> append_arg(all_sources(o, a), uav, a, addr, offs, mask) <| SMR.DataFlagAnalysis_PlaceHolder
$IsResLoad(uav, a, addr, offs, mask) -> append_arg(sources(o, a)) <| SMR.RangeDataAnalysis
$IsResStore(uav, a, addr, offs, mask, val) -> append_param(a) (chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsResStore(uav, a, addr, offs, mask, val) -> append_param(a) <| SMR.DataFlagAnalysis_PlaceHolder
$IsRound(fp int) = mov(fp int) <| MR.GenSimplifyInstructionsOpt1_NoExcl
$IsStandardLoad(a, chain) -> append_addressed(o, chain) (range/flag prop) <| SMR.RangeDataAnalysis
$IsStandardLoad(a, chain) -> append_addressed(o, chain), append_arg(a, chain) <| SMR.DataFlagAnalysis_PlaceHolder
$IsStandardStore(addr, val, chain) -> append_param(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
$IsStandardStore(addr, val, chain) -> append_param(chain) <| SMR.DataFlagAnalysis_PlaceHolder
$IsSync() -> append_all_visible+inputs(UAV chain args) <| SMR.DataFlagAnalysis_PlaceHolder
$IsTwoValueAtomic(chain, res, addr, op1, op2) -> append_arg(all_sources(o, chain), chain, addr, op1, op2) <| SMR.DataFlagAnalysis_PlaceHolder
$IsTwoValueAtomic(chain, res, addr, op1, op2) -> append_arg(chain, addr, op1, op2) <| SMR.DataFlagAnalysis_NoPlaceHolder
$p< u
$p< uA
$P<@u
$Params
$PRESHADER_PS
$PRESHADER_VS
$SKIP
$super
$SVWh0k
$SVWj
$t,VW
$t[=PERF
$T0 $ebp = $eip $T0 4 + ^ = $ebp $T0 ^ = $esp $T0 8 + =
$T0 $esp = $eip $T0 ^ = $esp $T0 4 + = $ebp $ebp = $ebx $ebx = $eax $eax = $ecx $ecx = $edx $edx = $esi $esi = $edi $edi =
$T0 .raSearch = $eip $T0 ^ = $esp $T0 4 + =
$T0 .raSearch 4 - = $ebp $T0 ^ = $eip $T0 4 + ^ = $esp $T0 8 + =
$T2 $esp = $T0 .raSearchStart =
$T2 $esp = $T0 .raSearchStart = $eip $T0 ^ = $esp $T0 4 + = $ebp $ebp = $ebx $ebx =
$ThisPointer
$u,VW
%%%%%&%%%%4
%.14fl
%0,016;6
%0E0V3]3G4h4o4
%1@1D1H1L1P1T1X1\1`1w1
%-17s
%-20s
%2u %9u 
%3333
%4u%c 
%4u: Illegal instruction index
%cnorm can not be used with type
%cs_%d_%d
%d constant registers (c#) read by instruction.  Max. constant registers readable per instruction (even if they are the same) is %d.  This is in addition to the read port limit of %d for constants, which restricts how many *different* constants can be read. (There is one exception: none of this applies to the SINCOS macro instruction.)
%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d.
%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d. 
%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d. (There is one exception: this rule does not apply to the SINCOS instruction.)
%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d.(There is one exception: this rule does not apply to the SINCOS macro instruction.)
%d different constant registers (c#) read over 2 co-issued instructions. Max. different register numbers from any one register type readable across co-issued instructions is %d.
%d different input (v#) or texture (t#) registers read by instruction.  Max. different input/texture registers readable per instruction is %d.
%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d.
%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d. 
%d different input registers (v#) read over 2 co-issued instructions. Max. different register numbers from any one register type readable across co-issued instructions is %d.
%d different input registers (v*#) read by instruction.  Max. different input registers readable per instruction is %d.
%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d.
%d different temp registers (r#) read over 2 co-issued instructions. Max. different register numbers from any one register type readable across co-issued instructions is %d.
%d different texture coordinate registers (t#) read by instruction.  Max. different texture registers readable per instruction is %d.
%d different texture registers (t#) read by instruction.  Max. different texture registers readable per instruction is %d.
%d different texture registers (t#) read over 2 co-issued instructions. Max. different register numbers from any one register type readable across co-issued instructions is %d.
%d[%d].
%JK%[:;"%a#"\<STUb
%s %s
%s %s = 
%s %s[%d] = 
'%s' : macro redefinition
'%s' : unknown pragma ignored
'%s' already defined as a %s
%s array index must be a literal expression
%s array signature parameter %s cannot be indexed dynamically.
%s bem cannot be co-issued.
%s binding ranges overlap for range %s[%d:%d]
%s can only be used with non-NULL shaders
%s can only emit to 1 stream
%s can only emit to streams 0-%u
%s cannot be redeclared
%s cannot be used with doubles, cast to float first
%s can't operate on array references
%s condition parameter can't specify min precision. 
%s condition parameter%s can't specify min precision. 
%s def cannot be co-issued.
%s did not match any prototype in the class
%s does not allow instancing
%s does not allow textures or samplers to be members of compound types
%s does not allow writable textures, samplers or UAVs to be members of compound types with interface inheritance
%s does not have method '%s'
%s does not support 16-bit float conversions
%s does not support 16-bit uint minimum-precision data
%s does not support 8-bit or 16-bit integers
%s does not support aborts
%s does not support Append/Consume buffers
%s does not support double-precision floating-point
%s does not support doubles
%s does not support groupshared, groupshared ignored
%s does not support indexing resources
%s does not support interface bindings
%s does not support interlocked operations
%s does not support messages
%s does not support minimum-precision data
%s does not support msad4
%s does not support multi-output stream out
%s does not support pull-model attribute evaluation
%s does not support pull-model evaluation of position
%s does not support stream out
%s does not support structs without members
%s does not support structured buffers
%s does not support synchronization operations
%s does not support thread synchronization operations
%s does not support typed UAVs
%s does not support UAVs
%s dp4 cannot be co-issued.
%s emulates A / B with A * reciprocal(B). If the reciprocal of B is not representable in your min-precision type the result may not be mathematically correct.
%s FAILED!
%s input limit (%d) exceeded, shader uses %d inputs.
%s instruction cannot be predicated.
%s instruction cannot write to scalar output register.
%s instruction cannot write to scalar output registers (oFog, oPts).
%s instruction does not support _sat modifier.
%s instruction must use destination writemask: .%s
%s instruction requires parameter to be label (l#). 
%s instruction requires sampler declared in %s mode.  Opcode #%d, operand #%d (counts are 1-based). 
%s instruction requires shader model 5 or higher.
'%s' is not a valid instruction in this shader version
'%s' is not a valid register name.  Registers must start with v_, r_, c_, b_, or i_ depending on the register type. (o_ for vs_3_0 only)
%s is not supported on %s
%s is only valid in hull shaders
'%s' matches a variable in the template shader but the type layout does not match
'%s' max tesselation factor must be in the range [1,64]
'%s' must have a max vertex count
'%s' must have a max vertex count greater then 0
%s nop cannot be co-issued.
%s not supported on the given type
%s object does not have method '%s'
%s object does not have methods
%s only allows up to %u instances
%s only supports interlocked operations on scalar int or uint data
%s output limit (%d) exceeded, shader uses %d outputs.
%s phase marker cannot be co-issued.
%s register already declared.
%s registers live in the same name space as outputs, so they must be bound to at least %c%u, manual bind to slot %s failed
%s requires %s parameter to be integer constant register (i#). 
%s requires %s parameter to be label (l#). 
%s requires parameter (the branch condition) to be boolean constant register (b#), or predicate register (p0). 
%s requires parameter (the branch condition) to be boolean constant register (b#). 
%s requires replicate swizzle for source parameter(s) in order to select component. For the vPos register, this can either be .x or .y (z,w are not available). 
%s requires replicate swizzle for source parameter(s) in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)
%s requires replicate swizzle for the source parameter in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)
%s requires resource declared as texture2D/2DArray%s.  Opcode #%d, operand #%d (counts are 1-based). 
%s requires second source parameter (the condition) to be boolean constant register (b#), or predicate register (p0). 
%s requires second source parameter (the condition) to be boolean constant register (b#). 
%s requires the condition parameter%s to be boolean constant register (b#), or predicate register (p0). 
%s requires the condition parameter%s to be boolean constant register (b#). 
%s requires the first parameter to be a label (l#). 
%s semantic '%s'
%s semantic '%s' cannot be centroid
%s semantic '%s' has been deprecated; use '%s%d' instead
%s shader fragments are not supported
%s signature parameter %s (1-based Entry %d) has an unrecognized system name. 
%s signature parameter %s (1-based Entry %d) specifies invalid interpolation mode for integer component type. 
%s signature parameter %s (1-based Entry %d) specifies unrecognized or invalid component type. 
%s signature parameter %s (1-based Entry %d) type must be a scalar float. 
%s signature parameter %s (1-based Entry %d) type must be a scalar uint. 
%s signature parameter %s (1-based Entry %d) type must be float32 and mask must be xyzw. 
%s signature parameter %s (1-based Entry %d) type must be float32. 
%s signature parameter %s (1-based Entry %d) type must be uint32. 
%s snap offset must be in the range -8 to 7
%s target does not support texture lookups
%s tessfactor %ss missing
'%s' used but not defined
%s X%u: 
'%s'!'%s'
%s%d must be a four-component vector
%s%d%s
%s%s contains a system-interpreted value (%s) which must be written in every execution path of the shader.  Unconditional initialization may help. <| A%u (B%u)
%s%s contains a system-interpreted value (%s) which should be written in every execution path of the shader <| A%u (B%u)
%s%s requires replicate swizzle for this parameter in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)
%s%u,space%u
%s%u.%c
%s%u[%u:
%s%ux%u
%s(%d) : 
'%s(%s)' attribute expected, where '%s' are %s
'%s(%s)' attribute expected, where '%s' is %s
'%s': %s cannot be declared 'const'
'%s': %s cannot be declared 'extern'
'%s': %s cannot be declared 'groupshared'
'%s': %s cannot be declared 'inline'
'%s': %s cannot be declared 'shared'
'%s': %s cannot be declared 'single'
'%s': %s cannot be declared 'static'
'%s': %s cannot be declared 'uniform'
'%s': %s cannot be declared 'uniform out'
'%s': %s cannot be declared 'volatile'
'%s': %s cannot be target specific
'%s': %s cannot be void
'%s': %s cannot have %ss
'%s': %s cannot have annotations
'%s': %s cannot have semantics
'%s': %s does not support 64-bit integers
'%s': %s does not support 8-bit or 16-bit integers
'%s': %s does not support doubles as a storage type
'%s': %s does not support minimum-precision data
'%s': %s must be a literal expression
'%s': %s only allows one depth output
'%s': %s semantic has no special meaning on 10level9 targets
'%s': %ss are limited to no more than %u parameters (%u given)
'%s': ambiguous function call
'%s': array dimension must be between 1 and 65536
'%s': array dimensions of %s must be explicit
'%s': cannot %sconvert %sfrom '%s' to '%s'
'%s': class does not implement method %s
'%s': Compute shaders can't return values, outputs must be written in writable resources (UAVs).
'%s': conversion from larger type to smaller, possible loss of data
'%s': declaration type differs from definition type
'%s': default parameters can only be provided in the first prototype
'%s': doubles cannot be used as library function inputs or outputs. If you need to pass a double to a library function, you must pass it as two uints and use asuint and asdouble to convert between forms.
'%s': entrypoint not found
%s: ERROR: If either a HullShader or DomainShader is set then both must be set. Technique %s, Pass %s.
%s: ERROR: No valid %s-%s combination could be found in Technique %s, Pass %s.
'%s': extern %s cannot be declared 'groupshared'
'%s': extern %s cannot be declared 'static'
'%s': function must return a value
'%s': function return value cannot contain Effects objects
'%s': function return value differs from prototype
'%s': function return value missing semantics
'%s': functions cannot be declared 'extern'
'%s': functions cannot be declared 'uniform'
'%s': functions cannot have a target
'%s': Geometry shaders can't return values, outputs must be written to streams.
'%s': global structs and classes cannot be changed
'%s': global variables cannot use the 'half' type in %s. To treat this variable as a float, use the backwards compatibility flag.
'%s': groupshared variables cannot hold resources
'%s': identifier represents a %s, not a function
'%s': identifier represents a %s, not a variable
'%s': implicit array missing %s
'%s': implicit array type does not match %s
'%s': implicit truncation of vector type
'%s': incorrect array size
'%s': initializer does not match type
'%s': input parameter '%s' cannot have a geometry specifier
'%s': input parameter '%s' conflicts with geometry specifier of previous input parameters
'%s': input parameter '%s' missing semantics
'%s': input parameter '%s' missing semantics, expected %s
'%s': input parameter '%s' must have a geometry specifier
'%s': input parameter '%s' patch size must be in the range [1,32]
'%s': InputPatch inputs can only be used in hull and geometry (5_0+) shaders
'%s': interface input parameters not yet implemented for hull shaders, use a global interface instead
'%s': interface methods cannot be declared outside of an interface
'%s': interface methods cannot be static
'%s': interface methods cannot have bodies
'%s': interfaces can only be inputs
'%s': interfaces cannot be declared in buffers
'%s': interfaces cannot be members
'%s': interfaces cannot contain data
'%s': interfaces cannot have semantics
'%s': invalid shader target/usage
'%s': library function parameter and return cannot have duplicate semantic '%s'
'%s': library function parameters cannot have duplicate semantic '%s'
'%s': library functions are supported only for PS and VS shaders
'%s': library functions cannot have a target
'%s': line output topologies are only available with isoline domains
'%s': loop control variable conflicts with a previous declaration in the outer scope; most recent declaration will be used
'%s': may only have one InputPatch parameter
'%s': may only have one OutputPatch parameter
'%s': member not a static variable
'%s': method not found in class
'%s': methods cannot have a target or usage
'%s': missing %s
'%s': missing default value for parameter '%s'
'%s': no input primitive specified, if your shader doesn't require inputs, then define an empty struct and give it the proper primitive type.
'%s': no matching %u parameter %s
'%s': non-numeric uniform %s cannot have %ss
'%s': Not all control paths return a value
'%s': only first dimension can be implicit
'%s': out parameters cannot have default values
'%s': output only %s cannot have %ss
'%s': output parameter '%s' missing semantics
'%s': output parameter '%s' not completely initialized
'%s': output parameters cannot be declared 'const'
'%s': output parameters not yet implemented for control point shaders
'%s': OutputPatch inputs can only be used in the domain shaders and a hull shader's patch constant function
'%s': Patch constant function must use the same input control point type declared in the control point phase.
'%s': Patch constant function must use the same output control point type returned from the control point phase.
'%s': Patch constant function's output patch input should have %d elements, but has %d.
'%s': place-holder template resources can only be simple resources, structs and arrays are not supported
'%s': recursive functions not allowed in %s
'%s': return type does not match overridden method
'%s': samplers can only be used with declared textures or texture assignments
'%s': static member not found in class
'%s': static members can only be defined in global scopes
'%s': static methods cannot be called on objects
'%s': 'static' mismatch between declaration and definition
'%s': stream input parameter '%s' can only be used in geometry shaders
'%s': stream input parameter '%s' must be an inout parameter
'%s': stream input parameter '%s' must be an inout parameter 
'%s': stream output parameter '%s' can only be used in geometry shaders
'%s': stream output parameter '%s' must be an inout parameter 
'%s': too many target specifiers given
'%s': top-level interface arguments cannot be 'out'
'%s': Top-level output parameter '%s' not completely initialized
'%s': Top-level return value is not completely initialized
'%s': triangle output topologies are not available with isoline domains
'%s': types cannot contain members of their own type
'%s': undefined variable
'%s': uniform %s cannot be declared 'groupshared'
'%s': uniform %s cannot be declared 'static'
'%s': unsupported type for a library function parameter '%s'
'%s': unsupported type qualifier for a library function parameter '%s'
'%s': variable declared but not defined
'%s': variable is declared as tbuffer, which is not supported for libraries yet
'%s': variables containing textures, samplers and UAVs can only be declared 'static' if the variable only contains resources
'%s': variables of type '%s' cannot be declared 'static'
'%s': void function cannot have a semantic
'%s': void functions cannot return a value
%s: WARNING: There exist invalid %s-%s combinations in Technique %s, Pass %s, depending on which elements of the specified shader array(s) are chosen.
'%s': When defining a pass-through control-point shader, the number of output control points must be zero or must match the input patch size.
'%s': When defining a pass-through control-point shader,you must declare an InputPatch object.
%s[%s]
%s[%u +
%s[%u]
%s[%u].%c
%s[%u][%u].%c
%s[eval(
%s[r%u.%c/%u]<
%s[r%u.%c]<
%s\%s
%s_%s_n%u_%u
%s_n%u_%u
%s+%s
%s<%d
%sInvalid register number: %d.  Max allowed for this type is %d.
%sInvalid register number: %d. Max allowed for this type is %d.
%sInvalid register type.
%sInvalid source modifier for tex* instruction.
%sInvalid source modifier.
%sInvalid source register type for instruction.
%sInvalid source selector for tex* instruction.
%sInvalid source selector.
%sInvalid source selector: %s. The only available source swizzles in this shader version are: .rgba/xyzw (same as not specifying swizzle), .r/x, .g/y, .b/z, .a/w, .gbra/yzxw, .brga/zxyw and .abgr/wzyx. 
%sModifiers are not allowed on constants for ps_1_4.
%sMS%d
%sRegister number: %d on this parameter for a matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d.
%sSource modifier not allowed for tex* instruction.
%sSource register type must be temp (r#) or texture coordinate input (t#) for tex* instruction.
%sSource register type must be texture coordinate input (t#) for texcrd instruction.
%sSource swizzles not allowed on tex* instruction.
%sTexture coordinate registers (t#) are not available to arithmetic instructions.
%sUnexpected source parameter.
%u "%s"
%UUUU+
%UUUU3
%ux%u
&'()*+,-
&0S0Z0e0
&f9<M
&VRQW
(%f, %f, %f, %f)
(%fl, %fl)
(%i,%i,%i)
(%s source param) Invalid register number: %d.  Max allowed for this type is %d.
(%s source param) Modifiers are not allowed on constants for ps_1_x.
(%s source param) Negate or abs modifiers not permitted on source parameters to texld*
(%s source param) Source modifier not allowed on sampler (s#).
(%s source param) Source modifier not allowed on texcoord for texldl.
(%u,%u-%u): 
(%u,%u): 
(())4,--./01/2---.3.
((a << m) & n) | i : if( known_bfi_bitmask_postshift_ignore(n,a,m,i) ) -> bfi(bfi_bitwidth_postshift_ignore(n,a,m,i), m, a, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
((a >> o1) << o2) : if( o1 == o2 ) -> bfi(o, 0, 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
((a >> ov1) << o2) : if( ov1 == o2 ) -> and(a, ~((1 << ov1)-1)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(0 < n) ? 1 : 0 -> umin(1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0l0p0p1t1x1|1
(00080D0d0l0x0
(0x%08x)
(2,2024282
(4?4N4Y4
(a != b) ? a : b -> a <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a != b) ? b : a -> b <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a & ((iv_pow2 << n) - 1)) -> bfi(iv_pow2 + n, 0, a, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & ~(((iv_pow2 << n) - 1) << o) -> bfi(iv_pow2 + n, o, 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & ~(((iv_pow2 << n) << ov) + (-1 << ov))) -> bfi(iv_pow2 + n, ov, 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & ~((iv_pow2 << n) - 1)) -> bfi(iv_pow2 + n, 0, 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(A & B) | (A & C) => (A & (B | C)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a & b) | (a & c) -> and(a, b | c) <| MR.GenSimplifyInstructionsOpt1_Excl
(a & n) | i << m : if( known_bfi_bitmask_ignore(a,n,i,m) ) -> bfi(bfi_bitwidth_ignore(a,n,i,m), m, n | i, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) | r : if( known_bfi_bitmask_noshift(n,a,r) && and_is_zero(n,r) ) -> bfi(bfi_bitwidth_noshift(n,a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
(a & n) << m : if( known_bfi_bitmask(a,n,m) ) -> bfi(bfi_bitwidth(a,n,m), m, n, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) << m : if( known_bfi_bitmask(n,a,m) ) -> bfi(bfi_bitwidth(n,a,m), m, a, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) >> m : if( known_ubfe_bitmask(a,n,m) ) -> ubfe(ubfe_bitwidth(a,n,m), m, n) <| MR.GenD3D10_OptimizeEarlyTranslate
(a & n) >> m : if( known_ubfe_bitmask(n,a,m) ) -> ubfe(bitwidth(n,a,m), m, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a | (((iv_pow2 << n) - 1) << o)) -> bfi(iv_pow2 + n, o, -1, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a | (((iv_pow2 << n) << ov) + (-1 << ov))) -> bfi(iv_pow2 + n, ov, -1, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a | ((iv_pow2 << n) - 1)) -> bfi(iv_pow2 + n, 0, -1, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a | (b << n)) : if(known_bfi_bitwidth_impmask(a, b, n)) -> bfi(get_bfi_bitwidth_impmask(a, b, n), n, b, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(A + A) * 0.5 -> no-op mov of A <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a + F) - a -> append_arg(F) <| SMR.RangeDataAnalysis
(a + F1) - (a + F2) -> append_arg(F1-F2) <| SMR.RangeDataAnalysis
(A + L2) - (A + L1) = L2 - L1 if A non-NaN/Inf <| Explicit
(a << m) & n : if( known_bfi_bitmask_postshift(n,a,m) ) -> bfi(bfi_bitwidth_postshift(n,a,m), m, a, 0i) <| MR.GenD3D10_OptimizeEarlyTranslate
(a << n) >> (m) -> ibfe(32-m, m-n, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a << n) >> (m) -> ubfe(32-m, m-n, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(a == (b ? a : c)) : if (c != a) -> b != 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a == (b ? c : a)) : if (c != a) -> b == 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a == b) ? a : b -> b <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a == b) ? b : a -> a <| MR.GenSimplifyInstructionsOpt1_NoExcl
(a >> m) & n : if( high_bit_clear(a & n) && known_ubfe_bitmask_nomaskshift(a,n,m) ) -> ubfe(ubfe_bitwidth_nomaskshift(a,n,m), m, n) <| MR.GenD3D10_OptimizeEarlyTranslate
(a >> m) & n : if( known_ubfe_bitmask_nomaskshift(a,n,m) ) -> ubfe(ubfe_bitwidth_nomaskshift(a,n,m), m, n) <| MR.GenD3D10_OptimizeEarlyTranslate
(B & A) | (A & C) => (A & (B | C)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(bfi(w, 0i, 0, n) | ubfe(w, 0i, v)) -> bfi(w, 0i, v, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(bfi(w, o, 0, n) | bfi(w, o, v, 0)) -> bfi(w, o, v, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(First source param) 
(Fourth source param) 
(i + I) - i -> append_arg(I) <| SMR.RangeDataAnalysis
(i + I1) - (i + I2) -> append_arg(I1-I2) <| SMR.RangeDataAnalysis
(int)(a & n) >> m : if( high_bit_clear(a & n) && known_ubfe_bitmask(a,n,m) ) -> ubfe(bitwidth(a,n,m), m, n) <| MR.GenD3D10_OptimizeEarlyTranslate
(int)(a & n) >> m : if( high_bit_clear(a & n) && known_ubfe_bitmask(n,a,m) ) -> ubfe(ubfe_bitwidth(n,a,m), m, a) <| MR.GenD3D10_OptimizeEarlyTranslate
(n & a) | r : if( known_bfi_bitmask_noshift(n,a,r) && and_is_zero(n,r) ) -> bfi(bfi_bitwidth_noshift(n,a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
(n > i) ? X : dmin(n, i) -> (i > n) ? X: i <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n > i) ? X : imin(n, i) -> (i > n) ? X: i <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n > i) ? X : min(n, i) -> (i > n) ? X: i <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n > i) ? X : umin(n, i) -> (i > n) ? X: i <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n >= V) ? V : n -> dmin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n >= V) ? V : n -> imin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n >= V) ? V : n -> min(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(n >= V) ? V : n -> umin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(none)
(previous instruction)
(previous instruction) Co-issued instruction cannot write all components - must write either alpha or color.
(previous instruction) Dot-product needs color/vector pipeline to execute, so instruction co-issued with it cannot write to color components.
(previous instruction) Dot-product which writes alpha cannot co-issue, because both alpha and color/vector pipelines used by the dot product.
(previous instruction) dp3 needs color pipe to execute, so instruction co-issued with it cannot write to color components.
(previous instruction) dp3 which writes alpha cannot co-issue since it uses up both the alpha and color pipes.
(previous instruction) dp4 instruction cannot be co-issued.
(previous instruction) Individual instruction in co-issue pair cannot write both alpha and color component(s).
(previous instruction) nop instruction cannot be co-issued.
(root parameter [%u], visibility %s)
(root parameter [%u], visibility %s, descriptor table slot [%u])
(root parameter[%u], visibility %s, descriptor table slot [%u])
(Second source param) 
(Source param) 
(Statement %d) 
(static sampler [%u], visibility %s)
(Third source param) 
(unknown scope entry kind)
(unknown scope value kind)
(unknown)
(unnamed)
(V < n) ? (V+1) : n -> dmin(V+1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? (V+1) : n -> imin(V+1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? (V+1) : n -> min(V+1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? (V+1) : n -> umin(V+1, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? V : n -> dmin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? V : n -> imin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? V : n -> min(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
(V < n) ? V : n -> umin(V, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
)0v0}0l2
)2X2k2}2
* CIL *
-* Linker *
***DIA***
***globals***
, "%s"
, %.9g
, '%s'
, %u, %u
, dynamicIndexed
, fb%u
, forcing loop to unroll
, ft%u
, immediateIndexed
, mode_comparison
, mode_default
, mode_mono
, or '%s'
, space=%d
, space=%u
, stride=%u
, texm3x2depth
,,,,,,,,,,,,
,-./01
,-./012345886788135,-./0
,0F0`0z0
,1g1u1
,SVW3
. The compiler cannot always detect that an array is fully assigned to. Fully initializing the array in its declaration may help avoid this error
.$super
.?AVtype_info@@
._m%u%u
.00cfg
.2E2j2
.Base
.CRT$XCA
.CRT$XCL
.CRT$XCU
.CRT$XCZ
.CRT$XIA
.CRT$XIC
.CRT$XIZ
.CRT$XLA
.CRT$XLZ
.CRT$XPA
.CRT$XPZ
.CRT$XTA
.CRT$XTZ
.data
.data$brc
.data$r$brc
.debug$P
.debug$S
.debug$T
.edata
.gfids
.giats
.idata
.idata$2
.idata$3
.idata$4
.idata$5
.idata$6
.mips can only be used in a two-element indexing expression such as .mips[mip][element]
.rdata
.rdata$brc
.rdata$r$brc
.rdata$sxdata
.rdata$T$brc
.rdata$zzzdbg
.rrrr swizzle expected for operand #%d of opcode #%d (counts are 1-based). 
.rsrc$01
.rsrc$02
.rtc$IAA
.rtc$IZZ
.rtc$TAA
.rtc$TZZ
.sample can only be used in a two-element indexing expression such as .sample[sample][element]
.text
.text$cthunks
.text$di
.text$mn
.text$mn$00
.text$src
.text$tii
.text$wti
.text$x
.text$yd
.tls$
.tls$ZZZ
.xdata$x
/               
/()*OPgc^
/* Interface parameter %u bound to: %s
/* Stream %u out decl: "%s" */
/* Stream %u to rasterizer */
/* Stream out decl: "%s" */
// ---------- --------------------------------------------------
// -------------------- --------------------
// ------------------------------ ------------------
//   
// -------------- --------------- ----------------
// ---------- ------- ---------- ---------
// ---------- ------- --------- --------- ----------------------
// ------------------------------ ---- --------- ------- -------
// -------------------- -------------------- --------------- ---------------- ------------------------------ 
// --------------------------- ---- -- --------- ------- -------
// ------------------------------ ---------- ------- ----------- -------------- ------
// -------------------- ----- ------ -------- -------- ------- ------
// ------------------------------ ---------- ------- ----------- ------- -------------- ------
//              
//             Slots
//       %s
//     %c%-4u= 
//   %s
//   Name
// %-20s %20u
// %-27s %4u 
// %-30s %10s %6s%d %11s %14s %6s %s
// %-30s %10s %6s%d %11s %7s %14s %6s %s
// %-30s %10s %7s %11s %14s %6s %s
// %-30s %10s %7s %11s %7s %14s %6s %s
// %-30s %-18s
// %-30s %4u %9u %7u %7u
// %3u  %s
// %s %s
// %s shader bytecode:
// %s signature:
// %u %s buffer(s)
// %u %s interface(s)
// %u %s object(s)
// %u groups(s)
// %u technique(s)
// | Table ID |         |
// | Type ID  |         |
// | Type ID  |%4u     |
// | Type ID  |%4u-%-4u|
// +----------+---------+---------------------------------------
// <internal error> column mismatch in debug info
// <internal error> could not find inner most frame in PDB
// <internal error> could not get array element stride from PDB
// <internal error> could not get find UDT child with correct offset in PDB
// <internal error> could not get live range length for variable from PDB
// <internal error> could not get location type from PDB
// <internal error> could not get matrix columns from PDB
// <internal error> could not get matrix element length from PDB
// <internal error> could not get matrix major stride from PDB
// <internal error> could not get matrix row-major flag from PDB
// <internal error> could not get matrix rows from PDB
// <internal error> could not get register index count from PDB
// <internal error> could not get register index values from PDB
// <internal error> could not get register type from PDB
// <internal error> could not get UDT child length in PDB
// <internal error> could not get UDT child offset in PDB
// <internal error> could not get UDT child type in PDB
// <internal error> could not get UDT children in PDB
// <internal error> could not get variable index ID from PDB
// <internal error> could not get vector element length from PDB
// <internal error> could not get vector length from PDB
// <internal error> file name too long in debug info
// <internal error> filename length mismatch in debug info
// <internal error> filename mismatch in debug info
// <internal error> incorrect file offset in debug info
// <internal error> incorrect instruction offset in debug info
// <internal error> incorrect scalar offset in debug info
// <internal error> incorrect token offset in debug info
// <internal error> incorrect variable offset in debug info
// <internal error> invalid matrix member
// <internal error> invalid vector member
// <internal error> line mismatch in debug info
// <internal error> offset overruns length for type in PDB
// <internal error> too many instruction outputs in debug info
// <internal error> unable to find instruction in PDB
// <internal error> unable to get array element type from PDB
// <internal error> unable to get column number from PDB
// <internal error> unable to get file id from PDB
// <internal error> unable to get file name from PDB
// <internal error> unable to get HLSL type kind from PDB
// <internal error> unable to get line number from PDB
// <internal error> unable to get matrix element type from PDB
// <internal error> unable to get source file info from PDB
// <internal error> unable to get statement flag from PDB
// <internal error> unable to get sub-variable type from PDB
// <internal error> unable to get type length from PDB
// <internal error> unable to get typedef type from PDB
// <internal error> unable to get vector element type from PDB
// <internal error> unable to instruction offset from PDB
// <internal error> unable to iterate instruction in PDB
// <internal error> unexpected data kind in PDB
// <internal error> unexpected location type in PDB
// <internal error> unexpected register type in PDB
// Approximately %i instruction slots used
// approximately %u instruction slot%s used
// approximately %u instruction%s used
// Available Class Instances:
// Available Class Types:
// b%-9d cb%-5d %10d %9d
// Buffer Definitions: 
// c%-10d %49s
// c%-9d cb%-5d %9d %9d  (
// Child effect (requires effect pool): %s
// clip%-6d cb%-5d %9d %9d  (
// COMMENT: %s
// Constant buffer to DX9 shader constant mappings:
// Created by:  %s
// Debug name: %s
// Default values:
// disassembly only available for VS and PS targets
// Function parameter signature (return: %s, parameters: %u):
// FX Version: %s
// Generated by 
// i%-9d cb%-5d %10d %9d
// Initial variable locations:
// Interface slots, %u total:
// Library:  flags %x, %u functions:
// Name                                 Type  Format         Dim      HLSL Bind  Count
// Name                                 Type  Format         Dim      ID      HLSL Bind  Count
// Name                             ID CB Stride Texture Sampler
// Name                        Type CB CB Offset Texture Sampler
// Name                 Index   Mask Register SysValue  Format   Used
// Name                 SemanticName         In 1st,Num,Mask Out 1st,Num,Mask Type                           
// no %s
// Note: shader requires additional functionality:
// Note: SHADER WILL ONLY WORK WITH THE DEBUG SDK LAYER ENABLED.
// Offset:  N/A Size:   N/A [unused]
// Offset: %4u
// Offset: %4u Size: %5u%s
// Offset: %4u, size: %4u
// Parameters:
// Pixel Shader runs at sample frequency
// Registers:
// Resource Bindings:
// Runtime generated constant mappings:
// s%-13d s%-14d t%-16d
// Sampler/Resource to DX9 shader sampler mappings:
// Target Reg                               Constant Description
// Target Reg Buffer  Source Reg Component
// Target Reg Buffer  Start Reg # of Regs        Data Conversion
// Target Sampler Source Sampler  Source Resource
// Tessellation Domain   # of control points
// Tessellation Output Primitive  Partitioning Type 
// Trace has %u steps (some may be inactive)
/Cube/CubeArray
/LinkInfo
/names
/src/files/
/src/headerblock
: !":#$::%%%&''&'':():::::::::::*::::::+,:-./01:23:45::::::::::67:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::8:9X
: :$:(:,:0:4:8:
: :$:(:,:0:4:8:<:@:D:H:L:P:T:X:\:`:d:h:l:p:t:
: :$:(:,:0:4:8:<:@:D:H:L:P:T:X:\:`:d:h:l:p:t:x:|:
: :$:(:,:0:4:8:t?
: :$:(:,:0:4:h:s:
: :&:2:8:>:D:x<
: :(:=:t:
: :(:4:<:H:P:\:d:p:x:
: :(:8:@:P:X:h:p:
: :,:0:4:@:D:H:T:X:\:h:l:p:|:
: :,:4:=:D:P:X:a:h:t:|:
: :,:8:D:P:\:h:t:
: :;:V:q:
: :@:`:
: :5:J:_:t:
: :8:P:h:
: :D=L=T=d=p=t=
: ;$;(;,;0;4;8;<;@;D;H;L;P;T;X;\;`;d;{;
:!:+:
:!:3:::L:S:w:~:
:!:6:K:`:u:
:!:V:u:
:!;X;
:":*:1:D:I:O:X:`:g:o:{:
:":,:0:7:P:Y:h:r:v:}:
:":-:8:Q:g:r:
:":{:
:":7:L:a:v:
:":A:
:":D:|:
:":e:s:|:
:";1;A; ?/?=?
:#:(:-:2:7:M:
:#:):/:5:;:A:
:#:):3:=:G:Q:[:e:k:u:
:#:/:8:J:S:m:v:
:#:':.:H:Q:]:
:#:1:e:
:#:8:M:b:w:
:#:J:Q:o:v:
:#:U:t:
:#:Z:
:#;*;];
:#;G;\;a;
:#;L;
:$:(:,:8:<:@:L:T:`:d:h:t:x:|:
:$:,:4:D:L:T:d:l:t:
:$:?:Z:u:
:$:4:D:d:t:
:$:8:L:`:t:
:$:9:N:c:x:
:$:l:
:$;(;
:$;+;
:$;A;^;k;x;
:$;g;
:$;P;|;
:%:::O:d:y:
:%:+:1:7:=:C:I:O:U:[:a:g:m:s:y:
:%:<:
:%:3:D:U:\:a:k:u:
:%:4:;:E:g:|:
:%:8:E:N:a:n:w:
:%:H:a:
:%:Q:]:s:
:%;*;;;I;W;
:%;/;u;
:%;B;h;
:&:-:e:s:
:&:;:P:e:z:
:&:0:::D:N:X:t:~:
:&:A<
:&:K:+={>
:&;D;
:&;V;y;
:(:@:D:H:L:P:X:`:h:x:|:
:(:@:X:p:
:(:0:<:D:P:X:d:h:l:x:|:
:(:0:5:<:H:P:U:\:h:p:y:
:(:4:@:L:X:d:p:|:
:(;j;q;
:(;l;
:):3:
:);y;
:*:3:B:L:P:W:p:y:
:*:B:H:`:p:t:x:|:
:*;@;_;~;
:*;K;~;
:*;S;
:*<\<
:,:@:T:
:,:0:L:P:p:
:,:J:Y:p:
:,;0;
:,;0;4;8;<;@;D;g;
:,;0;4;8;L;P;5>3?:?A?
:.:=:L:`:{:
:.:P:
:.;7;?;t;};
:.;a=v=
:.;x;|;
:/:b:
:/:G:M:j:
:/:T:y:
:/;b;i;
:':.:L:S:w:~:
:::::::::::::::
:::X:v:
:::Y:1=9=F=L=R=
::;v;
::__unnamed
::<unnamed-tag>
:-:2:C:M:T:k:y:
:':6:@:D:K:d:m:|:
:':9:\:n:
:';.;
:;;L;v;
:;;n;
:;<=>?@ABCD
:';=;];c;s;z;
:';C;
:';n;
:';t;
:?:[:
:?:d:
:?:F:x:|:
:?:z:
:?;B<H<G=M=
:@:G:j:
:@:W:n:
:@;M;
:@<`<
:[;`;f;l;r;x;~;
:[;e;
:\:f:{:
:\;`;
:\;F<a<
:_;i;
:'<.<
:<;D;
:=:j:
:=:U:t:
:=:w:
:>:E:
:>;_;U?
:>;m;s;
:0:\:
:0:~:
:0:9:H:W:c:h:n:x:|:
:0:F:l:w:
:0:h:
:0:H:`:x:
:0:N:l:
:0:P:p:
:0:X:\:x:|:
:0;4;8;<;@;D;H;L;P;T;X;\;`;d;h;l;p;t;x;|;
:0U1~1
:1<;<
:1=B=m=&>
:2:T:
:2;C;a;h;
:2;u;
:2;w;
:3:::b:i:
:3:;:S:[:
:3:>:`:s:
:3:m:
:3;h;
:3;R;|;
:4:`:
:4:I:^:s:
:4:R:\:c:
:4:W:
:4;^;
:5:D:K:`:w:
:5:P:u:
:5:Z:q:
:5;<<
:5;C;Y;
:6:d:i:z:
:6:i:
:6:r:
:6:T:u;L=
:6;T;X;\;`;d;h;l;p;t;x;|;
:6;v;
:7:O:g:
:7;A;
:7;c;
:7;M;};
:7;P;
:7;W;
:8:@:H:T:t:
:8:=:
:8:g:
:8:H:L:P:T:X:\:h:z:
:8:M:g:q:
:8:P:}:
:8;}; <}<
:8;v;
:9:>:C:J:O:V:]:b:i:n:u:
:9:g:
:A:G;
:A;e;
:b:g:
:B:q:
:B:Q:\:
:C:h:
:C;J;
:D$8t*
:D:k:
:D:Y:
:D;g;
:D;P;u;
:E:p:w:
:e:t:
:E:u:
:E:U:c:j:s:|:
:e:v:
:F:u:
:G:d:
:G:O:x:
:h:r:
:H;];l;~;
:H;L;
:H;O;
:I:t:
:J:{:
:J:d:}:
:K:c:
:K;E<
:L;P;T;X;
:l;v<
:M:T:
:O;f;v;
:r;~;
:R;v;
:r;y;
:ShISGN
:ShOSG5
:ShPCSG
:T;|;
:t;W=
:T;X;\;`;d;h;l;p;t;x;|;
:V;`;
:V;e;
:x;p<
:y;l=v=
:z<c=
; ;$;
; ;$;(;
; ;$;(;,;0;4;8;<;@;D;H;L;P;T;X;\;`;d;h;l;p;t;x;|;
; ;$;0;4;8;D;H;L;X;`;l;t;
; ;,;0;4;@;H;T;\;h;p;|;
; ;>;\;z;
; ;5;J;_;t;
; ;8;P;h;
; ;l;p;
; ;u;
; <p<
;!;';-;3;9;L;R;X;`;d;h;l;p;t;x;|;
;!;+;1;;;E;O;
;!;6;K;`;u;
;!<e<
;";);B;K;Z;d;h;o;
;";+;:;D;H;O;h;q;
;";7;L;a;v;
;";E;{;
;"<[<
;"<D<H<
;"<G<l<
;"<W<
;#;,;8;U;c;w;
;#;/;6;<;C;J;x;
;#;?;[;w;
;#;5;A;E;K;d;m;y;
;#<-<
;#<u<
;$;,;4;D;L;T;d;l;t;
;$;,;8;@;L;T;`;h;t;|;
;$;-;4;P;
;$;>;E;_;f;
;$;0;<;H;T;`;l;x;
;$;0;8;l;t;|;
;$;4;D;d;l;t;
;$<(<,<0<4<8<<<@<i<
;$<+<h<
;$<3<><i<x<
;$<i=
;%;-;2;9;H;n;7<M>
;%<B<e<
;%<C<L<S<
;%=?=
;&;,;0;j;
;&;D;s;
;&;X;_;f;
;&<-<`<m<
;&<-<9=l=
;&<-<T<[<p<t<x<
;&<1<$>b>
;&<A<
;&<G=[=
;(;,;0;<;D;P;X;d;l;x;
;(;@;X;p;
;(;<;P;d;x;
;(;0;9;@;L;T;Y;`;l;t;y;
;(;1;@;F;J;Q;j;s;
;(;4;@;L;X;d;p;|;
;(;6;K;R;Y;`;
;(;f;
;(;U;Z;l;
;(<5<P<'=P=l=
;(<p<
;);;;M;_;q;
;);=;D;V;[;u;
;);U;c;r;
;);W;
;)<0<,=0=4=`=d=h=
;)<N<{<
;*;H;f;
;*;R;d;z;
;*<S<
;*<U<x<
;*=;=
;,;0;L;P;l;p;
;,;1;9;F;M;U;\;d;l;};
;,;3;
;,;X;
;,<d<
;.;7=1>
;.;I;d;
;.;K;h;
;.;O;4<;<B<
;.<8<
;.<V<f<
;.u&C;
;/;@;c;u;
;/>>>L?P?T?X?\?
;:;e;
;:;Z;
;:=A=H=l=p=t=x=|=
;;;P;U;j;q;w;
;';\;`;d;h;l;p;t;x;|;
;';6;A;/>r>
;';h;
;-;M;R;p;
;?;F;M;Z;a;l;s;y;
;?<n<
;@;I;
;[;V<
;\$ r
;\$ s
;\$@r
;\$Dsn
;_0sMSh
;_4s"
;_LrU
;{$v(
;|$,r
;|$|r
;|<s=
;~8u2;N<u-
;+<2<U<5=<=_=B>
;+<Q<w<
;<;\;`;d;h;l;p;t;x;
;<;g;
;<;h;
;<;n;
;'<^<
;<=>?@ABCDEFGHIJKL
;-<4<
;'<K<
;'<P<
;'<X<
;=;N;
;>;^;
;>;{;
;>;v;
;><J<
;0;E;Z;o;
;0;H;`;x;
;0;N;a;
;0;P;p;
;0<4<8<<<@<
;0J0u4
;0t3B
;1;[;
;1;F;[;p;
;2;8;\;
;2;G;\;q;
;2;M;h;
;2<;<O<
;3;;;S;[;s;{;
;3;<;C;e;t;{;
;3;A;G;S;
;3;H;];r;
;3;L;o;
;3;R;
;3<h=
;3<u<
;3=6?
;4;I;^;s;
;4;Q;r;
;4=F=M=m=
;4>G>Z>|>
;5;S;a;g;s;
;5;S;k;
;5<U<[<
;6;?;N;X;\;c;|;
;6;<;[;a;
;6;l;
;6;Q;l;
;6;S;^;
;6<t<
;7;_;{;
;7;D;g;t;
;7<a<o<v<
;7f7K8{8
;7rO;
;8<|<
;8<}<
;8<<<@<D<H<L<P<T<X<\<`<d<h<|<y='>h>t>
;8<d<k<
;9;H;c;
;9;v;
;9<@<a<
;A$uT
;A(uL
;A,uD9s
;A@u"
;A<H<c<
;AhuG
;APu&
;APu(
;B<<=
;B<a<
;BPu&
;C ua
;C$v%
;C,r+
;C,v4;
;C;J;P;
;C@v[
;C<g<
;D$ s
;D$$s$
;D$(sI
;D$\v"
;D$|v
;D$4r
;D$8u
;D$du
;D$hv<
;D$tsp
;D$tu!
;D$xv
;D;H;
;D;y;
;D<r<
;E r5v-
;E$rIw
;E;`;G<d<{<
;E;k;
;E<U<V=e=p=
;E<V<d<m<t<
;E<Z<v<
;E0rS
;E4rswh
;F s[
;F u/
;F uX;~$uS
;F$sH
;F$v-+^$
;F;`;
;F;u;
;F@wP
;F<ruw
;F8rh
;FDw]r
;FLu03
;FPrg
;G s5
;G|r4;
;G|re
;g<l<
;G=e=
;GprE
;H(v'
;H;L;y<
;H<L<
;H<L<P<T<X<\<`<d<h<l<p<
;h<o<
;Hds 
;I<n<
;I<P<
;j;`=g=
;J;b;
;J;X;f;
;K r!
;K;g;
;k;r;
;L$$s
;L$,r
;L$,s
;L$@s
;L$@sU
;L$`s
;L$4sh
;L;{;
;l<p<
;l<p<t<x<|<(=,=h=l=
;L=l>\?
;N;t;
;O(s}
;O<Y<i<y<
;p@s<
;PDu'
;Q,vB
;q<x<
;QLwy
;R;u;
;R;w;
;R<]<j<u<
;S$v#
;s$v,
;S;W=
;S<k<
;t$(r
;t$,r
;T$,r
;T$lr
;U;[;d;m;
;V;};
;VPs5
;wdt)
;wPt'
;X r/
;X;\;`;d;h;l;p;t;x;|;
;X4rH
;Y<l<
? ?$?(?,?0?4?8?<?@?D?H?L?P?g?
? ?$?(?,?0?4?8?<?@?D?H?L?P?T?X?\?`?d?h?l?p?t?x?|?
? ?$?(?4?8?<?H?L?P?\?`?d?p?t?x?
? ?$?4?8?<?
? ?&?,?2?8?>?D?J?P?V?\?b?h?n?x?
? ?*?1?e?
? ?,?0?4?@?D?H?T?X?\?h?l?p?|?
? ?'?.?5?
? ?'?@?I?X?b?f?m?
? ?5?J?_?t?
? ?8?P?h?
? ?b?
? ?F?_?
? ?j?q?
?!?(?I?
?!?6?K?`?u?
?"?7?L?a?v?
?"?D?W?d?
?#?.?P?c?
?#?+?3?D?I?Q?^?e?m?t?|?
?#?1?X?c?w?
?#?5?U?h?
?#?8?M?b?w?
?#?C?c?
?#?N?[?v?
?$?(?,?0?4?
?$?*?1?8???F?M?T?[?c?k?s?
?$?,?4?D?d?
?$?,?8?@?L?T?`?h?t?|?
?$?.?6?H?]?b?i?p?w?~?
?$?+?3?8?^?k?r?y?
?$?>?c?
?$?0?<?H?T?`?l?x?
?$?4?D?T?d?t?
?$?9?N?c?x?
?$?D?d?
?$supu:f
?%?:?O?d?y?
?&?;?P?e?z?
?&?-?
?&?C?X?u?
?&?d?
?&?D?b?
?(?@?X?p?
?(?<?P?d?x?
?(?>?E?
?(?0?<?D?P?X?d?l?x?
?(?4?@?L?X?d?p?|?
?(?C?]?
?)?;?^?p?
?)?0?
?*?M?_?
?*?W?
?,?0?4?8?<?
?,?0?L?P?l?p?
?.?8?<?C?\?e?t?~?
?/?;???F?_?h?w?
?/?G?_?w?
?:?A?Y?
?:?X?v?
?;?g?
?;?i?
?-?;?B?L?R?Y?`?}?
?-?]?
?'?<?Q?f?{?
?-?>?O?`?q?
?'?0?7?C?K?T?Z?`?k?s?|?
?-?2?7?=?G?O?T?[?g?o?t?{?
?'?u?
?@?O?Z?
?]?t?
?<?D?x?
?=?[?y?
?0?4?8?<?@?D?H?a?
?0?9?H?R?V?]?v?
?0?H?`?x?
?0?K?f?
?0?p?x?
?0?X?
?1?7?G?[?l?p?t?x?|?
?1?J?k?
?1?x?|?
?1T2[2
?2?R?r?
?2N2Y2M6T6
?3?;?S?[?s?{?
?3?<?K?U?Y?`?y?
?3?b?
?4?`?
?4?>?U?
?7?e?u?
?8?`?
?8?S?n?
?9?H?
?C?y?
?d?h?
?D?l?
?d?n?
?D?p?
?D?V?
?E?\?o?
?E?_?
?e?v?
?F?e?
?F?P?j?
?G?f?
?H?r?
?H?t?
?L?S?
?N?d?h?x?|?
?N?n?
?n?u?
?O?V?
?P?\?
?R?Y?
?S?a?g?n?u?
?W?j?
?W?w?
?X?\?`?d?h?l?p?t?x?|?
@ !G 
@ )G 
@ ;A 
@ ;A r
@ ;A s>j
@ ;B 
@ ;B vj
@ ;C 
@ ;C uc
@ ;G 
@ ;G v
@ @&@%@
@ 1G 
@ 9A 
@ 9B 
@ 9B r
@ 9C 
@ SVW
@"@"@
@#@$@%@
@$;ADs
@$+A$]
@%s<E&C%03.3d>
@(;A$
@)@8@
@,;ATs
@,;F,u
@,@&@+@
@.reloc
@.rsrc
@:@9@/@
@;~0r
@;D$$v
@;D$(v
@;D$@v
@;D$\v
@;D$Dv
@;D$Xv
@;FTr
@;G,r
@'@.@
@\9A\t$
@<;B<t
@<;H,
@4_^]
@9G s
@9G4s
@D t@
@D_^[
@D_^Y]
@ILT+%d(
@ILT+%d(%s)EnC
@PhAon9
@potentially uninitialized data accessed at this location <| I%u (B%u)
@t,VW
@T3AT
[%8I64u] 
[%ld]
[%s%d.%c]
[%s%d[%s].%c]
[%s.%c]
[%s[%s].%c]
[%s[%u + %s].%c]
[%s[%u].%c]
[internal error]
[RootSignature(%s)]void ___DummyMainForRS(){}
[t,h(
[t'WV
\$$;]
\$$9S 
\$$QQS
\$(9T$$s
\$(9T$@
\$,;|$H
\$,;T$0
\$,=B
\$@9\$0
\$\SW
\$`;\$,
\$0F;t$
\$0GB
\$0QSPh
\$49]
\$8;\$(
\$8VS
\$d;\$`
\$d;ZPs
\$Ht(
\$L;\$,
\$L9\$,
\$LuX
\%9~-
\;0t'A
\]^_\
\1,2,3,4
\1d1{1
],;]4wTr
]7d7q7x748;84989
^021D3Q3f3s3z5
^f9B"u
_ _^[
_%d_%d.
_(_^[
_(t9A
_^[Y]
__%s_n%u_%u
___DummyMainForRS
___ImageBase
__CxxFrameHandler3
__EH_prolog
__EH_prolog2
__EH_prolog3
__EH_prolog3_align
__EH_prolog3_catch
__EH_prolog3_catch_align
__EH_prolog3_catch_GS
__EH_prolog3_catch_GS_align
__EH_prolog3_GS
__EH_prolog3_GS_align
__enc$textbss$begin
__enc$textbss$end
__FILE__
__fx_2_0__
__imp_
__int128
__int16
__int32
__int64
__int8
__isascii
__LINE__
__SEH_prolog
__SEH_prolog4
__SEH_prolog4_GS
__test_intrin1
__test_intrin2
__test_intrin3
__test_intrin4
__unaligned 
__unDName
_8_^[
_aoffimmi
_bias
_binormal
_blendindices
_blendweight
_bx2 cannot be used on src register for texbem or texbeml instructions.
_bx2 cannot be used on src register for texreg2ar or texreg2gb instructions.
_bx2 is a valid src mod for texM* instructions only (%s source param).
_centroid
_centroid flag only permitted on dcl v# statements.
_clearfp
_color
_controlfp
_cube
_CxxThrowException
_depth
_dw(=_da) modifier on source param for texld only allowed if source is a texture coordinate register (t#).
_dw(=_da) modifier on source param must be paired with source selector .xyw(=.rga).
_dynamicindexed
_dz(=_db) modifier cannot be used on source parameter for texcrd. It is only available to texld instruction, when source parameter is temp register (r#).
_dz(=_db) modifier may only be used at most 2 times in a shader.
_dz(=_db) modifier on source param for texld must be paired with source selector .xyz(=.rgb). Note: Using no selector is treated same as .xyz here.
_dz(=_db) modifier on source param for texld only allowed if source is a temp register (r#).
_EH_prolog
_EH_prolog2
_EH_prolog3
_EH_prolog3_align
_EH_prolog3_catch
_EH_prolog3_catch_align
_EH_prolog3_catch_GS
_EH_prolog3_catch_GS_align
_EH_prolog3_GS
_EH_prolog3_GS_align
_except_handler4_common
_finite
_indexable
_initterm
_initterm_e
_isnan
_KiUserCallbackDispatcher@12
_KiUserExceptionDispatcher@8
_normal
_NT_ALT_SYMBOL_PATH
_NT_SYMBOL_PATH
_o___std_type_info_destroy_list
_o___stdio_common_vsnprintf_s
_o___stdio_common_vsnwprintf_s
_o___stdio_common_vsprintf
_o___stdio_common_vsprintf_s
_o___stdio_common_vsscanf
_o___stdio_common_vswprintf
_o___stdio_common_vswprintf_s
_o__atoi64
_o__callnewh
_o__cexit
_o__chsize_s
_o__CIacos
_o__CIasin
_o__CIatan
_o__CIatan2
_o__CIcos
_o__CIcosh
_o__CIexp
_o__CIfmod
_o__CIlog
_o__CIpow
_o__CIsin
_o__CIsinh
_o__CIsqrt
_o__CItan
_o__CItanh
_o__close
_o__configure_narrow_argv
_o__crt_atexit
_o__errno
_o__execute_onexit_table
_o__filelengthi64
_o__fpclass
_o__get_osfhandle
_o__initialize_narrow_environment
_o__initialize_onexit_table
_o__invalid_parameter_noinfo
_o__lseeki64
_o__mbscmp
_o__mbstrlen
_o__memicmp
_o__open_osfhandle
_o__purecall
_o__read
_o__register_onexit_function
_o__seh_filter_dll
_o__strdup
_o__stricmp
_o__strnicmp
_o__strtoui64
_o__wcsdup
_o__wcsicmp
_o__wcsnicmp
_o__wfsopen
_o__wfullpath
_o__wgetenv
_o__wmakepath_s
_o__write
_o__wsopen_s
_o__wsplitpath_s
_o__wtoi
_o_atof
_o_atoi
_o_bsearch
_o_calloc
_o_ceil
_o_fclose
_o_floor
_o_fread
_o_free
_o_fseek
_o_ftell
_o_getenv
_o_isalnum
_o_isalpha
_o_isdigit
_o_isspace
_o_isxdigit
_o_malloc
_o_modf
_o_qsort
_o_setlocale
_o_strcat_s
_o_strcpy_s
_o_strncpy_s
_o_strtod
_o_strtoul
_o_terminate
_o_tolower
_o_toupper
_o_towlower
_o_wcscat_s
_o_wcscpy_s
_o_wcsncat_s
_o_wcsncpy_s
_o_wcstoul
_position
_positiont
_psize
_rcpfloat 
_sample
_sat not permitted on tex* instructions.
_sat not permitted with frc instruction.
_sat not permitted with setp instruction.
_sat not permitted with SINCOS instruction.
_SEH_prolog
_SEH_prolog4
_SEH_prolog4_GS
_tangent
_tessfactor
_texcoord
_time32
_uglobal
_ugroup
_uint 
_unknown
_volume
`.data
`0d0h0l0
`0D1S1d1
`2d2w4~4
`abc`
`OTHER
`PACKED
`Rs%a
`TEMP
`UUe?
{    
{ %d, %d, %d, %d }
{ %g, %g, %g, %g }
{ 9Ghu
{ j;W
{\;{T
{8u ;}
{Q;L$
|$(S;
|$,tBj
|$@F;w
|$@u&
|$\9<2
|$0;{
|$0;t$
|$0t<
|$4;{
|$D)D$D
|$LQW
|$LWV
|$p;D$ s
|$Tu,
|$x9|$p|
||||}}}}~~~~
||}}~~
|xy{wzvuyu
}*97|
}yXZ,
~ /uK
~ <tu
~ 0u"
~ 0uQ
~0$r5
~l+~h
~LC;_
+#INF
+*++++056++
+,,,,,,,,,,,,,,,,-----....///000111112223344556677889:;<
+,,-A../012.3/145&5216127689277/010/21:8/22.3/3/.11;0.10//:
+,-./
++++++
+++++++++
++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++
+++de
+020=0F0P0{0
+0F0i0
+A$+A
+B`VW
+C$QP
+HDQh
+j hh
+K PQ
+L$(j
+L$<3
+T$(+{8
< <$<(<,<
< <$<(<,<0<4<8<<<@<
< <$<(<,<0<4<8<<<@<D<\<
< <$<(<,<0<4<8<<<@<D<H<L<
< <$<(<,<0<4<8<<<@<D<H<L<P<T<X<\<
< <$<(<,<0<4<8<<<@<D<H<L<P<T<X<\<`<d<h<l<p<t<x<|<
< <$<(<,<0<4<8<<<@<D<H<L<P<T<X<\<`<d<h<l<t<|<
< <$<(<,<0<4<8<<<@<D<H<L<P<T<X<\<`<d<h<l<x<
< <$<(<,<0<4<8<<<@<D<H<P<T<X<\<`<d<h<l<p<t<x<|<
< <$<(<,<0<4<8<<<@<D<H<Y=x=
< <$<(<,<0<w?
< <$<0<4<8<D<H<L<X<`<l<t<
< <$<i=
< <(<4<<<H<P<\<d<p<x<
< <*<.<5<N<W<i<u<y<
< <,<0<4<@<D<H<T<X<\<h<l<p<|<
< <,<8<D<P<\<h<t<
< <'<9<@<
< <><F<\<m<
< <8<b<
< <8<P<h<
< <B<f<m<
< <Y>
< <Z<a<
< ={=
< =<=Z=m=
< =F=
< =L=x=
< >$>(>,>0>4>8>P>T>X>\>
< tB</t>
<!-- id=%d -->
<!<:<C<U<`<d<k<
<!<<<W<r<
<!<g<q<
<!=&=7=N=
<!=,=7=K=P=l=q=
<!=M=m=
<"</<=<E<K<O<
<"<><m<
<"<Q<r<
<"<x=
<"=7=Z=q=
<"=l=
<"=z=
<#</<?<N<
<#<:<A<j<x<
<#<{<
<#<<<E<T<^<b<i<
<#=G=c=
<#=T=
<$<,<8<@<t<|<
<$<,<8<D<L<T<d<l<t<
<$<,<9<@<H<O<W<_<p<u<}<
<$<D<d<
<$=(=,=
<$=(=,=0=4=
<$=>=l=
<$=U=
<%<@<[<v<
<%<7<I<[<m<
<%<G<\<s<|<
<%=3=>=^=
<%=p=
<%=P=u=
<%=X=
<%s return value>
<&<@<a<
<&<=<U<u<
<&<X<_<f<
<&=F=f=p=
<(<,<0<4<8<<<@<D<H<L<P<T<X<\<`<d<h<l<p<t<x<|<
<(<@<X<p<
<(<[<
<(<0<<<D<P<X<d<l<x<
<(<0<5<<<H<P<Y<`<m<x<
<(<4<@<L<X<d<p<|<
<(<e<j<q<v<
<(<h<
<(<K<
<(<N<\<
<)<-<3<L<U<h<t<x<
<)<3<?<r<|<
<)<D<_<z<
<)<X<e<
<)=H=L=P=T=X=\=`=d=h=l=p=t=x=|=
<)=Y=
<*<G<j<x<
<*<J<u<5=
<*=D=H=L=P=T=X=\=`=
<*=l=
<,<@<T<h<|<
<,<_<t<
<,<6<:<A<Z<c<r<|<
<,<9<
<,<A<V<k<
<,<S<i<
<,<X<
<,=0=4=8=
<,>>>I>r?
<.?z?
<.<C<X<m<
<.<K<
<.<L<j<
<.=a=
<.=J=
</<D<Y<n<
</=n=x>|>
</=O=b=
</font>
</pre>
<:=[=
<;<B<Y<i<
<;<E<O<k<
<;=:>?>J>
<?=F=n=
<@<}<
<@<9=
<@<T<
<@=D=H=L=P=T=l=p=t=x=|=
<\<y=
<\=`=d=h=l=p=t=
<\u);
<\uh;
<_t,3
<| dependent on I%u (B%u), A%u (B%u)
<+=Y=`=r=
<-<;<F<
<<<@<D<H<L<P<T<v<
<<<_<q<
<<<S<n<u<~<
<<=@=|=
<<=C=l?p?t?
<'<9<t<
<-<B<W<l<
<'<H<L<P<T<X<
<'<n<
<=<<<
<=<C<S<Z<n<
<==>>??@ABCDEFFFGFFFFFHHIIIIIJIIIIhKKKKLLLLMNOPQRS
<'=e=
<'=g=F>
<-=I=k=
<-=q=
<><b<
<><x<
<>=Z=
<0<`<
<0<E<Z<o<
<0<H<`<x<
<0<L<P<l<p<
<0<P<p<
<0=4=8=<=@=D=
<0=4=k>
<0=e=
<0x0|0
<1<F<[<p<
<1<j<
<1<R<
<1=U=
<2@2\8
<2<9<N<U<
<2<D<i<
<2<G<\<q<
<2<G<Q<a<o<
<2=<=
<3<A<G<S<
<3<H<]<r<
<3<N<
<3<P<i<}<
<3=X=
<4<:<V<\<s<z<
<4<`<
<4<8<<<@<D<H<
<4<8<<<@<D<H<L<P<T<X<\<`<d<h<l<p<t<x<|<
<4<8<L<P<
<4<F<i<{<
<4<X=b=s=
<4=H=Z=
<4=t=
<4=W=
<5<f<
<5<l<
<5<L<s<
<5<M<
<5<U<c<i<x<
<5<W<o<
<5=C=]=
<5=g=
<5=m=
<5=T=m=
<5>g>
<6<Q<}<
<6=v=
<7=Y=
<8<?<F<M<T<
<8<N<j<
<8<V<t<
<8=?=i=p=7>x>
<9<p<
<9<W<
<a<h<
<a=w=
<anonymous>
<B<O<
<B>d>
<basic>
<BCD>
<bit>
<body bgcolor="#000000">
<c<i<o<u<{<
<C<u<
<C=e=
<C=J=
<complex>
<compound>
<container>
<continued>
<count>
<currency>
<d<I=
<d=h=
<date>
<E<i<
<E=1>
<E=z=
<error - out of memory>
<error>*
<f<m<
<f<p<
<F<Y<{<
<float16>
<font color = "#
<font color = "#%s">
<G<c<
<G<o<
<G<u<
<G<Y<
<G=~=
<G=n=
<g>~>
<G>q>x>
<I={=7>e>w?
<internal error>
<internal error> unable to get variable name from PDB
<internal error> unable to get variable subfield offset from PDB
<internal error> unable to get variable type from PDB
<invalid constant table>
<invalid default value offset>
<invalid member offset>
<invalid type offset>
<k<]=d=%>
<K<Z<w<
<K=p=I>
<L<P<T<X<\<`<d<h<l<p<t<x<|<
<L=r=w=
<M<T<
<memory>
<method>
<nocast>
<none>
<NoType>
<o<3=
<o<z<
<o=?>
<o=~=
<out of memory>
<P<T<X<\<`<d<4=8=<=@=D=
<P<T<X<\<`<d<h<l<p<t<
<P=W=|=
<P=Y=w=
<parse error>
<pointer>
<pre>
<Q<r<
<r<p>
<S<[<s<{<
<S=]=
<st^<ttZh
<SVW3
<symobj>
<T<#=]=Q>
<T<\<
<T<_<
<t<x<
<T<X<\<`<d<h<l<p<
<T<X<\<`<d<h<l<p<t<x<|<
<T=e=
<tt,<st(h
<tt7h
<U>9?
<unknown buffer type>
<unknown class>
<unknown dimension>
<unknown HLSL built-in %u offset %u>
<unknown interpolation> 
<unknown qual> 
<unknown register type %u>
<unknown register type>
<unknown resource return type>
<unknown shader model>
<unknown type>
<unknown>
<unknown> 
<unnamed>
<unused>
<V=i=s=
<w=^>n>
<x=(>`>
<X=t=
= =$=
= =$=(=
= =$=(=,=
= =$=(=,=:=\=`=d=h=l=p=t=
= =$=(=,=0=4=8=<=@=D=H=L=P=T=X=\=`=d=h=l=p=t=x=|=
= =$=(=,=0=4=8=<=@=D=H=L=P=T=X=\=d=h=l=p=t=x=
= =$=(=,=0=4=8=<=@=D=H=P=T=X=\=`=d=h=l=p=t=x=|=
= =$=(=,=0=4=8>F>
= =$=(=|=
= =$=0=8=D=L=X=`=l=t=
= =$=h=
= =(=4=<=H=P=\=d=p=x=
= =(=4=<=p=x=
= =,=4=@=D=H=T=X=\=h=l=p=|=
= =,=8=D=P=\=h=t=
= =4=H=\=p=
= =8=P=h=
= >(>0><>D>x>
= >.>
= >?>F>e>
= >F>_>
= >O>
=!=1=A=Q=g=
=!>Z>
="=&=-=F=O=^=h=l=s=
="=)=
="=:=l=p=t=x=
="='=.=;=C=H=O=\=d=i=o=u=
="=H=X=
="=P=
=">1><>y>
=">g>
=">L>
=">v>
=#=*=4=B=J=[=l=}=
=#=*=5=<=H=O=[=b=n=u=
=#=/=8=D=M=Y=b=v=
=#=<=a=
=#=1=?=K=V=a=l=
=#=C=c=
=#=E=V=]=x=
=#=W=u=
=$=(=,=0=4=8=<=@=D=H=L=P=
=$=,=8=@=L=T=`=h=t=|=
=$=-=<=F=J=Q=j=s=
=$=0=@=L=X=d=p=|=
=$=0=<=H=T=`=l=x=
=$=1=m=
=$=D=d=
=$>(>,>0>4>8><>@>
=$>[>
=$>h>
=$>J>p>
=$>Y>_>z>
=%=,=h=o=
=%=:=?=S=j=
=%=3=<=H=T=
=%=L=
=%>?>
=%>6>D>M>T>p>
=%>E>_>
=&=0=4=;=T=]=l=r=v=}=
=&>`>5?U?
=&>3>
=&>3>J>W>y>
=&>L>
=(=,=
=(=@=X=p=
=(===R=g=|=
=(=-=A=
=(=2=6===V=_=n=x=|=
=(=F=d=
=(=P=x=
=(=S=
=(=x=
=(>,>0>4>8><>@>D>H>L>P>T>X>\>`>d>h>l>p>t>x>|>
=(>,>0>4>O>
=)=>=S=h=}=
=)=1===E=Q=Y=e=m=
=)=8=C={=
=)=b=
=)>b>
=*=?=T=i=~=
=*=1=9=>=H=P=Y=`=l=u=}=
=*=2=8=<=|=
=*=2=g=t=
=*=5=N=t=
=*>D>
=,=0=L=P=l=p=
=,=0=L=P=p=
=,=5=D=N=R=Y=r={=
=,=A=V=k=
=,>3>A>d>
=.=_=
=.=5=\=c=
=.=8=B=O=s=
=.=C=X=m=
=.>e>u>
=/=D=Y=n=
=/=g=
=/=J=e=
=/=X=
=;>P>e>s>y>
=?=c=v=
=?>E?
=@=O=Z=
=^=k=
=+=@=U=j=
=+=6=s=
=+=8=P=]=
=+=9=?=H=c=}=
=+>c>
=<=R=h=~=
=<=w=
=<=Z=x=
=<>@>D>H>L>P>T>X>\>`>d>h>l>
='=.=6===E=M=^=c=k=x=
=-=^=
===e=}=
===O=r=
='=5=
=-=B=W=l=
=-=X=
='>:>E>c>|>
=>?@=ABCDABCDAEFGHEIJKLIJKLIMNOP
=>?@A
=>?@ABC
=>?@ABCD
=>?@ABCDEFGHIJK
=->_>
=>=_=m={=
=>=v=
=->7?Z?
='>e>
='>O>
='>s>
='>v>
='>W>
=0?n?
=0=4=8=<=@=D=|=
=0=D=X=l=
=0=H=`=x=
=0=H=N=k=
=1>@>
=1><>P>[>z>
=1>E>S>
=1>u>
=2=\=
=2>!?u?
=2>8>
=2>t>
=3=:=^=
=3=;=S=[=s={=
=3=N=i=
=3>G>
=4=<=`=h=
=4>;>p>t>x>
=4>t>
=4>V>
=5?C?
=5===t=x=|=
=5>a>{>
=5>R>
=6=H=k=}=
=6=q=
=6>J>
=6>m>
=7=<=G=R=]=h=s=~=
=7=I=f=w=
=7=R=m=
=7>g>
=8=G=R=
=9=G=(>,>0>4>8><>@>D>H>L>P>T>X>\>`>d>h>
=9>m>v>}>
=a=5>
=A=H=f=m=
=A=T=[=
=C>J>
=C>N>j>x>
=CRPTt3=SHEXu
=d?x?
=D=d=t=
=D=h=r=
=d=p=
=D=Y=
=D>H>
=D>K>
=e?l?
=e=u=
=E>`>w>
=E>V>f>
=FALSE
=H={=
=H=5>X>e>
=H=L=
=H=O=
=H=Z=
=J?[?
=J>Q>
=K=a=
=K=h=m=&?G?Q?|?
=K>E?^?
=m>r>
=MINIu
=N=b=
=NB10t&=RSDSt
=NB10u(
=NOTMu
=O>o?v?
=P=T=X=\=`=d=h=l=p=t=x=|=
=p=x>
=P>k>
=P>T>X>\>`>d>h>
=Q=]>/?c?
=Q00000000_dopqrefmn>
=RDEFtJ
=SDTL
=STAT
=T>{>
=U>\>
=W={=
=w>~>
=W>k>
=X>\>`>d>Z?
=x>x?|?
=Y=c=
=Z=~=
> ?L?x?
> >$>
> >$>(>
> >$>(>,>0>4>8><>@>D>H>L>
> >$>(>,>0>4>8><>@>D>H>L>P>T>X>\>`>
> >$>(>,>0>4>8><>@>D>H>L>P>T>X>\>`>0?4?8?<?@?D?H?L?P?T?X?\?`?d?h?l?p?t?x?|?
> >$>(>,>0>4>8><>@>D>H>L>P>T>X>\>`>d>h>
> >$>(>,>0>4>8><>@>D>H>L>P>T>X>\>`>d>h>l>p>t>x>|>
> >$>(>,>0>4>8><>@>D>H>p>
> >$>(>,>0>4>8><>@>P>T>X>\>`>d>h>l>p>t>x>|>
> >$>+>D>M>\>f>j>q>
> >(>4>8><>H>P>\>d>p>x>
> >,>8>D>P>\>h>t>
> >8>P>h>
> >C>f>
> >C>V>y>
> >K>[>k>v>
>!?7?
>!>)>0>8>@>Q>V>^>k>r>z>
>!>0>:>>>E>^>g>v>
>!>N>U>
>">)>.>5>M>T>Y>`>
>">+>:>D>H>O>h>q>
>">=>X>s>
>">>>Z>v>
>">3>=>D>[>
>#>*>S>a>g>n>u>
>#>.>9>D>O>Z>e>p>{>
>#><>E>T>^>b>i>
>$?.?
>$?+?
>$?2?E?S?a?{?
>$?g?
>$?h?
>$>(>,>0>q>
>$>)>
>$>,>4>D>T>d>l>t>
>$>,>8>@>L>T>`>h>t>|>
>$>,>D>T>d>t>
>$>.>8>G>Q>[>j>t>~>
>$>^>e>
>$>0>8>D>L>X>`>l>t>
>$>6>
>$>8>L>`>t>
>$>9>N>c>x>
>$>D>d>
>%?x?
>%>:>O>d>y>
>%>5>C>L>U>d>
>%>C>Q>W>c>
>%>s>
>&?-?6?
>&?E?
>&>;>P>e>z>
>&>?> ?>?E?J?Q?X?_?f?m?t?{?
>&>+>1>7>B>J>O>V>b>j>o>v>
>&>A>\>w>
>(>,>|>
>(>@>X>p>
>(>\>g>
>(>=>R>g>|>
>(>0><>D>P>X>d>l>x>
>(>1>@>J>N>U>n>w>
>(>4>@>L>X>d>p>|>
>(>A>P>X>`>h>
>)>\>`>d>h>|>
>)>>>S>h>}>
>*>?>T>i>~>
>*>@>]>o>
>*>E>`>{>
>,?0?4?8?<?
>,?G?u?
>,>0>L>P>l>p>
>,>J>h>
>.>?>W>o>
>.>5>>>z>
>.>E?T?_?
>.>e>
>.>N>n>
>/?4?
>/>6>
>/>6>T?[?
>/>G>_>
>:???
>:?A?
>:>O>r>
>;>g>
>;>K>
>??M?b?g?
>??o?
>?@ABC
>?@ABCD
>?@ABCDEF
>?> ?
>?>l>
>?>Y>
>'?6?A?z?
>'?O?
>'?S?
>'?u?
>@?D?H?L?P?i?
>@>h>
>[?j?u?
>[>|>
>[>g>
>]?s?
>^>e>j>
>_^[]
>+?2?
>+?G?b?
>+>@>U>j>
>+>2>h>o>v>
>+>w>
><?_?
><>\><?y?
><>h>
><>z>
>=>j>
>>?g?
>'><>Q>f>{>
>'>1>8>=>G>O>X>_>k>s>|>
>'>3>
>->4>@>\>`>
>->G>
>'>y>
>0;1e1
>0>:>A>u>
>0>1~2~3
>0>H>`>x>
>0>L>P>p>
>2>9>
>2>O>t>
>3>;>S>[>s>{>
>3>]>
>4?t?
>4?x?
>4>:>W>o>u>
>4>R>v>
>5?h?
>5?H?O?V?q?
>5?j?
>5?u?
>5>_>
>5>g>
>6>T>r>
>7?^?l?x?
>7?L?
>7>)?R?
>7>q>
>7>R>u>
>8?{?
>8?g?
>9?[?b?i?p?
>9?o?
>9>^>
>9>m>
>9>W>
>A?h?}?
>A?n?
>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA?????????@@@@@@@@@@++=
>B?`?
>B>I>d>t>
>b>o>
>C?x?
>D?O?d?n?
>d>{>
>d>h>
>d>k>
>D>p>
>DXBC
>E?_?
>E?_?x?
>E?Y?m?
>E>\>
>E>h>
>E>k>y>
>E>L>h>l>p>t>x>
>E>n>
>F?a?
>G?`?
>G?u?
>H?]?r?
>h?v?
>H>c>
>h>l>
>I?^?
>I?o?
>i>;?
>J?\?
>J?Q?
>k>'?
>K>R>
>L?o?
>l>p>t>x>|>X?\?`?d?h?
>N?U?
>N>a>
>P?w?
>q?x?
>Q>u>
>R>d>
>R>j>
>T?r?
>t?x?
>TEXTum
>U?|?
>U?r?
>u>_?
>U>k>
>W>z>
>X>b>
>X>f>
0 0$0(0
0 0$0(0,0
0 0$0(0,000
0 0$0(0,000\0
0 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0l0
0 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0l0p0t0x0|0
0 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0y0
0 0$0(0,00040J0
0 0$0004080D0H0L0X0\0`0l0p0t0
0 0$0p1
0 0$0V0t0
0 0%0,080@0E0L0X0`0e0l0x0
0 0(00080@0H0P0X0`0h0p0x0
0 0,040@0H0T0\0h0p0|0
0 0,0e0l0u0
0 0+0
0 050J0_0t0
0 080P0h0
0 1$1(1,101I1
0 1$1(1I1
0 1h6
0 1J1
0!0<0W0r0
0!060K0`0u0
0!0G0w0
0!0K0
0!1<1[1
0!1'161<1R1Z1i1s1}1
0!1M1
0"0(0.040;0B0I0P0W0^0e0m0u0}0
0"0+020H0u0
0"070L0a0v0
0"0i0z0
0"0N0U0\0c0h0o0t0{0
0"0U0r0
0"1)1T1X1\1`1d1
0"1K1x1
0#0>0Y0t0
0#0-01080R0[0j0t0x0
0#080M0b0w0
0#0s0
0$0,080@0L0T0`0h0t0|0
0$0,0D0T0d0t0
0$0+0`0
0$000<0H0T0`0l0x0
0$0B0
0$0D0d0t0
0$0K0
0$1(1,10141
0$1v2@3
-0$2(2,2024282<2@2
0%0;0J0s0
0%0<0Y0j0
0%0-0>0C0K0X0_0g0n0v0~0
0%0a0t0{0
0%1B1
0%1B1g1
0%1F1b1
0%1H1V1g1{1
0%1K1Q1e1
0&020W0_0d0p0w0
0&0C0N0p0
0&0Q0\0|0
0&1M1
0(0,0004080<0@0D0H0L0P0T0
0(0?0V0m0
0(0@0X0p0
0(000<0D0P0X0d0l0x0
0(040@0L0X0d0p0|0
0(0P0x0
0(1,1
0)030:0?0J0R0W0^0k0s0x0
0)0A0u0
0)1L1
0)1V1
0*030:0U0
0*04080?0X0a0s0
0*080C0S0b0m0i1p2
0*080F0T0b0p0~0
0*0H0f0
0*141
0*1j1
0*1v122_2
0,0;0J0W0
0,0@0T0h0|0
0,0004080<0g0l0}0
0,0M0n0
0,1u3
0.070F0P0T0[0t0}0
'0.0R3Y3
0.1X1g1p1}1
0.2T3]3
0/0G0_0w0
0:0B0X0f0
0:1U1|1G2
0;0^0q0{0
0;H,uS
0?0I1j1
0@1D1H1L1P1T1X1\1
0@WVP
0[1j1u1
0\1`1\2v8
0^0m0x0(181J1U1d1h1l1|1
0+0}0
0+0F0a0|0
0+1A1N1Y1o1
0+1E1S1\1h1
0+2}4
0<1@1D1H1L1P1T1X1\1`1d1h1l1p1t1x1|1
0<1^1
0<1W2
0=1]1
0>1C1
0'0?0z0
0'0+020K0T0c0m0q0x0
-0000tT-
0004080T0X0
000B0e0w0
000H0`0x0
000L0P0l0p0
000S0d0
001\1
0014181<1
001r1
0024282P2T2X2O3
0-0C071R1
00ffff
0'0g0
0'0I0u0|0
0-0j0
0-0K0i0
0'0L0
0'0W0`0|0
0-1<1S3
010;0
0123456789abcdef
0123456789ABCDEF'
0'171X1h1
0-1e1
01E2W2i2
0'1U5x5
020B0k0s0
020G0\0q0
020l0
020Y0
021M1
021M1`1n1}1
021Z1
030;0S0[0s0{0
030a0
030H0]0r0
030W0
031K1
03D$,
040904B0
040I0^0s0
040R0p0
04181
041e1
041t1
04282
'050\0q0
050I0W0d0k0
050K0a0
050Z0
050Z0h0n0u0
060?0N0X0\0c0|0
060[0|0
060D0\0t0z0
060W0^0c0
060Z0
061e1v1
061p2
070<0C0J0Q0p0t0x0|0
070m0
070O0g0
071/2
090_0
09L$4
0A0\0
0a0o0u0
0a0r0}0
0A0U0f0w0
0A0X0
0C2S2
0D0w0
0D1~2
0d1'2
0d1h1l1p1t1x1|1
0e0\1m1J4O6e6
0E0K0Q0g0p0{0
0E0u0
0E0w0
0E0Z0i0}0
0E1R1
0E1w1
0F0K0
0G0y0
0H0Z0
0H1L1Z4
0H1p1
0h1u1
0h4l4p4t4x4
-0J0i0|0
0J1X1d1v1
0K0s0
0K4Z4e4y4
0l1'2
0l1p1
0L1P1
'0O0\0|0
0O1#2
0O1X1z1
0p1t1x1|1
0P1W1
0Ph(r
0Q0X0
0RQPV
0RVhP
0S0i0
0SVW3
0T0i0
0T0X0
0U0w0
0u1|1
0U1j1
0V0`0
0v0}0
0W0z0
0W1H2
0WEIGHTS
0x%016I64xUI64
0x%02x
0x%08x
0x%08x 
0x%08X: 
0X0s0w3
0X0v0
0X1g1r1
0Y1x1
1 / sqrt(x) -> rsq(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
1 / x -> rcp(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
1 1$1(1,1
1 1$1(1,10141<1@1H1L1
1 1$1(1,1014181<1@1D1H1L1P1T1X1\1`1d1h1l1p1t1x1|1
1 1$1:1Z1
1 1%1,181@1E1L1X1`1e1l1x1
1 1(141<1H1P1\1d1p1x1
1 1(181@1H1X1`1h1p1x1
1 1,141@1H1T1\1h1p1|1
1 1,181D1P1\1h1t1
1 151C1I1U1[1s1z1B2
1 181P1h1
1 1u1
1 2<2U2h2{2
1 2d2
1!1)111=1E1M1d1i1u1z1
1!1D1
1!1F1
1!1U1h1
1!1W1
1!292k2s2P3m3
1"1&1-1F1O1^1h1l1s1
1"1(131;1@1G1S1[1`1g1s1{1
1"1*1S1!242g2
1"1+121U1q1}1
1"1+1E1S1\1f1t1
1"1W1
1"1x1
1#1*1h1o1
1#1<1h1l1p1t1x1|1
1#1g1
1$1,141@1H1|1
1$101<1H1T1`1l1x1
1$10181D1L1X1`1l1t1
1$14181D1T1X1d1t1x1
1$141D1T1d1
1$151X1i1
1$1B1`1~1
1$1D1P1d1l1t1
1$2+2
1$222;2@2H2
1$242;2B2I2P2d2p2w2~2
1%1:1H1N1Z1`1l9\;c;
1%2e2
1%2E2|2
1%2Q2[2b2y2
1%2t2
1&1?1Y1^1{1
1&1<1R1q1
1&1-151<1D1L1]1b1j1w1~1
1&151?1C1J1c1l1{1
1(1,101<1@1D1P1T1X1d1h1l1x1
1(1@1X1p1
1(292Z2
1(2c2
1(2T2
1)1\1
1)121>1g1p1
1)1Y1t1
1)2@2\3
1)2[2
1)2L2
1*1.141M1V1e1o1s1z1
1*1F1c1n1
1,1;1U1
1,101
1,101P1l1p1
1,1F1P1j1
1,1X1
1,202
1,242<2H2h2t2
1,2m2r2
1.#IND
1.#INF
1.#QNAN
1.#SNAN
1.171F1P1T1[1u1~1
1.1A1
1.1C1X1m1
1.1e1
1.2m2
1/1=1H1
1/1D1Y1n1
1/1u1
1:1A1\1c1u1|1
1:1I1X1g1v1
1:1L1o1
1:243w3
1:4V4
1;1Y1w1
1@1D1H1)2
1@1D1H1i1
1@1h1
1@2f2
1@5d5
1\2`2
1]1|1
1]2i2
1_^[]
1`2d2h2l2p2t2x2|2
1|2T3
1}2E3
1+2^2
1+2g24383<3@3D3H3L3P3T3X3\3`3d3h3l3p3t3x3|3
1+2G2b2
1+2q2
1+2W2
1<2@2D2H2
1<2D2g2p2
1<2K2V2
1<2m2v2
1<3@3D3H3L3P3T3X3\3
1=1l1v1
1>2h2
10.0.19041.546
10.0.19041.546 (WinBuild.160101.0800)
101D1X1l1
101E1Z1o1
101G1Y1}1
101H1`1x1
102R2w2
10s0z0
111d1i1p1w1~1
111F1[1p1
111L1g1
111L1i1
111T1i1
1'1m1
1'1U1z1
1'2,5
1'2\3`3d3h3l3
121C1T1e1v1
121G1
121G1\1q1
121w1
122X2j2
1-2H2p2
1-2J2V2n2
1'2r2"333e3
1'2T3z3
1-2u2
1-2x2~2E3
131;1S1[1s1{1
131H1]1r1
131i1
132;2s2{2
14.00.23615.0
141;1
141;1D1v1}1
14191@1G1N1U1\1c1
141I1^1s1
14282<2@2D2
142t2
151C1W1z1
151V1w1
151X1`1
152F2n2
152J2f2
152v2
16 bit code
'161G1
161G1i1z1
162v2
1'6J7j7
171N1
171O1g1
181`1
181g1
181V1t1
182B2
182u2
182X2v2
191R1y1
191T1o1
191u1
192\2
19233u3
1A2g2
1B1i1
1B1y1
1B2<3
1B2w2|2
1C2e2
1c2l2x2|2
1D2^2
1D2H2L2P2
1D2N2
1d4i5s5z5
1darray
1E1b1
1E1x1
1E2r2
1F$8K
1f;2u
1f1m1
1G2~2&374\4
1G2p2
1G2t2
1G2Z3
1H1_1
1H1f1t1{1
1H1L1P1
1h1l1p1t1x1T2X2\2`2d2
1H1t1
1I1|1
1i1u1
1I2m2z2
1I2x2
1i5L6
1K2q2
1K3^3e395
1k3B4
1L152?2z2n3
1L1P1T1X182s2X3\3`3d3
1L3P3T3X3\3`3d3h3l3p3t3x3|3
1m2t2
1N2l2
1n2x2
1N2x2
1o2y2
1P2V2^2
1Q2f2q2
1q7x7
1R1`1w1'2D2_2w2
1U1s1}1
1U2c2
1V596
1W1|1
1W1z1
1W3x3
1WEIGHTS
1X2\2l2p2
2 2$2
2 2$2(2
2 2$2(2,2024282<2@2D2H2L2P2T2X2\2`2d2h2l2p2t2x2|2
2 2$2(2,20242L2
2 2$2(2,202g2)3
2 2$2(2<2@2D2H2L2>4M4d5s5~5
2 2$2<2@2D2H2L2P2e5
2 2%2,282@2E2L2[2c2h2o2{2
2 2(2/272?2P2U2]2j2q2y2
2 2(20282@2H2P2X2`2h2p2x2
2 2,242@2H2T2\2h2p2|2
2 2,282D2P2\2h2t2
2 2.3:4S4l4
2 2;2V2q2
2 2+2R2
2 2=2J2W2m2
2 202H2X2p2
2 2'232;2@2G2S2[2`2g2s2{2
2 242H2\2p2
2 282P2h2
2 282P2k2
2 2P2
2 3\3O;
2 3'3B3I3[3b3
2 383H3`3p3
2 3d3
2 3D3\3
2 3G3R3y3
2 3J3q3
2 3W3~3
2 3x3
2!2%2,2E2N2]2g2k2r2
2!2)212;2C2H2P2X2_2g2l2t2|2
2!2*212T2x2
2!2,2p2t2
2!202:2>2E2^2g2v2
2!272M2c2
2!2G2u2
2"2[2x2
2"2+222H2u2
2"2+2E2S2\2f2t2
2"252H2l2q2
2"2g2
2#2@2E2a2g2l2w2
2#20242
2#2'2.2G2P2_2i2m2t2
2#2G2
2#2N2Y2i2s2
2#2X2r2
2#383
2$2(2,282<2@2L2T2`2h2t2|2
2$2,242D2L2T2d2l2t2
2$2?2Z2u2
2$20282D2L2X2`2l2p2t2
2$24282D2T2X2d2t2x2
2$242D2T2d2t2
2$272I2
2$3(3
2$3E3]3
2$3K3
2$3S3
2%2/2U2i2}2
2%2]2
2%202
2%3@3\3
2%3E3g3
2&303v3
2&3f3v3
2(2,2024282<2@2D2H2L2P2T2X2\2`2d2h2l2p2t2x2|2
2(2/242H2\2
2(2@2X2p2
2(232:2u2
2(232>2_2v2
2(242@2L2X2d2p2|2
2(272A2E2L2e2n2}2
2(292\2m2
2(2D2f275J5`5v5
2(2F2d2
2(2P2x2
2(3o3+:
2)2B2I2
2)2K2q2
2*2?2T2i2~2
2*2H2
2*2I2
2*3C3
2*4w4
2,202P2l2p2
2,2A2V2k2
2,2b2
2,2G2b2}2
2,393^3
2,3o3
2.2C2X2m2
2.2N2g2u2
2.3L3
2.3n3x3
2.4K4l4
2/292u2
2/2D2Y2n2
2/2E2[2i2~2
2/3D3x3
2:2{2
2:2A2H2x2
2:3Y3x3
2:4a4z4
2;3v3
2;4_5f5{5
2?2P2s2
2?2S2x2|2
2?4F4k4r4
2@2g3
2@3@1@0@
2@3_3
2@3H3
2[3l3
2\3|3
2^3i3t3
2+2@2U2j2
2+2I2g2
2+3j3
2<2b2
2<2I4N4
2<3B4
2<3S3
2=2D2M2
2=2M2
2>3\3
2>3H3|3
202D2J3O3q3
202E2Z2o2
202H2`2x2
202U2
203=3J3W3d3k3
2034383<3@3D3H3L3P3T3
2034383<3@3D3H3L3P3T3X3\3`3d3h3
20373@3
203t3
20A0Q0
20D0x0
212<2@2D2H2L2P2T2X2\2`2d2h2
212=2\2
212a2
212p2v3
2'2?2W2o2
22292Q2`2d2h2l2p2t2x2|2
223t3
2-2B2W2l2
2-2E2
2'2P2
2'3:3D3N3Y3s3
2'3~3
232D2P2a2l2
232T2X2\2`2d2h2
233i3
233s3
23A3g6v6
2-3P3`3
242`2
242I2l2
243h3
243Q3
252>2M2W2[2b2{2
252e2
252R2
252V2]2q2
253F3f3
263g3
263j3
272@2I2P2{2
272|2
273k3
273z3x4
274n4
282d2l2
283r3
284W4
293(4
2A2t2
2a4/<N<k<
2b2i2
2B2I2f2m2
2B2s2
2B3}3
2d/%mwe)
2D2H2L2P2T2
2D2H2L2P2T2X2u2
2D2l2
2d3n3}3
2darray
2e214%575N5_5
2E2a2s2z2
2E2g2s2
2E2S2k2
2E3`3
2F2y2
2F3j3p3y3
2f3m3
2G3n3
2G3N4
2G8$ 
2I2P2f2
2I2v2
2i3`4%5,5S5Z5x5
2i3A5n7M8
2j<%=G=y=
2J3t3
2K2|2
2K2r2
2K3Z3e3A4
2l2p2t2x2|2
2l3a4
2m2x2
2M3T3
2N2c2x2
2N2d2
2N3.4
2n6u6
2O2m2
2P2Z2
2P3T3
2P3T3X3\3`3d3h3l3p3%4<4
2Q3j3o3
2Q3p3
2R3m3
2S2b2
2t2y2~2
2t5x5
2U<w<
2U2|2
2U2h2
2U5s5
2v4$5(5?<
2W2g2u2
2W2t2
2W3i3R4d4
2WEIGHTS
2X2\2
2X3\3`3
2X3h3d4
2x4|4
2Z2}2
3 3$3
3 3$3(3,3
3 3$3(3,3\3`3d3h3l3p3
3 3$3(3,3034383<3@3D3H3L3
3 3$3(3,3034383<3@3D3H3L3P3T3X3\3`3d3h3l3p3
3 3$3(3,3034383<3@3D3H3L3P3T3X3\3`3d3h3l3p3t3x3|3
3 3$3(3@3D3H3L3P3T3X3
3 3$3(34383<3H3L3P3\3`3d3p3t3x3
3 3$3*3C3L3[3e3i3p3
3 3$393l3w3
3 3%3,3<3A3F3L3V3^3c3j3w3
3 3(30383@3H3P3X3`3p3x3
3 3/393=3D3]3f3u3
3 34383<3P3T3X3l3p3t3
3 383P3h3
3 3A3V3
3 3Z4a4
3 4*4
3!3)3T3X3\3`3d3h3l3p3
3!373>3
3!4(4]4d4
3!4(4S4s5z5
3!4B4
3"3*323C3H3P3]3d3l3s3{3
3"3.32383Q3Z3i3s3w3~3
3"3?3M3V3u3
3"3+323`3g3n3
3"313;3?3F3`3i3x3
3"3'3.3;3D3K3P3Z3b3g3n3x3
3"3H3L3P3T3X3\3`5
3#3*3e3
3#3.3J3U3e3o3
3#373Y3p3
3#3J3p3
3$3,343D3L3T3d3l3t3
3$303<3H3T3`3l3x3
3$30383D3L3X3\3`3l3t3
3$343D3T3d3t3
3$383L3`3t3
3$3D3L3d3t3
3$3D3P3p3
3$4G4\4
3$5f5u5
3%3;3Q3g3}3
3%313
3%3-33373{3
3%333A3J3Q3t3
3%3g3
3%3t4
3%4+4
3%4B4
3&3;3P3e3z3
3&323>3u3
3&3-3>3G3Q3U3\3`3
3&3-3E3q3{3
3&3I3
3&3j3
3&444l4
3&464=4D4
3(3@3X3p3
3(3=3R3g3|3
3(303:3B3M3S3Y3e3o3z3
3(343@3L3X3d3p3|3
3(3S3{3
3)3,4
3)3=3Q3e3y3
3)3>3S3h3}3
3)373L375k5
3)4<4
3)474C4y4
3)4d4
3)4X4
3*3?3T3i3~3
3*353F3d3
3*3U3w3
3*3Y3y3
3*4A4U4}4
3*4H4d4h4
3*4W4
3*747R7j7t7
3,3=3`3q3
3,3A3V3k3
3,3M3e3
3,4044484<4@4D4H4L4P4T4g4
3,4044484<4P4T4X4\4`4
3.3I3d3
3.454q4|4
3/3G3_3w3
3/464?4F4P4
3:3U3p3
3:4]4
3:4|4
3;3@3J3T3^3t3
3;3\3z3
3;4B4
3;4x4
3?3F3O3w3
3@3c3
3@3h3
3@3l3
3\$X#\$
3\3g3
3`3d3
3`3j3
3+3@3U3j3
3+3]3q3
3+3_3y3
3+353g3
3+4y4
3<3^:i:
3<3h3
3<4@4D4H4L4(5,5054585
3=3[3|3
3=3\3
3=4i4
3>3I3l3}3
3>6E6Q6U6
303\3
303c3
303H3`3x3
303L3P3l3p3
303o3
303S3
304<4H4T4`4l4x4
304>4h4z4
3044484<4@4H4L4P4T4X4\4`4d4h4l4p4t4x4|4
304-5M5x5
304V4
313A3g3
313E3Y3m3
323?3X3
323`3{3
323=3h3
323H3^3t3
323k3u3
323M3h3
323n3
32595L5P5:9W9
32-bit floating-point operations flush denorm float literals to zero, %g is losing precision (this warning will only be shown once per compile)
3'3<3Q3f3{3
3'3>3`3d3h3l3p3t3x3|3
333\3`3d3h3l354<4
33333
333N3u3
334n4
3-3G3Y3
3-3W3
343=3L3V3Z3a3z3
34383<3@3D3H3L3P3T3X3\3
34383<3@3D3p3t3x3|3
343J3W3l3
344o4
3456789:;
3'494d4
3-4B4w4
3'4d4
353h3
353J3w3
353k3
353X3
353z3
354<4
354=4W4_4
354G4X4c4j4
354t4
363T3r3
373@3O3Y3]3d3}3
374g4
374k4
374p4
374v4
374X4o4
383e3
393W3u3
3BTRP
3C4J4
3c4j4v4}4
3c4W5
3c7r7
3CTSP
3D$$3L$
3D$,3
3D3g3
3e6t6{6
3f3m3
3F3x3
3f3x3
3F4e4
3FTVP
3G3y3
3G4d4
3I3]4l4
3I3O3l3r3
3j@Pj
3J4_4
3j4u4
3j6y6|9
3K(!G$#O 
3K3Z3
3KTPSQ
3KTRSQP
3L354X4
3l4p4
3m3w3
3M4W4
3N3S3Z3a3h3o3
3O3j3
3o3v3
3P3T3
3P4b4r4|4
3Q4X4e4
3Q5b5e6
3r4y4A5H5
3S3u3
3T3t3
3T4t4
3t4v5%6
3t4x4|4
3U3c3l3x3
3U3f3
3U3g3x3
3U3j3
3w3'4.4c4q4
3W4f4
3WEIGHTS
4 4$4(4,4<4
4 4$4(4,4044484<4
4 4$4(4,4044484<4@4D44585<5@5D5H5L5P5T5X5H6L6P6T6X6\6`6X7j7
4 4$4(4,4044484<4@4D4H4
4 4$4(4,4044484<4@4D4H4L4P4T4X4\4`4
4 4$4(4,4044484<4@4D4H4L4P4T4X4\4`4d4h4l4p4t4x4|4
4 4$4(4,404H4L4P4
4 4%4,484@4E4L4X4`4e4l4v4~4
4 4&42484
4 4(40484H4P4X4`4h4p4x4
4 4(444<4H4P4\4d4p4x4
4 4,484D4P4\4h4t4
4 4.464<4@4
4 484P4h4
4 4E4U4`4
4 4o4
4 4p4t4x4
4 5(545<5H5P5\5d5p5x5
4 5H5p5
4 5L5x5
4 component with no swizzle expected for operand #%d of opcode #%d (counts are 1-based). 
4!4(4M4S4Z4
4!4<4W4r4
4"4?4M4V4u4
4"434D4U4f4w4
4"474L4a4v4
4"4G4
4"4S4
4"506
4"5C5
4"5D5f5
4"5t5
4#4)4/454j5`6
4#4*4G4Z4
4#4,4;4E4I4P4i4r4
4#4;4[4
4#424F4u4
4#484M4b4w4
4#4Q4
4#5~5
4#5-5
4#5e5
4$4(4,484<4@4L4P4T4`4h4t4|4
4$4(4<4@4T4X4l4p4
4$4)404=4E4J4Q4a4f4k4q4{4
4$4,4=4B4J4W4^4f4m4u4}4
4$4,444D4L4T4d4l4t4
4$4:4P4f4|4
4$4|4
4$404<4H4T4`4l4x4
4$444D4T4d4
4$444D4T4d4t4
4$494N4c4x4
4$4d4
4$4p4z4
4$4W4
4$5(5,5054585<5@5D5H5L5P5T5X5
4$5@6
4$5+5
4$5d5
4$5O5l5s5
4$5P5X5|5
4%4:4O4d4y4
4%4@4^4|4
4%4+41474=4J4P4V4\4b4h4n4t4z4
4%4<4Q4a4
4%4<4u4
4%464G4X4i4z4
4%4p4
4%5@5\5
4%5c5
4%5f5
4%5R5w5
4%7B7
4&4;4P4e4z4
4&4D4b4
4&505m5
4&5-5A5
4(4,434L4U4d4n4r4y4
4(4@4X4p4
4(4<4P4d4x4
4(4=4R4g4|4
4(44484<4@4D4H4L4P4T4X4\4`4d4h4l4p4t4x4|4
4(484P4`4x4
4(5u5
4)4/4?4S4d4h4l4p4t4x4|4
4)494I4Y4i4y4
4)4G4e4
4)5]5
4)585
4)5C5Y5^5o5
4)5W5
4)5X5
4*4`4g4[5i5
4*4g9
4*4i4
4*4l4
4*5G5Z5|5
4,4;4F4|4
4,4~4
4,404L4P4p4
4,4L4x4
4,4W4z4
4,5g5
4,5Q5~5
4,5W5^5e5l5s5
4.4<4H4g4W5~5
4.585B5L5X5b5l5v5
4.596
4.6_6
4/4?4M4X4
4/4G4_4{4*5>5a5
4/4L4S4k4
4/4Q4o4
4/5D5I5Z5r5
4:4f4
4?4b4
4?4W5
4?5I5
4@4D4H4L4P4T4e4
4@5J5
4[9e9
4]5e5
4^5y5
4`4]5@6o6v6
4`5v5
4+4[4
4+525`6g6#7*7L7P7T7X7\7`7d7h7l7p7t7x7|7
4+5R5{5
4+5s5{5
4<4@4D4H4L4x4|4
4<4A4H4O4V4]4d4k4r4y4
4<4h4
4<4N4q4
4<588
4<5W5w5
4=4K4U4
4044484L4P4T4h4l4p4
40494H4R4V4]4v4
404A4d4w4
404H4`4x4
404H4L4P4T4X4\4`4d4h4l4p4t4x4|4
404i4p4
404M4w4
404X4
4054585<5@5
405w5
406A6o6
4080<0@0D0H0L0
414=4X4w4
414L4S4p4
415j5
415m5
424;4J4T4X4_4y4
42494
424G4N4T4f4p4
434=4D4e4
43484C4a4x4
434g4
435g5
435G5
435P5.6r6
4'4%5J5
4'4<4Q4f4{4
4'42464<4U4^4m4w4{4
44444444
4444444444
44444444444444444444 4!4"4###$#####
44494J4b4x4}4
444A5T5z5U6h6
444c4
445;5
4-474;4B4[4d4s4}4
4-4C4Y4o4
4-4D4l4
4'4F5T5`5f5m5u5
4-4H4c4~4
4'4L4
4'5.5g5n5
4'5\5v5
4'525\5
454[4
454a4
454X4
45596f6
455l5
455x5|5
4560*+;<E
456789:;
4'5M5}5
4'5P5|5
4'5P5m5
464_4
464S5y5
474a4
474A4H4_4f4|4
474O4g4
475>5E5L5S5\5n5
484@4Q4
484i4
484s4
484U4d4r4{4
484V4s4
494_4g4k5
4A5H5
4a6K8R8
4B5Q5
4b5w5
4BDQRSC6
4C4{4
4C4l4v4
4D4p4
4D4V4v4{4
4D9H9L9P9T9X9
4e4e5
4E5i5
4E5V5~5
4E6h6
4f5p5
4F5W5
4G4~4%5
4G4N4U4\4c4
4G5d5
4G5i5
4g5y5
4G7}79;~;
4H4]4
4h4l4
4H4M4^4v4
4H4t4
4H4t4X6\6`6d6h6l6p6t6x6|6
4H5^5
4h5l5 6$6<6@6X6\6
4H5L5P5T5X5
4I5S5
4J5L6z7
4j5q5
4k5z5
4l4p4t4x4|4
4L4W4
4L5P5T5X5\5`5
4l5p5t5x5|5
4l6)7
4L8.9d9
4m6t6
4N6Y8
4o6w6
4P4Z4
4P5d5
4p5t5x5|5
4p5w506J6n9u9
4Q5e5<6P6
4Q5x5
4q5z5
4q7x7
4R4:5!6G6W6e6
4R5{5
4r5w5
4s5h9l9p9t9
4SV_VertexID
4SVW3
4T9\9
4V4f4
4Y5}5
4z526
4Z6 7
5 5$5(5,5054585<5@5D5H5L5P5T5X5\5`5d5h5
5 5$5(5,5054585<5@5D5H5L5P5T5X5\5`5d5h5l5
5 5$5(5,5054585<5@5D5H5L5P5T5X5\5`5d5h5l5p5
5 5$5(5,5054585<5@5D5H5L5P5T5X5\5`5d5h5l5p5t5
5 5$5(5,5054585<5@5D5H5L5P5T5X5\5`5d5h5l5p5t5x5|5
5 5$5(5,5l5p5t5x5|5
5 5$5(5T5X5\5`5d5
5 5$5(5X5\5`5d5h5l5p5t5x5|5
5 5$5<5@5D5H5
5 5(5,5054585<5@5D5H5L5P5T5X5\5`5d5l5
5 5,585D5P5\5h5t5
5 5;5V5q5
5 555J5_5t5
5 585P5h5
5 5x5
5 6$6(6,6064686<6@6D6H6L6P6T6X6\6,70747
5 6)6w6
5 6=6^6
5 6'6q6}6
5 6D6
5 6L6x6
5!565K5`5u5
5!5a5g5
5!606J6Y6
5!6e6G7
5"5,54595@5J5R5W5^5h5p5u5|5
5"5;5D5S5]5a5h5
5"5?5M5V5u5
5"5+5T5t5
5"575L5a5v5
5"595R5[5b5h5o5
5"5g6
5"6/6
5"676
5"6G6e6
5"6G6y6
5"6O6
5"6U6\6
5"6w6
5#:2:u:
5#5.5E5\5q5
5#5;5
5#5+50575D5J5S5Z5e5m5r5y5
5#505I5w5
5#585M5b5w5
5#5E5Y5`5g5
5#5g5
5#6@6s6
5$5(5,5054585I6
5$5,545<5P5h5
5$5,585@5L5T5`5h5t5|5
5$545D5L5T5d5l5t5
5$545D5T5d5t5
5$575X5m5
5$595N5c5x5
5$5b5
5$6(6
5$6d6
5$6E6i6
5$6W6i6
5%5<5u5
5%6,6E6J6m6
5%6=6\6
5%666^6
5%6J6
5%6q6{6
5%6s6
5&5?5Y5
5&6@6u8
5&6-6?6
5&686H6R6
5(5;5\5m5t5
5(5@5P5h5x5
5(5@5X5p5
5(505<5D5P5X5d5l5x5
5(50585@5H5P5`5h5x5
5(545@5L5X5d5p5|5
5(5R5y5
5(6,6064686
5(6,606Z6
5(6T6
5)535=5C5M5W5a5k5u5
5)5R5
5)6o6
5*5G5p5t5x5|5
5*5Y5
5*6x6
5,5@5T5h5|5
5,5054585<5@5D5H5L5P556
5,505L5P5l5p5
5,53556H6Y6e6l6r6y6
5,5B5X5n5
5,5q5
5,676G6x6
5.535D5\5r5w5
5.6I7Z7h7
5.6w7
5/585>5c5
5/5J5e5
5/5P5
5/5u7
5/6_6
5:5u5
5:6q6
5;6w6
5@5[5w5
5@5J5T5
5@6V6
5\5c5h5q5z5
5\6}6
5^5m5y5
5_7y7
5{5Y6
5+52595Q5w5|5
5+6=6S6
5<6N6
5=6D6,8
5>5]5k5u5
5>5_5j5
5>5e5
5>6m6}6e7z7
5>6r6
50555=5J5Q5Y5`5h5p5
50595L5X5\5c5|5
505e5
505H5`5x5
505N5l5
505S5b5*6
506:6
50646
50676c6m6s6
506M6t6
506Z6
50777
50E0T0^0
50J0V0b0n0#1*1P2
51565J5T5Z5q5
51686]6d6
516l6q6
525@5F5R5X5
535]5
535a5v5B6b6l6
535H5]5r5
545=5`5d5h5l5p5
54585d5h5
545I5^5s5
545q5
545Q5n5
545R5p5
545V5e6
546_6|6
5'5?5W5o5
5'5<5_5t5
5'505?5I5M5T5m5v5
555K5a5w5
555R5W5h5
555X5
5'565@5D5K5d5m5|5
56:E:P:
565=5Q5
565I5l5}5
565J5z5
566F6f6
566i6
56789
56789:
56789:;
56789:;<
567j7
5'6W6m6
5'6Y6n6
575L5Q5b5l5
575U5s5
576>6v6
5'767>7G7D8H8L8P8+9]9p;t;x;|;
576g6
5A5]5r5T9[99:
5a5w5
5B5S5
5B5S5v5
5B6P6
5B6p6
5C5b5
5c6):t:{:
5c6i6o6u6{6
5C6O6|6
5c6r6}6
5d5h5l5p5t5x5|5
5D5p5
5D5w5
5d667G7
5D6h6
5d8E:\:m:
5E5T5_5
5E6_6
5E6x6
5F5V5v5
5f6u6
5G5~5
5G5P5c5o5s5z5
5G5Z5u5
5h6r6
5H8u8
5I5X5c5
5ineI
5J5z5
5J6y6'7.7W8
5K6[6L8
5l:2;9;^;e;
5L5n5
5L5V5
5L6V6
5L7f8m8
5M6T6Y6
5M6W6i6s6
5N5l5
5N6]6k6
5ntel
5O5d5r5y5
5P:T:X:\:`:(;,;
5P6b6y6
5Q5\5p5{5
5q8S9
5S5^5d5o5
5S6~6
5T64787=;L;
5U9|:
5W6{6
5X6\6
5X6_6%7S7
6 6$6(6,6
6 6$6(6,6064686<6@6D6H6L6P6l6
6 6$6(6,6064686<6@6D6H6L6P6T6
6 6$6(6,6064686<6@6D6H6L6P6T6X6\6`6d6h6l6p6t6x6|6
6 6(60686@6H6P6`6x6
6 6*6.656O6X6g6q6u6|6
6 6,646@6H6T6\6h6p6|6
6 6,686D6P6\6h6t6
6 6<6@6\6`6|6
6 6>6\6z6
6 656J6_6t6
6 686|6
6 686P6h6
6 6h6
6 6y6
6 7*7
6 7B7d7
6 7G8
6!6(6>6u6
6!6>6q6
6!6-646T6u6
6!7`7k7
6!7d7G8
6!7E7l7~7
6!808|;
6"6?6M6V6u6
6"6=6X6s6
6"6o6
6"7E7o7
6#6(606=6D6L6S6[6c6t6y6
6#6,656F6L6
6#6.666;6B6N6V6[6a6g6r6z6
6#7;7S7
6#8*8
6$6,646D6L6T6d6l6t6
6$6,686@6L6T6`6h6t6|6
6$6/6f6
6$606<6H6T6`6l6x6
6$626>6`6
6$646D6T6d6t6
6$6-6?6J6N6T6m6v6
6$6B6`6~6
6$6G6X6{6
6%:E:
6%6/636:6S6\6k6u6y6
6%6E6^6
6%6H6u6
6%7,7R7Y7w7~7
6%7<7w7
6%7B7J90:c:
6&6.676>6M6U6Z6a6m6u6z6
6&6?6H6Z6f6j6p6
6&6-6K6R6v6}6h8l8p8t8x8|8
6&767V7
6&7974;
6(6,606<6D6P6X6d6h6l6x6
6(6?6z6
6(6@6X6p6
6(60686H6P6X6`6p6x6
6(646@6L6X6d6p6|6
6(7c7
6(7O7
6(7T7
6)656B6I6O6a6x6
6)686<6@6D6H6L6P6T6X6\6i7p7
6)6D6
6)6J6l6
6)7d7|7
6)7j7
6*646r6
6*7D8K8p8w8
6*7L7~7
6*7P7h7y7
6*7X7
6,6:6X6k6
6,606
6,606L6P6p6
6,7g7
6,7o7~7
6,7p7
6,7U7
6,808
6.686?6K6b6{6
6.6I6d6
6.7_7
6.757<7J7n7
6/666L6S6u6
6/6D6Y6n6
6/6G6_6w6
6/6Y6
6/7o7
6:6G6
6:7J7o7
6';Y;
6?6T6w6
6@6j6
6@6K6`6
6@7L7W7b7m7
6@8;:J:\<
6@8J8
6[7a7u7
6[7g7
6\6]8
6^6.7
6_7r7
6`7d7h7l7p7t7x7|7
6+666
6<6n6t6
6<7m7v7
6=7v7
6>6Z6
6>7x7W9
606@6X6h6
606C6
606D6X6l6
606E6Z6o6
606F6e6q6
606H6`6x6
606S6
607\7
607e8}8
607H7s7
60D0K0h0
60E0P0u2
616?6T6Y6m6
616?6V6[6r6
616^6e6v6
616=6
616F6[6p6
617;7
617q7
617x7|7
626[6y6
626G6\6q6
626T6v6
636}6
636>6`6s6
636H6]6r6
637S7
637u7
64 UAV slots
646 7~7
646E6b6
646I6^6s6
647w7
656:6K6c6z6
656<6H6
656e6j6
656s6
657V7p8
6'6.656B6V6
6'6@6G6
6'6=6S6i6
6'616;6E6K6U6_6i6s6}6
6'656=6C6G6
666?6N6X6\6c6|6
666^6e6(7,707
667n7
667w7
6'6E6c6
6'6M6
6-6p6w6
6-7"9)919
6-7@7
6'7[7
6'717
676^6}6
676U6
677L7S7`7
6789:;<=
6'7g7
6-7g7
6-7W7
686`6
686U6c6q6z6
696F6
697I7i7
698d8
698z8
6A6|6
6A6g6
6a6g6m6s6
6a6k6
6A6U6x6
6A7T7]7h7
6A7u9
6D6)7
6d6h6l6p6t6x6|6
6D6R6i6
6d7n7|7
6E6n6
6E6p6
6E7d7h7l7p7
6G6^6
6G6p6
6G7o7
6g8+9
6h7l7
6H7R7q7
6i=b>
6I6V6q6
6I7P7
6J7k7
6J7Q7
6l<s<!>0>;>T>X>
6L7|7
6l7p7
6L7P7
6l8p8t8x8
6N:U:
6O6c6
6P6W6
6S7]7
6T7^7i7{7
6X8\8`8d8h8l8p8t8x8N9S9Y9_9e9k9q9w9}9
6x9|9
7 7$7(7
7 7$7(7,7074787<7@7D7\7`7d7h7l7
7 7$7(7,7074787<7@7D7H7L7P7T7X7\7`7d7h7l7p7t7x7|7
7 7$7(7,70747L7P7T7l7p7t7x7
7 7$7074787<7
7 7(70787@7P7X7`7h7p7x7
7 7)707<7D7M7T7`7h7q7x7
7 7*7.757N7W7f7p7t7{7
7 7,747@7H7T7\7h7p7|7
7 7,787D7P7\7h7t7
7 7@7
7 7@7`7|7
7 7+7Z7o7
7 727>7B7H7a7j7}7
7 747H7\7p7
7 757O7d7x7
7 787
7 787P7h7
7 7i7
7 7s7
7 7T7h7|7
7 8?8
7 8@8\8
7 8E8T8b8n8
7 8W8w:
7 8x8
7!7<7W7r7
7!7-747M7u7
7!7-757:7A7M7U7Z7a7m7u7z7
7!777
7!787X7s7
7!8?8J8a8t8
7"7*777>7F7M7U7]7n7s7{7
7"777g7
7"787e7u7
7"7J7h7
7"7N7
7#7.7P7c7
7#757f7
7#8~8
7#8W8
7$7(7<7@7T7X7p7
7$7,747D7L7T7d7l7t7
7$7.7
7$7=7F7U7_7c7j7
7$707<7H7T7`7l7x7
7$70787D7L7X7`7l7t7
7$7D7d7
7$7v7
7$7w7
7$8q8
7$8Y8
7%7,7
7%7.7=7G7K7R7k7t7
7%7/797C7M7S7]7g7q7{7
7%7=7
7%737>7
7%7d7r7{7
7%7G7\7s7|7
7%8C8]8
7%8X8
7%8X8z8
7&717
7&7-757@7
7&8F8
7&8I8q8
7(7.7M7S7r7x7
7(7@7`7
7(7@7X7p7
7(7<7P7d7x7
7(707<7D7P7X7d7l7x7
7(747@7L7X7d7p7|7
7(787F7a7t7
7(7K7\7
7(8X8
7)717D7Q7X7i7q7
7)7A7O7g7u7
7)7A7p7
7)7S7
7)8]8d8
7)8<8
7)898Y8
7)8M8y8
7*7@7V7l7
7,?0?4?8?<?@?D?H?L?P?T?X?\?`?d?h?l?p?t?x?
7,7074787<7@7D7H7L7P7T7X7\7`7d7h7l7p7t7x7|7
7,777
7,7A7V7k7
7,7G7b7}7
7,7U7%8R8h8
7,7U7l7
7,8084888<8@8
7,8F8w8
7.7C7X7m7
7.7L7j7
7.7S7j7
7.8l8
7.8m8z8
7/<T<h<
7/7D7Y7n7
7/8e8
7/8h8
7:8~8
7:8m8
7:8y8
7;7_7
7;7N7[7z7
7;8I9
7?8D8k8r8
7@7e7t7
7[7x7
7\8 9f9N:
7]8x8
7_8E9_9
7`7j7
7`8d8
7+7@7U7j7
7+7e7
7+7U7
7+8\8
7+8_8
7+8a8
7+8L8h8G9
7<7@7
7<8@8P8T8
7<8C8h8o8
7=7C7N7j7y7
7=7M7k7v7
7>8E8J8Y8h8w8
70#1G1
707E7Z7o7
707G7
707H7`7x7
707K7f7
707L7P7p7
707N7l7
707X7p7
707y788<8@8D8H8&9/9
70878
708g8
71777A7G7R7b7q7|7
717D7^7c7t7
717d7y7
717F7
717F7[7p7
717u7
7181989
718Y8
738W8
74787<7@7D7H7
747c7
747f7
747q7
747V7~7
747V7f7
747W7l7
747X7y7
75;i;p;
757D7K7`7w7
757S7q7
758t8
767;7L7c7~7
768U8s8
77:>:
777>7E7q7
7-777;7B7[7d7v7
777O7g7
778J8s8
7-7B7W7l7
7-7D7l7
787m7
788Y8h8s8
7-8B9
7-8n8'9a9
797X7
798D8w8
798O8
7A7a7q7
7A7O7
7A7V8
7a8v8
7a9l9j:
7B7l7s7x7
7B7u7
7b9i9
7c7\8
7C8]8
7d7h7l7p7
7D8N8
7d8z8
7E8`8d8h8l8y8$919@9O9^9
7E849
7E8U8~8
7E8V8t8
7f:w:U<j<o>v>
7f8\9
7F8`8n8
7g9n9^>e>
7I7_7
7J7e7
7J7g7
7J8T8g8
7J8y8
7K7W7u7
7K8}8
7k8y8
7L:X;
7L7Y7~7
7l8:9
7m7r7
7M7u7
7N7]7h7{7
7p869
7P8b8y8
7Q7^7z7
7Q8o8
7S8\8d8
7s8}8
7T:X:?;
7T7k7
7T8s8W9y9
7U7|7
7U7u7
7U8r8
7v:}:
7V8n8
7W8x8J9
7x7w8
7xicuU
7Y7g7p7|7
7Z8d9
8 8$8
8 8$8(8,8
8 8$8(8,8084888<8@8D8H8L8P8T8X8\8`8d8h8l8p8t8x8|8
8 8$8(8,80848G9w9F:E;P;^<k<
8 8$8(8@8
8 8$8(8^8G9N9Z9_9
8 8$8(8`8d8h8,959>9\9e9q9
8 8(808@8H8P8`8h8x8
8 8(848<8H8L8P8\8`8d8p8t8x8
8 8)888B8F8M8f8o8~8
8 8,848@8H8T8\8h8p8|8
8 8,888D8P8\8h8t8
8 888P8h8
8 9$9(9,9094989<9g9
8 9T9
8!<ar
8!<aru
8!828C8Z8h8
8!8'8@8I8X8b8f8m8
8!8'81858<8U8^8m8w8{8
8!9f9
8!9p9t9x9|9
8"8)808
8"8_8n8y8
8#8>8Y8t8
8#8-878A8K8U8[8e8o8y8
8#888
8#8E8T8[8e8
8#9H9
8#9h9O;
8#9y9
8$8,848<8D8T8\8d8l8t8|8
8$8,8D8L8d8l8t8
8$8:8`8m8
8$8;8e8
8$8+8A8e8
8$808<8H8T8`8l8x8
8$80888D8L8X8`8l8t8
8$818
8$888L8`8t8
8$8D8L8d8t8
8$9<9l9p9t9x9|9
8$929;9@9H9]9
8$939>9J9Y9d9
8%8*818>8G8N8S8]8e8j8q8}8
8%8,888@8I8P8\8d8m8t8
8%8C8X8m8
8%8c8y8
8%8D8Z8y8
8%9,9
8%9C9j9
8%9H9w9
8%9I9
8%9s9
8%9z9
8&8/888@8G8O8W8l8q8y8
8&8C8N8p8
8&8F8w8
8&8J8Q8u8|8
8&9,9
8&9S9
8&9X9z98:g:
8(8,8084888<8@8L8P8T8X8|8
8(8:8C8Z8
8(8@8X8p8
8(8]8
8(8=8R8g8|8
8(80888@8H8P8X8`8p8x8
8(848@8L8X8d8p8|8
8(868I8S8v8
8(8K8
8(8M8r8
8(9,9
8(9,9094989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
8(9W9^9
8)8>8S8h8}8
8)8g8
8)959C9
8*8?8T8i8~8
8*818G8L8
8*858`8o8z8
8*8C8
8*8T8~8
8,:0:4:8:<:@:D:H:L:P:T:X:\:
8,8@8`:
8,8A8V8k8
8,8h8o8
8,8O8`8
8/8@8D8H8L8P8T8X8\8`8d8
8/8D8H8L8
8:8C8\8f8w8
8:8Q8W8
8:8U8p8
8:9g9
8:t V
8;8\8j9
8;8`8
8;L$H
8?u_h
8@=F=
8@8P8l8p8
8[SVW
8\$.t
8\$.u
8\8`8
8]91:G:d:
8^9c9t9
8^9h9
8_uR3
8`9d9h9l9p9L:P:T:X:\:
8~9p>
8+8@8U8
8+8@8U8j8
8+818P8`8t8
8+898L8]8
8<8h8
8<8Z8x8
8<9@9D9H9L9P9a9
8<9`=
8=8_8
8>8J8b8l8
8>9W9e9
8>9Y9p9
80<0@0D0H0
80<0@0D0H0L0P0T0X0\0`0d0h0l0p0t0x0|0
808:8F8
808\8
808D8X8l8
808H8`8x8
808P8p8
808R8t8
818O8q8
819@9N9
819O9
828P8n8
829U9
838E8L8
838I8_8u8
839;9W9\9j9
839{9
839f9~9
839U9
839u9
848B8K8R8u8|8
849>9
849S9
858]8
858C8L8X8
858D8K8`8w8
858O8
859w9
868i8
869g9
878>8o8
879\9
879_9t:7;
879s9
8'8?8W8o8
8'8<8Q8f8{8
8'80878U8h8
8'81858<8U8^8m8w8{8
88888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888
889K9k9
8-8B8W8l8
8-8I8d8
8'8W8^8p8
8-8z8
8'9=9D9N9]9i9|9
898B8T8`8d8j8
898u8
89CDEF
8'9I9`9u9':I:W:l:
8'9t9
8'9Y9
8A9f9
8A9F9
8a9n9
8B8a8j8
8B9I9x9
8C8~8
8D$/uE
8D8[8r8
8D8R8[8`8h8}8
8d9h9
8d9h9l9p9t9x9|9
8DBUGu
8e8{8
8E8m8
8e8r8
8E8u8
8E8U8c8m8t8z8
8E9`9
8G;g<
8Gau7
8h8+:
8H8L8P8T8X8\8`8d8h8
8H8u8
8H8Z8
8h94:8:<:@:D:H:L:P:T:X:\:
8H9L9
8H9X9
8I9j9
8I9X:
8J8p8
8J9d9j9
8k8p8
8L$Gu(
8O93:Z:
8Q:l:
8R9Y9
8RQPV
8S#t.
8s?;}
8S<u!h
8s>;}
8S8z8
8T8`8k8}8
8T9p9
8U8s8
8U9r9
8v9}9
8Vh@B
8W8S9y9
8W9C:
8x8|8
8X8o8
9 :':j;
9 :F:m:
9 9$9(9,9094989<9@9D9H9L9,:
9 9$9(9,9094989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
9 9$9(9,9094989<9@9D9H9W9y9
9 9$9(9,9094989h9}9
9 9(90989@9H9P9X9`9h9p9x9
9 9(949<9H9P9\9d9p9t9x9
9 9,989D9P9\9
9 9@9
9 9@9`9
9 949H9\9p9
9 959
9 989<9@9D9H9L9P9
9 989<9@9L9P9`9d9h9x9|9
9 989P9h9
9 9D9L9
9!:1:c:
9!9(9a9
9!9+959?9I9S9]9c9m9w9
9!91989?9F9M9j9
9!999H9L9P9T9X9\9`9X:j:
9":0:7:A:G:N:U:x:
9";B;
9"9@9^9|9
9"9E9U9\9n9
9#:e:
9#:F:
9#:P:
9#989M9b9w9
9$:9:r:
9$:P:|:
9$:z:
9$9(9,989<9@9L9P9T9`9d9h9t9|9
9$9,949<9D9H9L9P9X9\9d9h9p9x9|9
9$9,949<9D9T9\9h9
9$9,949D9L9T9d9p9t9
9$9+929W9q9
9$909<9H9T9`9l9x9
9$90989A9H9T9\9e9l9x9
9$90989D9L9X9`9l9t9
9$999N9c9x9
9$9D9T9d9l9t9
9%:d:
9%:o:
9%9:9O9d9y9
9%969D9M9T9[9w9
9%9S9
9&:-:x:
9&:~:
9&:+:k:p:
9&:=:
9&:0:
9&:G:
9&9;9P9e9z9
9&9?9Y9
9&909:9A9K9U9
9&90969<9B9H9N9T9Z9`9f9l9r9x9~9
9&959H9[9f9l9w9
9&9-9B9
9&9b9
9(:,:0:4:8:
9(9,909<9@9D9P9T9X9d9h9l9x9|9
9(9,9094989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
9(9,98<,=
9(9/979>9F9N9_9d9l9y9
9(9@9X9p9
9(9<9P9d9x9
9(9=9R9g9|9
9(949@9L9X9d9p9
9(999S9
9(9-9l9z9
9(9H9w9
9(9J9Z9j9u9
9(9N9[9i9q9w9{9
9)9>9S9h9}9
9)919:9A9M9U9^9e9q9y9
9)9-939L9U9d9n9r9y9
9)9I9w9
9*:Q:X:b:q:
9*:T:
9*9?9T9i9~9
9*94989?9X9a9p9z9~9
9,9[9
9,9=9a9y9
9,909L9P9l9p9
9,969:9A9Z9c9r9|9
9,9f9
9,9J9h9
9,9P9[9f9{9
9,9Q9v9
9.:5:x:|:
9.;];m;
9/:D:t:
9/9?9_9t9
9/9E9h9y9
9/9G9_9w9
9-:";N=
9':.:
9::@:
9-:H:
9':H:U:o:|:
9':O:
9':U:
9@9b9
9\$ vp
9\$(s
9\$(v
9\$DvH
9\:L<a<
9\9w9
9] t"h
9]:z:
9^ v>W
9^ w2
9^(vX
9^,vT
9^:}:
9^@vE
9^9h9
9^9w9
9^L_[t
9_ v3
9_@v9
9_^[]
9_XvY
9`:L;d;
9`9j9
9{ v6
9{0u+
9{dve
9|$$w
9|$\v;
9|$|v8
9|$x|
9|$Xvf
9|$Xvk
9|$Xvv
9|:R;
9~(v&
9~(v)
9~,v&
9~@v>
9~<v6;~<s
9~4s=;~0v!
9~4v"
9~Dv$3
9~Tv$3
9+:g<
9+929
9+949@9K9h9q9}9
9+949C9M9Q9X9q9z9
9+969K9
9+9v9}9<:F:P:
9'<.<Y=`=f=
9<9o9
9<9Q9l9
9<9S9f9}9
9-=4=C=J=4>
9=9f9~9
9>9{9
9>9I9T9z9
9>9u9
9>u9j
90:x:
90?0P0
909H9`9x9
909J9\9c9m9
909P9p9
909S9d9
909W9~9
90t)A;
91~23
919h9
919L9g9
919O9
92:;;
92:=:w:
929[9
939;9S9[9s9{9
939M9T9[9b9i9p9w9~9
939V9
94:^:
94:J:Q:}:
94<`<
94=;=
949>9Y9x9
949Q9
95:h:
95:R:
95:S:a:g:s:
95:Z:
959C9R9
959D9K9`9w9
959T9k9
96;>;-=4=
97:~:
97:>:P:T:u:
97:Z:
979^9
979z9
989A9P9Z9^9e9~9
989n9t9
989s9
98t!A
98t'A
98tCA
98trB;Q
99:n:
9'9<9Q9f9{9
9'9<9S9\9c9
9'90979k9
9'929
9'9F9s9
9-9H9c9~9
9'9i<v=c>
9'9j9
99t;3
9A:Y:
9A@uO
9A0um
9A0uP
9A9l9
9A9N9f9
9B r>
9B u*
9B$u"
9B:~:
9B:I:S:b:i:s:
9B@t!^
9B<t/^
9B9M9v9
9BSCD
9C@uK
9C0u;
9D$$v^
9D$(r
9D$0u
9D$0w
9D$8r
9D:H:
9D:H:L:P:
9E u(
9E uN
9E:^:
9E:_:
9E9c9
9E9r9
9F r/
9F(_^
9F,s/
9FPv3;Fps
9G9o9
9H:L:d:h:
9H:t:
9H9O9
9hLFS0
9Hlu!
9Hlu1
9I:P:
9K:w:
9K\v"
9K0t+
9K9[9q9
9Kpt7
9L$ ti
9L$<u(9T$0u"
9L$Xu
9l:p:|:
9l9p9
9L9S9r9y9
9m:{:P;G<U<0=
9N$t)
9N9]9h9
9NB09
9O,tI
9O4~]
9O9f9x9
9p tQ
9P u[
9P v<
9P:}:
9p<uI
9P0v*
9P9w:
9Q:n:
9Q@uF
9Q9k9p9
9r4t8
9S,v#
9S9u9
9T$$|
9t$$r
9T$$t
9t$|v
9T$4r
9t$Ht0
9t$hvZ
9T$lv
9t$lv[
9t$pvZ
9t$T|
9t:{:R;Y;
9t:x:|:
9T9X9
9U:\:r:
9U:o:
9U;\;<<C<Y<`<
9u<t=x=|=
9V,v:
9w v!
9W,vU
9W|vc
9w0tb
9X,v,
9X:s:
9X4t]
9Y t)
9y(va
9Y:x:
9Y9c9
9Y9w9@:
9z,v{
9Z:t:
9Z@uF
9z4vB
A * (1/A) = 1 <| Explicit
A * B for boolean A & B -> AND A, B <| MR.GenSimplifyInstructionsOpt1_NoExcl
A * B/A with negative variations on A <| MR.GenSimplifyInstructionsOpt1_NoExcl
A ;C s
A ;G 
A @;F s.
a | r : if( known_bfi_bitmask_noshift_impmask(a,r) && and_is_zero(a,r) ) -> bfi(bfi_bitwidth_noshift_impmask(a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
a + (F - a) -> append_arg(F) <| SMR.RangeDataAnalysis
a + -a -> append_arg(0) <| SMR.RangeDataAnalysis
A + B for boolean A & B -> OR A, B <| MR.GenSimplifyInstructionsOpt1_NoExcl
a << L | b (bfi(w=32-L, o=L, a, b) if( mask_is_zero(w, o, b) && allbutwidth_is_zero(w, a) -> imad (a, 1 << L, B) <| MR.GenMad
A = B ? B : C -> A = B ? TRUE : C} <| Explicit
A = B || !B -> A = B || TRUE <| Explicit
a = bfi(w, o, and(m, v), r) : if( masked_is_one(w,o,m) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, and(v, m), r) : if( masked_is_one(w,o,m) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, v, 0i) | r : if( mask_is_zero(w,o,r) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_Excl
a = bfi(w, o, v, 0i) | r : if( mask_is_zero(w,o,r) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, v, and(m, r)) : if( unmasked_is_one_or_val_is_zero(w,o,v,m) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a = bfi(w, o, v, and(r, m)) : if( unmasked_is_one_or_val_is_zero(w,o,v,m) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
a library must have at least one exported function
A 'ret' instruction must be followed by either (1) the end of the shader or (2) a 'label' instruction. Aborting shader validation.
A Shader is declaring a resource object as a texture using a register mapped to a root descriptor SRV (ShaderRegister=%u, RegisterSpace=%u).  SRV or UAV root descriptors can only be Raw or Structured buffers.
A Shader is declaring a structured UAV with counter using a register mapped to a root descriptor UAV (ShaderRegister=%u, RegisterSpace=%u).  SRV or UAV root descriptors can only be Raw or Structured buffers.
A Shader is declaring a typed UAV using a register mapped to a root descriptor UAV (ShaderRegister=%u, RegisterSpace=%u).  SRV or UAV root descriptors can only be Raw or Structured buffers.
a uint specifying the number of iterations to unroll
A$f9p
A( V6
A($X6
A((W6
A(,V6
A(;G(
A(@W6
A(\V6
A(`X6
A(|W6
A(<X6
A(0X6
A(4W6
A(8V6
A(DV6
A(dW6
A(hV6
A(HX6
A(LW6
A(lX6
A(PV6
A(pW6
A(tV6
A(TX6
A(xU6
A(XW6
A(xX6
a*(1/(b*a)) -> 1 / b <| MR.GenSimplifyInstructionsOpt1_Excl
A*(L2<0) REL L (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2<0) REL L <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2>0) REL L (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*(L2>0) REL L <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*L2 REL L where L2 < 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*L2 REL L where L2 > 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
A*L2 REL L where L2 divides L as a UINT <| MR.GenSimplifyInstructionsOpt1_NoExcl
A,;B,
A;K\r
A;NPr
A@;B@u7
A+A REL L (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
A+A REL L <| MR.GenSimplifyInstructionsOpt1_NoExcl
A<;B<s
A<;C<
A<;F<
A<SVW
A0;A8u
A0;B0u
A0;B0u'
a0a0a0
A4;A<u
A4;B4u
A4f;C
A4f;G
AB_BlendFactor
AB_SampleMask
ABCDEFGHIIIJKKJKKLMNOPPPQPPPPPPRSTUVWXYZ[\]^_`abcdefghijklmnopqrs
abort
abs float_literal <| SFPS
abs fp_flags <| SFPS
abs fp_range <| SFPS
abs fp_specials <| SFPS
abs instruction to abs modifier match <| Explicit
Abs modifier not allowed for operand #%d of opcode #%d (counts are 1-based). 
abs on unsigned values is not meaningful, ignoring
abs(a), a negative -> neg(a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
abs(a), a positive -> a <| MR.GenSimplifyInstructionsOpt1_NoExcl
Absolute and relative addressing of constant registers cannot be combined in one instruction.
Absolute and relative addressing of input registers cannot be combined in one instruction.
abstract interfaces not supported on %s
abstract interfaces not supported on %s, interface references must resolve to specific instances
Access
accum
acos float_literal <| SFPS
acos fp_flags <| SFPS
acos fp_range <| SFPS
acos fp_specials <| SFPS
Ad;A\
AD+A@
AD+A@VW
AD+A@W
ADAPTIVETESS_W
ADAPTIVETESS_X
ADAPTIVETESS_Y
ADAPTIVETESS_Z
ADC+A@
add float_literal <| SFPS
add fp_flags <| SFPS
add fp_range <| SFPS
add of negative of itself identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
add of zero identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
add(0f,a) -> append_arg(a) <| SMR.RangeDataAnalysis
Addition of same argument is same as multiply by 2 <| Explicit
Address mode must be absolute (%s source param).
addressing operations are not allowed on input registers '%s'
addressing operations are not allowed on output registers '%s'
addressing operations not allowed on temporary registers '%s'
AddressOffset
addressOffset
AddressSection
addressSection
AddressTaken
addressU
ADDRESSU
AddressU
ADDRESSV
AddressV
addressV
AddressW
ADDRESSW
addressW
ADDSIGNED
ADDSIGNED2X
ADDSMOOTH
AddUint64
AddUint64 can only be applied to uint2 and uint4 operands
AddUint64 requires shader model 5 or higher
ADt;h
ADtDh
After texdepth instruction, r5 is no longer available in shader.
aL can only be referenced in the following scenarios: (1) inside a loop/endloop block, or (2) in a subroutine for which in all cases some call below in the stack is in a loop/endloop block. 
All DS input control point vcp[][] registers must have control point count (first dimension) declared with size equal to the number of input control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
all global variables are implicitly constant when compiling a library.
All GS input v[][] registers must have vertex count (first dimension) declared with size equal to the number of vertices in the declared input primitive (%d vertices in this case). Input %d has %d vertices declared. 
All HS control point phase input v[][] registers must have control point count (first dimension) declared with size less than or equal to the number of input control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
All HS fork phase input vcp[][] registers must have control point count (first dimension) declared with size less than or equal to the number of input control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
All HS fork phase input vocp[][] registers must have control point count (first dimension) declared with size less than or equal to the number of output control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
All HS join phase input vcp[][] registers must have control point count (first dimension) declared with size equal to the number of input control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
All HS join phase input vocp[][] registers must have control point count (first dimension) declared with size equal to the number of output control points declared in the hs decls phase (%d control points in this case). Input %d has %d control points declared. 
all template type components must have the same type
AllMemoryBarrier
AllMemoryBarrierWithGroupSync
allocatesBasePointer
ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT
ALLOW_STREAM_OUTPUT
allow_uav_condition
allResourcesBound
ALPHA
ALPHAARG0
ALPHAARG1
ALPHAARG2
ALPHABLENDENABLE
ALPHAFUNC
ALPHAOP
ALPHAREF
ALPHAREPLICATE
ALPHATESTENABLE
AlphaToCoverageEnable
alternate cases for 'asm' are deprecated in strict mode
alternate cases for 'decl' are deprecated in strict mode
alternate cases for 'pass' are deprecated in strict mode
alternate cases for 'technique' are deprecated in strict mode
alternate cases for 'Texture1D' are deprecated in strict mode
alternate cases for 'Texture2D' are deprecated in strict mode
alternate cases for 'Texture3D' are deprecated in strict mode
alternate cases for 'TextureCube' are deprecated in strict mode
Alternately, fxc's /LD option allows use of the old compiler DLL
ALWAYS
AMBIENT
AMBIENTMATERIALSOURCE
AMPLIFICATION
and bits_known <| SFPS
and fp_flags <| SFPS
and int_flags <| SFPS
and int_literal <| SFPS
and(a, iv2) : if( can_reduce_and(a, iv2) ) -> and(a, get_reduced_and(a, iv2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
and(and(a, b), c) : if( and_is_identity(c, b) ) -> and(a, c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
and(and(b, a), c) : if( and_is_identity(c, b) ) -> and(a, c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
and(btrue,a) -> append_arg(a) <| SMR.RangeDataAnalysis
and(false,a) -> append_arg(0,a) <| SMR.RangeDataAnalysis
and(or(a, iv1), iv2) -> or(and(a, iv2), and(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
and, binary_compute on values -> binary_compute, and <| MR.GenShuffleCompute_NoExcl
and, quat arg1 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg2 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg3 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, quat arg4 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
and, ternary arg1 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
and, ternary arg2 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
and, ternary arg3 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
and, unary_compute on values -> unary_compute, and <| MR.GenShuffleCompute_NoExcl
ANISOTROPIC
annotation members
ANTIALIASEDLINEENABLE
AntialiasedLineEnable
Aon9t
AP;BPu?
api-ms-win-core-debug-l1-1-0.dll
api-ms-win-core-errorhandling-l1-1-0.dll
api-ms-win-core-file-l1-1-0.dll
api-ms-win-core-file-l1-2-0.dll
api-ms-win-core-file-l2-1-1.dll
api-ms-win-core-handle-l1-1-0.dll
api-ms-win-core-heap-l1-1-0.dll
api-ms-win-core-heap-l2-1-0.dll
api-ms-win-core-interlocked-l1-1-0.dll
api-ms-win-core-io-l1-1-0.dll
api-ms-win-core-libraryloader-l1-2-0.dll
api-ms-win-core-localization-l1-2-0.dll
api-ms-win-core-memory-l1-1-0.dll
api-ms-win-core-processenvironment-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-0.dll
api-ms-win-core-processthreads-l1-1-1.dll
api-ms-win-core-profile-l1-1-0.dll
api-ms-win-core-registry-l1-1-0.dll
api-ms-win-core-string-l1-1-0.dll
api-ms-win-core-string-obsolete-l1-1-0.dll
api-ms-win-core-synch-l1-1-0.dll
api-ms-win-core-synch-l1-2-0.dll
api-ms-win-core-sysinfo-l1-1-0.dll
api-ms-win-crt-math-l1-1-0.dll
api-ms-win-crt-private-l1-1-0.dll
api-ms-win-crt-runtime-l1-1-0.dll
api-ms-win-crt-string-l1-1-0.dll
api-ms-win-crt-time-l1-1-0.dll
append
Append
Append/Consume not compatible with buffer type
AppendStructuredBuffer
array dimension for %s must be %i
array dimension must be between 1 and 65536
array dimensions must be literal scalar expressions
array dimensions of type must be explicit
array index out of bounds
array index out of bounds <| A%u (B%u), I%u (B%u)
array reference cannot be used as an l-value; not natively addressable
array, matrix, vector, or indexable object type expected in index expression
array_index 
array_merge(chain_merge() || chain) -> append_arg(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
ArrayIndexType
ArrayIndexTypeId
asdouble
asdouble can only be used on uint values on %s
asfloat
asfloat can only be used on floating point values on %s
asfloat cannot be used on min precision values
asin float_literal <| SFPS
asin fp_flags <| SFPS
asin fp_range <| SFPS
asin fp_specials <| SFPS
asint
asint cannot be used on %s
asint cannot be used on min precision values
asm {
asm blocks have not yet been implemented
asm_fragment
Assignment %s: Attempting to assign an incompatible inline shader
Assignment %s: Dimensionality mismatch (LHS expects %d, RHS has %d)
Assignment %s: Expressions cannot be evaluated to produce objects, though they may be used to index into arrays of objects
Assignment %s: Inline shader missing interface parameter bindings
Assignment %s: Left-hand side type does not match right-hand side type
Assignment %s: Non-array right-hand type expected
Assignment %s: Objects left-hand sides cannot be assigned to expressions
Assignment %s: Only 0 and NULL are valid constants for an object assignment
Assignment %s: Only literal right-hand side values are allowed in state blocks in Effects performance mode
Assignment %s: Reference to shader variable '%s' not valid for %s techniques because it is missing interface parameter bindings
Assignment %s: Reference to shader variable '%s' not valid for %s techniques because it uses an uninitialized shader
Assignment %s: Reference to shader variable '%s' not valid for %s techniques because it uses an unsupported shader model
asuint
asuint can only be used on double values on %s
asuint cannot be used on %s
asuint cannot be used on min precision values
At@t"
AT3CT
atan float_literal <| SFPS
atan fp_flags <| SFPS
atan fp_range <| SFPS
atan fp_specials <| SFPS
atan of known 0 or 1 identity <| Explicit
atan2
atan2 float_literal <| SFPS
atan2 fp_flags <| SFPS
atan2 fp_range <| SFPS
atan2 fp_specials <| SFPS
atomic_and
atomic_and fp_flags <| SFPS
atomic_cmp_store
atomic_cmp_store fp_flags <| SFPS
atomic_iadd
atomic_iadd fp_flags <| SFPS
atomic_imax
atomic_imax fp_flags <| SFPS
atomic_imin
atomic_imin fp_flags <| SFPS
atomic_or
atomic_or fp_flags <| SFPS
atomic_umax
atomic_umax fp_flags <| SFPS
atomic_umin
atomic_umin fp_flags <| SFPS
atomic_xor
atomic_xor fp_flags <| SFPS
attempt to group scalar values read by similar instructions <| Explicit
Attempt to read undeclared component%s of input register v%d (*): %s. Components of v# registers to be read must be declared by a dcl statement.
Attempt to write undeclared component%s of output register o%d (*): %s. Components of o# registers to be written must be declared by a dcl statement.
attribute %s expects the %s parameter to be a %s
attribute evaluation can only be done on values taken directly from inputs
Attributes
AttrParams
B :G u
B ;F r
B ;G u
B _^Y]
b | (a & c) | (a & d) -> or(b, and(a, or(c,d)) <| MR.GenSimplifyInstructionsOpt1_Excl
b = ubfe(w, o, a); movc(b & (1 << (w - 1 + o)), b | ~((1 << w + o)-1), b) -> ibfe(w, o, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
b = ubfe/ushr(a,o), movc((a >> o) & iv_pow2, b | -iv_pow2) -> ibfe(get_first_bit(iv_pow2), 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
b = ubfe/ushr(a,o), movc((b >> o) & iv_pow2, bfi(w, 0, b, -iv_pow2)) -> ibfe(get_first_bit(iv_pow2), 0, a) <| MR.GenD3D10_OptimizeEarlyTranslate
B!:G!u
B":G"u
B#:G#
B$;G$u
b%d already def'd in the shader. 
b%d must only be defined as true (0x00000001) or false (0x00000000). 
B*!(A * -B + B) -> A * B <| MR.GenSimplifyInstructionsOpt1_NoExcl
B,;G,
B,9G,
B;P0r
B;T$0r
B;V r
B;V(r
B;V,r
B;V`r
B;VPr
B;VTr
B;W,r
B<;C<
B<A;H
B0;Ads
B0+B,
B4_^]
B8Qh8
BackEndBuild
BackEndMajor
BackEndMinor
BackEndQFE
BackFaceStencilDepthFail
BackFaceStencilFail
BackFaceStencilFunc
BackFaceStencilPass
back-propagate negate through iadd <| MR.GenSimplifyInstructionsOpt1_Excl
back-propagate negate through imul <| MR.GenSimplifyInstructionsOpt1_Excl
Bad end token.  DWORD count > 1 given. Expected DWORD count to be 1 for end token.
Bad version token.  DWORD count > 1 given. Expected DWORD count to be 1 for version token.
Bad version token.  It indicates neither a pixel shader nor a vertex shader.
base data offset start
base data slot
base of locals
Base of the stack frame
base symbol for base pointer
base type is not a struct, class or interface
BaseType
Basic correctness checking <| Explicit
bcdef
bcrypt.dll
BCryptCloseAlgorithmProvider
BCryptCreateHash
BCryptDestroyHash
BCryptFinishHash
BCryptGetProperty
BCryptHashData
BCryptOpenAlgorithmProvider
BD+B@
bdeq fp_flags <| SFPS
bdeq int_literal <| SFPS
bdeq int_range <| SFPS
bdge fp_flags <| SFPS
bdge int_literal <| SFPS
bdge int_range <| SFPS
bdlt fp_flags <| SFPS
bdlt int_literal <| SFPS
bdlt int_range <| SFPS
bdne fp_flags <| SFPS
bdne int_literal <| SFPS
bdne int_range <| SFPS
BDt;h
bem can only be used before a phase marker (required) later in the shader.
bem may only be used once in a shader.
beq fp_flags <| SFPS
beq int_literal <| SFPS
beq int_range <| SFPS
BFBF;
bfi bits_known <| SFPS
bfi fp_flags <| SFPS
bfi int_literal <| SFPS
bfi(and(31,w), o, v, r) : if( lower_5_bits_are_set(31) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(and(w,31), o, v, r) : if( lower_5_bits_are_set(31) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(i) -> insertion sequence <| MR.Gen_RequiredTranslate
bfi(w, 0, v, n << w) : if( w != 0 ) -> bfi(32-w, w, n, v) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, 0i, a, 0i) -> ubfe(w, 0i, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, 0i, n, n) -> mov(n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, 0i, v, r) : if( width_is_zero(w,r) && allbutwidth_is_zero(w, v) -> iadd(v, r) <| MR.GenD3D10PostMod_Both
bfi(w, and(31,o), v, r) : if( lower_5_bits_are_set(31) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, and(o,31), v, r) : if( lower_5_bits_are_set(31) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, o, v, bfi(w, o, 0, n)) -> bfi(w, o, v, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfi(w, o, v, n) << s -> bfi(w, o+s, v, n) <| MR.GenSimplifyInstructionsOpt1_Excl
bfi(w, o, v, n) << s -> bfi(w, o+s, v, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bfrev
bge fp_flags <| SFPS
bge int_literal <| SFPS
bge int_range <| SFPS
bge(mul(x,x),neg(mul(x,x))) -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
bias amount for sample_b must be in the range [%f,%f], but %f was specified as an immediate. Opcode #%d, operand #%d (counts are 1-based). 
bieq bits_known <| SFPS
bieq fp_flags <| SFPS
bieq int_literal <| SFPS
bieq int_range <| SFPS
bige bits_known <| SFPS
bige fp_flags <| SFPS
bige int_literal <| SFPS
bige int_range <| SFPS
bilt bits_known <| SFPS
bilt fp_flags <| SFPS
bilt int_literal <| SFPS
bilt int_range <| SFPS
binary expression with negative symmetry reduction <| MR.GenSimplifyInstructionsOpt1_NoExcl
bind semantics cannot be specified for this object
bind_load(chain, value) -> o->append_sources(chain) <| SMR.DataFlagAnalysis
BindInterfaces
BindInterfaces used with a shader that does not have interface parameters
bine bits_known <| SFPS
bine for isfinite on finite -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
bine fp_flags <| SFPS
bine int_literal <| SFPS
bine int_range <| SFPS
bine(b,0) -> b <| MR.GenSimplifyInstructionsOpt2_NoExcl
bine(i/ushr(a, n),0) : if(lower_n_bits_are_zero(a, n)) -> bine (a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
bine(ishl(a, n),0) : if(upper_n_bits_are_zero(a, n)) -> bine (a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
BINORMAL
binormal
Binormal
Bit 31 not set in dcl info token!  Aborting validation.
BitPosition
Bitwise operations not supported on target %s.
BlA;K
Blend
BLEND_FACTOR
BLENDCURRENTALPHA
BLENDDIFFUSEALPHA
BlendEnable
BLENDFACTOR
BLENDFACTORALPHA
blendindices
BLENDINDICES
BlendIndices
BLENDOP
BlendOp
BlendOpAlpha
BLENDOPALPHA
BlendState
BLENDTEXTUREALPHA
BLENDTEXTUREALPHAPM
blendweight
BlendWeight
BLENDWEIGHT
blt fp_flags <| SFPS
blt int_literal <| SFPS
blt int_range <| SFPS
bne fp_flags <| SFPS
bne int_literal <| SFPS
bne int_range <| SFPS
bool ? a - 1 : a -> a + bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
bool ? a + 1 : a -> a - bool <| MR.GenSimplifyInstructionsOpt1_NoExcl
bool multiply chain reduction <| Explicit
bool1
bool1x1
bool1x2
bool1x3
bool1x4
bool2
bool2x1
bool2x2
bool2x3
bool2x4
bool3
bool3x1
bool3x2
bool3x3
bool3x4
bool4
bool4x1
bool4x2
bool4x3
bool4x4
boolean
boolean constant register '%s' must be defined as a variable of type bool only
BORDER
BorderColor
BORDERCOLOR
borderColor
both sides of the && operator are always evaluated, side effect on '%s' will not be conditional
both sides of the ?: operator are always evaluated, side effect on '%s' will not be conditional
both sides of the || operator are always evaluated, side effect on '%s' will not be conditional
BOTHINVSRCALPHA
BOTHSRCALPHA
Bp+B`
branch
break
break fp_flags <| SFPS
'break' instruction not within a local loop/rep construct. Aborting shader validation. 
'break' instruction not within a local rep/endrep construct. Aborting shader validation. 
break must be inside loop
break never match (to NOP) <| MR.GenSimplifyInstructionsAlways_Both
break(a,bieq(x,0)) -> breakn(a,x) <| MR.Gen_PreModTarget_Both
break(a,bine(x)) -> break(a,x) <| MR.Gen_PreModTarget_Both
break(a,not(x)) -> breakn(a,x) <| MR.Gen_PreModTarget_Both
break(ge(neg(fbool), fbool)) -> break_eq(fbool, 0) <| MR.Gen_PreModTarget_Both
break/breakc statement not inside loop or switch.  Opcode #%d (count 1-based).
break/continue can only be followed by case/default/endswitch/endloop/else/endif. Opcode #%d (count 1-based). Aborting validation.
break_c
break_cmp
break_consume fp_flags <| SFPS
BREAK_EQ i2,i1 <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,i1 matches when CMP is used <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,-iv1 where iv1 is literal and has to be negated <| MR.Gen_PreModTarget_Both
BREAK_EQ i2,-iv1 where iv1 is literal and has to be negated, CMP form <| MR.Gen_PreModTarget_Both
BREAK_GE i2,i1 for targets that use CMP <| MR.Gen_PreModTarget_Both
BREAK_GE i2,i1 short form <| MR.Gen_PreModTarget_Both
BREAK_GE i2,-iv1 where iv1 is literal and needs to be negated before using <| MR.Gen_PreModTarget_Both
BREAK_LT i2,i1 for targets that use CMP <| MR.Gen_PreModTarget_Both
BREAK_LT i2,i1 short form <| MR.Gen_PreModTarget_Both
BREAK_LT i2,-iv1 where iv1 is literal and needs to be negated before using <| MR.Gen_PreModTarget_Both
BREAK_NE i2,i1 <| MR.Gen_PreModTarget_Both
BREAK_NE i2,i1 with CMP <| MR.Gen_PreModTarget_Both
BREAK_NE i2,-iv1 where iv1 is literal and has to be negated <| MR.Gen_PreModTarget_Both
BREAK_NE i2,-iv1 where iv1 is literal and has to be negated, CMP form <| MR.Gen_PreModTarget_Both
breaka match <| MR.GenD3D10PostMod_Both
breakc
breakp
breakp requires parameter to be predicate register (p0). 
btof -> movc <| MR.GenSimplifyInstructionsOpt1_NoExcl
btof fp_flags <| SFPS
btoi -> movc <| MR.GenSimplifyInstructionsOpt1_NoExcl
btoi bits_known <| SFPS
btoi fp_flags <| SFPS
btoi int_literal <| SFPS
btoi int_range <| SFPS
buffer
Buffer
buffer requires a 't' register
BufferChecksWithoutOrdering
Buffers can only be bound to one slot in this version of Effects
Buffers may only be bound to one constant offset.
Buffers may only be bound to one slot.
bufinfo
bufinfo fp_flags <| SFPS
bufinfo requires resource declared as Buffer, Raw Buffer or Structured Buffer.  Opcode #%d, operand #%d (counts are 1-based). 
buge bits_known <| SFPS
buge fp_flags <| SFPS
buge int_literal <| SFPS
buge int_range <| SFPS
built in type kind
bult bits_known <| SFPS
bult fp_flags <| SFPS
bult int_literal <| SFPS
bult int_range <| SFPS
BUMPENVLOFFSET
BUMPENVLSCALE
BUMPENVMAP
BUMPENVMAPLUMINANCE
BUMPENVMAT00
BUMPENVMAT01
BUMPENVMAT10
BUMPENVMAT11
By default, unbounded size descriptor tables are disabled to support frame captures in graphics tools. Use of unbounded (or large) size descriptor tables can produce unusually large and potentially unusable frame captures in graphics tools.  Please specify a reasonably small upper bound on table size.  If that isn?t an option, unbounded size descriptor tables can be enabled using the compiler using switch: /enable_unbounded_descriptor_tables
By the end of a vertex shader, any oTn register written must not have gaps in components, starting from x, in order xyzw. To satisfy this, oT%d requires writing of the additional component%s(*): %s 
ByteAddressBuffer
Bytecode appears corrupt - integrity check failed.
byteOffset
C !G 
C ;A 
C ;A s
C ;A v
C QPQ
C$!G$
c%d already def'd in the shader. 
C(;B(r
C(;G(
C(PRQ
C(QPQ
C(wsRQP
C,;A,u]
C;\$l
C;^ r
C;^(r
C;^(v
C;^,r
C;^@r
C;_ r
C;_(s
C;_,r
C|+Cx
C|F;p
C|PhP$
C<_^[
C<+C4_^[
C<9C4
C0;G0uA
C0_^[
C0+C 
C09O4|
C0F+C,
C0M0W0a0x0
c1, c2, c3, c4, c5, c6
C4;C8v
C4_^3
C49C<
C8;G8u
C89O<
C9_0s
cabinet.dll
CACHE*
calclod1d fp_flags <| SFPS
calclod1d_a fp_flags <| SFPS
calclod1d_u fp_flags <| SFPS
calclod1d_u_a fp_flags <| SFPS
calclod2d fp_flags <| SFPS
calclod2d_a fp_flags <| SFPS
calclod2d_u fp_flags <| SFPS
calclod2d_u_a fp_flags <| SFPS
calclod3d fp_flags <| SFPS
calclod3d_u fp_flags <| SFPS
calclodcube fp_flags <| SFPS
calclodcube_a fp_flags <| SFPS
calclodcube_u fp_flags <| SFPS
calclodcube_u_a fp_flags <| SFPS
CalculateLevelOfDetail
CalculateLevelOfDetailUnclamped
call, callnz, label, and ret instructions are not allowed in assembly fragments
call/callc statement not referencing a label.  Opcode #%d (count 1-based).
callc
CallingConvention
callnz
CAMERASPACENORMAL
CAMERASPACEPOSITION
CAMERASPACEREFLECTIONVECTOR
can be declared (the amount is a function of how many threads there are).  This shader exceeds the limit at %d bytes per thread. 
cannot %sconvert %sfrom '%s' to '%s'
Cannot access 32-bit type pool with 16-bit APIs
Cannot append range with implicit lower bound after an unbounded range (descriptor table slot [%u], root parameter [%u]).
Cannot apply a negation source modifier on data that was last written with the saturate destination modifier. Affected components(*) of %s source param: %s
cannot bind interfaces to classes in tbuffers
cannot bind the same variable to multiple constants in the same constant bank
Cannot call subroutine label defined earlier in shader (label #%d in this case).  Subroutine call must reference label defined later in shader. Aborting shader validation. 
cannot cast the LHS of an assignment to an indexable object, consider using asuint, asfloat, or asdouble on the RHS
cannot clip from a swizzled vector
cannot convert from 'object type' to 'numeric type'
Cannot declare streams as an input for geometry shader primitives, it must be its own parameter.
Cannot fit shader into length limits for target shader model (ps_1_4). 
cannot have divergent gradient operations inside flow control
cannot have gradient operations inside loops with divergent flow control
cannot map expression to %s instruction set
cannot map expression to pixel shader instruction set
cannot map expression to vertex shader instruction set
cannot map loop to shader target, target does not support breaks
cannot match attribute %s, non-uint parameters found
cannot match attribute %s, parameter %i is expected to be of type %s%c
cannot match lerp because lerp factor is not _sat'd
cannot mix packoffset elements with nonpackoffset elements in a cbuffer
Cannot negate second source parameter to vector*matrix instructions.
cannot sample from non-floating point texture formats.
Cannot set co-issue ('+') on a tex* instruction.  Co-issue only applies to arithmetic instructions.
Cannot set co-issue ('+') on a texture instruction.  Co-issue only applies to arithmetic instructions.
Cannot set co-issue ('+') on consecutive instructions.
Cannot swizzle second source parameter to vector*matrix instructions.
cannot unroll loop with an out-of-bounds array reference in the condition
Cannot use %s attribute without specifying a 4-component SV_Position output
Cannot use abs on source parameter(s) on to vFace register.
cannot use casts on l-values
Cannot use negate on second source parameter to vector*matrix instructions.
Cannot use negate on source parameter(s) to %s instruction.
Cannot use negate or abs on second source parameter to vector*matrix instructions.
Cannot use negate or abs on source parameter(s) to %s instruction.
Cannot use tex* instruction after non-tex* instruction.
Cannot use texture arrays on DX9 targets with multiple samplers.
can't be base class, or method can't be overridden
Can't continue validation - aborting.
Can't create/set an invalid shader. Make sure your shader is valid, and make sure you're not using asm shaders in SM4.0
can't emit if statement with both gradients and program flow control
Can't fall through case/default unless case/default has no code. Opcode #%d (count 1-based). Aborting validation.
can't flatten if statements that contain out of bounds array accesses
can't flatten if statements that contain side effects
can't flatten with flow control when variable is bound to b register
can't force branch with gradients on non-inputs
can't match attribute %s, %d or 0 parameters expected, found %d
can't match attribute %s, %d parameter(s) expected, found %d
can't unroll loops marked with loop attribute
can't use branch and flatten attributes together
can't use branch, flatten, call  or case attributes together
can't use call or forcecase attributes on switches in %s programs
can't use fastopt and unroll attributes together
can't use flow control on this profile
can't use gradient instructions in loops with break
can't use loop and unroll attributes together
case %d (or if bits to be interpreted as float: %f) already seen. Opcode #%d (count 1-based).
case fp_flags <| SFPS
case ordinal too large for floating point representation
case statement doesn't match to the scope of a switch statement. Opcode #%d (count 1-based). Aborting validation.
CaseStmts
catch
CB%d[%d:
CB[%d] already declared, repeated declaration on opcode #%d (count is 1-based). 
cbBlock
cbLocals
cbParams
cbProlog
cbSavedRegs
cbStkMax
cbuffer
cbuffer bank %u used more than once
cbuffer register (b%u) used more than once
cbuffer register b#
cbuffer requires a 'b' register
cbuffers cannot have the same name ('%s') in a library
CCW_STENCILFAIL
CCW_STENCILFUNC
CCW_STENCILPASS
CCW_STENCILZFAIL
Cd;Gd
CD_^[
CD+C@
Cd+C`
CD+K@+C@
CDt@h
ceil float_literal <| SFPS
ceil fp_flags <| SFPS
ceil fp_range <| SFPS
ceil fp_specials <| SFPS
center
centroid
centroid 
cf = $IsReturn(a, ci) -> append_arg(a, ci) <| SMR.DataFlagAnalysis
chain_end fp_flags <| SFPS
chain_merge($IsSync() || chain) -> append_arg(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
chain_merge($IsSync() || chain) -> append_arg(sync) <| SMR.DataFlagAnalysis_ConstInterp
chain_merge(chain_merge() || chain) -> append_arg(chain) <| SMR.DataFlagAnalysis_NoPlaceHolder
Change swizzle of parameters to dot <| Explicit
character continues past end of file
check_access_fully_mapped
check_access_fully_mapped fp_flags <| SFPS
CheckAccessFullyMapped
CheckAccessFullyMapped requires shader model 5 or higher
checksumType
cinstanceid
cl = $IsBreak(a, ci) -> append_arg(a, ci) <| SMR.DataFlagAnalysis
cl = $IsConsume(a, b, ci) -> append_arg(ci) <| SMR.DataFlagAnalysis
cl = $IsContinue(a, ci) -> append_arg(a, ci) <| SMR.DataFlagAnalysis
cl = casecond(ci, c) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = emit(ci, stream) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = emitarg(a, b, ci) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = endcase(ci, ch) -> append_arg(ci) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = endcase(ci, ch) -> append_arg(ci, ci_p, ch) <| SMR.DataFlagAnalysis_PlaceHolder
cl = fcbody(ci, c) -> append_arg(ci, c) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = fcbody_end(ci, ch) -> append_arg(ci, ci_p, ch) <| SMR.DataFlagAnalysis_NoPlaceHolder
cl = fcbody_end(ci, ch) -> append_arg(ci, ci_p, ch) <| SMR.DataFlagAnalysis_PlaceHolder
CL+CH
CLAMP
clamp
class
class is intrinsic type
classes and interfaces are not supported in libraries
ClassParent
ClassParentId
clip can only be used with 1 to 4 components in %s
clip cannot be performed from a constant or literal
clip must be performed from a float3 vector for ps_1_x models
clip must be performed from a float4 vector for ps_2_0 models
clip not supported in texture shaders
Clip plane attribute parameters must be non-literal constants
Clip planes cannot be addressed in %s
Clip planes must be non-literal constants with identity swizzles in %s
clip(+d * a,b) -> clip(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
clip(a+a,b) -> clip(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
clip_distance
CLIPDST
CLIPPING
CLIPPLANE0
CLIPPLANE1
CLIPPLANE2
CLIPPLANE3
CLIPPLANE4
CLIPPLANE5
CLIPPLANEENABLE
clipplanes
'clipplanes' attribute is ignored in library functions
Clockwise Triangles
CloseHandle
cmp (a, a, -a) -> abs <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
cmp diff to basic logic identity <| Explicit
cmp float_literal <| SFPS
cmp fp_flags <| SFPS
cmp fp_range <| SFPS
cmp fp_specials <| SFPS
cmp of known negative identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp of known positive identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp of negated bool identity <| Explicit
cmp sequence 1 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
cmp sequence 2 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
cmp(+d * a,b,c) -> cmp(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(a,b,c) -> append_arg(b, c) <| SMR.RangeDataAnalysis
cmp(a+a,b,c) -> cmp(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-b,0,b) -> cmp(b,b,0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
CMP(c,d=1+CMP(c,a,b),f) -> CMP(c,1+a,f) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(c,d=cmp(c,a,b),f) -> cmp(c,a,f) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(c,f,d=cmp(c,a,b)) -> cmp(c,f,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-cmp(a, <=0, >0), b, c) -> cmp(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(cmp(a, <0, >=0), b, c) -> cmp(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(cmp(a, >=0, <0), b, c) -> cmp(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-cmp(a, >0, <=0), b, c) -> cmp(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp(-d * a,b,c) -> cmp(-a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
cmp, binary_compute on same value -> binary_compute, cmp <| MR.GenShuffleCompute_NoExcl
cmp, binary_compute on values -> binary_compute, cmp <| MR.GenShuffleCompute_NoExcl
cmp, binary_compute on values lhs -> binary_compute, cmp <| MR.GenShuffleCompute_Excl
cmp, binary_compute on values rhs -> binary_compute, cmp <| MR.GenShuffleCompute_Excl
cmp, unary_compute on values -> unary_compute, cmp <| MR.GenShuffleCompute_NoExcl
cmp, unary_compute on values lhs -> unary_compute, cmp <| MR.GenShuffleCompute_Excl
cmp, unary_compute on values rhs -> unary_compute, cmp <| MR.GenShuffleCompute_Excl
Co-issue ('+') is not supported in this shader version.
Co-issued instruction cannot write all components - must write either alpha or color.
Co-issued instructions cannot both be dot-product, since each require use of the color/vector pipeline to execute.
Co-issued instructions cannot both be dp3, since each require use of the color pipe to execute.
Co-issued instructions cannot both write to alpha component.
Co-issued instructions cannot both write to color components.
Co-issued instructions cannot both write to the same component(s).  One instruction must write to alpha and the other may write to any combination of red/green/blue.  Destination registers may differ.
Co-issued instructions cannot both write to the same components of a register.  Affected components: %s
color
Color
COLOR
COLOR outputs must be contiguous from COLOR0 to COLORn
COLOR%d must be a four-component vector
COLOR0
COLOR1
COLOR2
COLORARG0
COLORARG1
COLORARG2
COLOROP
COLORVERTEX
COLORWRITEENABLE
COLORWRITEENABLE1
COLORWRITEENABLE2
COLORWRITEENABLE3
column_major
column_major 
columnNumber
columnNumberEnd
combine AND of two equal unknown left shifts <| MR.GenSimplifyInstructionsOpt1_Excl
combine AND of two equal unknown right shifts <| MR.GenSimplifyInstructionsOpt1_Excl
combine AND of two equal unknown unsigned right shifts <| MR.GenSimplifyInstructionsOpt1_Excl
combine of commutative literals <| Explicit
combine OR of two equal shifts <| MR.GenSimplifyInstructionsOpt1_NoExcl
combine simple instructions to reduce instruction count <| Explicit
combine XOR of two equal shifts <| MR.GenSimplifyInstructionsOpt1_NoExcl
CombineInstructions can create dots <| Explicit
comdat
comma expression used where a vector constructor may have been intended
comma expression used where an initializer list may have been intended
comment
comment continues past end of file
Compact Registers - Compress <| Explicit
Compact Registers - Paint  <| Explicit
Compact Registers - Press Loop Ins <| Explicit
Compact Registers - Press Moves <| Explicit
CompanyName
compare
comparison
Comparison filtering for feature level 9
COMPARISON_ALWAYS
COMPARISON_ANISOTROPIC
COMPARISON_EQUAL
COMPARISON_GREATER
COMPARISON_GREATER_EQUAL
COMPARISON_LESS
COMPARISON_LESS_EQUAL
COMPARISON_MIN_LINEAR_MAG_MIP_POINT
COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR
COMPARISON_MIN_MAG_LINEAR_MIP_POINT
COMPARISON_MIN_MAG_MIP_LINEAR
COMPARISON_MIN_MAG_MIP_POINT
COMPARISON_MIN_MAG_POINT_MIP_LINEAR
COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT
COMPARISON_MIN_POINT_MAG_MIP_LINEAR
COMPARISON_NEVER
COMPARISON_NOT_EQUAL
ComparisonFunc
comparisonFunc
compiland
compilandID
compilands
compile
compile expression does not refer to a compilable function.  API calls such as ConstructGSWithSO and BindInterfaces can not be used in arguments to CompileShader
compile expression must specify a valid shader model
compile_fragment
Compiled code results in dynamic flow control nesting depth that exceeds limit of %d for target (%s). 
Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s) (due to conditional break that counts towards the same limit). 
Compiled code results in dynamic 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). 
Compiled code results in loop nesting depth that exceeds limit of %d for target (%s). 
Compiled code results in static 'if'/'endif' nesting depth that exceeds limit of %d for target (%s). 
Compiled code results in subroutine call nesting depth that exceeds limit of %d for target (%s). 
Compiled code results in subroutine nesting depth that exceeds limit of %d for target (%s). 
Compiled shader code has has many operations that use the texture unit (%d). Max. allowed by the target (%s) is %d.
Compiled shader code uses too many arithmetic instruction slots (%d). Max. allowed by the target (%s) is %d. Consider increasing optimization level to reduce instruction count.
Compiled shader code uses too many instruction slots (%d). Max. allowed by the target (%s) is %d.
Compiled shader code uses too many instruction slots (%d). Max. allowed by the target (%s), including cap for instruction limit, is %d.
Compiled shader code uses too many instructions (%d). Max. allowed by the target (%s), including cap for instruction limit, is %d.
Compiled With LTCG
compiler name
COMPILER_GENERATE_OLD_DEBUG_INFO
CompilerGenerated
CompileShader
COMPLEMENT
complement cannot be used with other modifiers
complement is not supported in this shader version
Component%s of register %s%d being read, but not declared. v# and t# registers must be declared using a dcl statement (down to the component level) in %s. Undeclared component%s(*) being read: %s
Component%s of register %s%d being read, but not declared. v# registers must be declared using dcl statement(s) (down to the component level). Affected components (*): %s
Component(s) of register vPos being read, but not declared. vPos must be declared using a dcl statement. Affected components (*): %s
Components of input declaration for register %d overlap with previous declaration for same register.  Opcode #%d (count is 1-based). 
Components of input declaration for register v%d overlap with previous declaration for same register.  Opcode #%d (count is 1-based). 
Components of output declaration for register %d overlap with previous declaration for same register.  Opcode #%d (count is 1-based). 
Components of output declaration for register o%d overlap with previous declaration for same register.  Opcode #%d (count is 1-based). 
Compute Shader input Thread Group ID already declared.  Opcode #%d (count is 1-based). 
Compute Shader input Thread Group ID declaration must have a non-empty mask and allows only components x, y, and z in mask.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID already declared.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID declaration must have a non-empty mask and allows only components x, y, and z in mask.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID In Group already declared.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID In Group declaration must have a non-empty mask and allows only components x, y, and z in mask.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID In Group Flattened already declared.  Opcode #%d (count is 1-based). 
Compute Shader input Thread ID In Group Flattened declaration must have an empty writemask.  Opcode #%d (count is 1-based). 
Compute Shader must declare a thread group size (X,Y,Z).
ComputeShader
conditional must be numeric
conflicting geometry types
conflicting quad/tri/isoline tessfactor semantic
Conflicting register semantics: '%s' and '%s'
Conservative correctness checking <| Explicit
Consider using the [flatten] attribute on the if statement or using the assignment syntax to calculate it yourself (e.g.: x`(y) = z)
Consider using the [flatten] attribute on the switch statement or using the assignment syntax to calculate it yourself (e.g.: x`(y) = z)
Consider using the [unroll] attribute on the loop statement or using the assignment syntax to calculate it yourself (e.g.: x`(y) = z)
Consider using the assignment syntax to calculate it yourself (e.g.: x`(y) = z)
const
const 
Const bool (b#) parameter to %s instruction must specify default swizzle (.xyzw, or none specified.) 
Const declaration (def) must appear before other instructions.
const_cast
CONSTANT
constant
Constant buffer register b# must be defined for each RootConstants
Constant buffer size (%d 16-byte entries) exceeds allowed limit of %d entries. Aborting.
Constant buffers, functions, and techniques cannot be nested inside of constant buffers
constant register '%s' must be defined as a variable '%s'
constant register address out of bounds on constant '%s', size %d, offset %d
constant table info exceeds maximum comment size
Constant variable '%s' bound to register greater than 8191 (%d requested)
ConstantBuffer
constinterp usage cannot be used with linear, noperspective, or centroid usage
ConstructGSWithSO
constructors only defined for numeric base types
ConstType
Consume
consume
ConsumeStructuredBuffer
container
continue
continue cannot be used in a switch
continue fp_flags <| SFPS
continue must be inside loop
continue never match (to NOP) <| MR.GenSimplifyInstructionsAlways_Both
continue(a,bieq(x,0)) -> continuen(a,x) <| MR.Gen_PreModTarget_Both
continue(a,bine(x)) -> continue(a,x) <| MR.Gen_PreModTarget_Both
continue(a,not(x)) -> continuen(a,x) <| MR.Gen_PreModTarget_Both
continue/continuec statement not inside loop.  Opcode #%d (count 1-based).
continue_consume fp_flags <| SFPS
continuea match <| MR.GenD3D10PostMod_Both
continuec
CONTINUOUS
conversion from larger type to smaller, possible loss of data
convert mod by power-of-2 to bitwise AND <| MR.GenSimplifyInstructionsOpt1_NoExcl
COORD0
COORD1
COORD2
COORD3
CopyFileExW
cos float_literal <| SFPS
cos fp_flags <| SFPS
cos fp_range <| SFPS
cos fp_specials <| SFPS
could not cast condition to boolean
could not cast condition to uint
couldn't cast expression to boolean for logical not operator
couldn't cast expression to boolean for logical operator
couldn't cast expression to integer
count
Count
COUNT1
COUNT2
COUNT3
COUNT4
countbits
countbits bits_known <| SFPS
countbits fp_flags <| SFPS
countbits int_literal <| SFPS
countbits(i) -> and/shift/add sequence <| MR.Gen_RequiredTranslate
Counter-Clockwise Triangles
COVERAGE
Cp+C`
CP+CL
cplusplusExceptionHandling
CRC of source bytes.
CreateEventW
CreateFile2
CreateFileA
CreateFileMappingW
CreateFileW
cross
CRPTt
CryptAcquireContextW
CryptCreateHash
CryptDestroyHash
CryptGetHashParam
CryptHashData
CryptReleaseContext
CRYPTSP.dll
cs_%d_%d
cs_4_0
cs_4_1
cs_5_0
cs_5_1
ct$_^2
CT@;CP
CT_^[
cubearray
CUBIC
cull_distance
CULLDST
CULLMODE
CullMode
CURRENT
cut_stream
cw9t4
CxF;p
CxG;x
CXtpj
Cycle Counter already declared.  Opcode #%d (count is 1-based). 
Cycle Counter declaration must have mask of .x or .xy.  Opcode #%d (count is 1-based). 
D$ ;G
D$ @P
D$ +D$$
D$ 8L$
D$ 9G
D$ Ph
D$ PhlM
D$ Pj
D$ PQW
D$ PS
D$ PWS
D$ tl
D$ u8
D$$;D$\v"
D$$;E
D$$;Y
D$$@P
D$$@Ph
D$$@Ph 
D$$@PhH
D$$@Php
D$$@PhP
D$$@Phx
D$$@PhX
D$$@Phx
D$$8L$(r
D$$Ph
D$$Pj
D$$PS
D$$PW
D$$RP
D$$SHDRP
D$$tu
D$$VP
D$$VWP
D$(!D$
D$(;C
D$(;L$l
D$(;X
D$(+D$
D$(8L$$r
D$(8S
D$(9CL
D$(Ph
D$(Pj
D$(PQ
D$(PV
D$(PW
D$(RP
D$(RS
D$(Sh
D$(tW
D$,;C
D$,+C8
D$,+D$
D$,9D$
D$,F+D$
D$,j P
D$,Ph
D$,PQ
D$,PR
D$,PSRVW
D$,PW
D$,VP
D$@;H0s
D$@+D$,
D$@9D$<s
D$@9D$<v
D$@A;
D$@DBUG3
D$@Ph
D$@PQQ
D$@PV
D$@PW
D$@SPP
D$@SR
D$@SVW
D$@tG;
D$@tN
D$@u[
D$\;D$Xu
D$\3D$$#D$P
D$\9D$du
D$\J@
D$\Ph
D$\Pj
D$\PPh
D$\PW
D$\Sj
D$`!D$
D$`;D$L
D$`;D$Ls.
D$`;T$X
D$`9D$du
D$`j(P
D$`Ph
D$`Pj
D$`PS
D$`PW
D$`QR
D$|G;|$h
D$|Pj
D$|PQ
D$|QP
D$|SQ
D$|uj
D$+9W
D$<;0
D$<;C
D$<0k
D$<9C
D$<Ph
D$<Pj
D$<PS
D$<PV
D$<PW
D$<t/
D$0;|$ r
D$0;D$,
D$09D$,
D$09D$4u
D$09J
D$09L$,
D$0F;
D$0Ph
D$0PQ
D$0PVu 
D$0PW
D$0SVW
D$0u6j
D$0uE3
D$4)t$$
D$4;\$8
D$4F;
D$4H;
D$4Ph
D$4Pj
D$4PQ
D$4PVu
D$8;D$4
D$8+L$P@
D$8A;
D$8F#
D$8Ph
D$8PQQ
D$8PR
D$8PV
D$8PW
D$8PWj
D$8QP
D$8RPh`
D$8SVW
D$8VP
D$D#L$0#D$4
D$D=e$
D$D3L$03D$4
D$DG;
D$DPh
D$h;|$`r
D$H;D$8
D$Hh` 
D$HPh
D$HPj
D$HPS
D$hPS
D$HPS
D$hPS
D$hPSj
D$HPSW
D$HQP
D$HuV
D$HyIh
D$L;D$P
D$L;D$x
D$l3D$$#D$@
D$L9D$ 
D$lA;
D$LPh
D$lPh
D$LPh
D$lPj
D$lPQSV
D$lQP
D$LQPh
D$ltMj
D$P;D$Hr
D$pPh
D$PPj
D$pPj
D$PPQj
D$pPR
D$PPSj
D$pPSV
D$PPSW
D$PPVj
D$PPW
D$PPWh
D$pPWj
D$pSV
D$TPh
D$tPj
D$TPQ
D$tPS
D$TPSRQ
D$TPWj
D$xPj
D$XPRj
D$XPRQ
D$xuK
D$XVWSP
d((double)x * x)/dz -> 2*dx/dz * x <| SR.GenDerivatives_Binary
d((double)x * y)/dz -> dx/dz * y + x * dy/dz <| SR.GenDerivatives_Binary
d((double)x + (double)y)/dz -> dx/dz + dy/dz <| SR.GenDerivatives_Binary
d((double)x)/dz -> (double)dx/dz <| SR.GenDerivatives_Unary
d((double)-x)/dz -> -(double)dx/dz <| SR.GenDerivatives_Unary
d(2^x)/dz -> ln(2) * 2^x * dx/dz <| SR.GenDerivatives_Unary
d(a ? b : c)/dz -> a ? db/dz : dc/dz <| SR.GenDerivatives_Ternary
d(acos(x))/dz -> -1/sqrt(1-x^2) * dx/dz <| SR.GenDerivatives_Unary
d(asin(x))/dz -> 1/sqrt(1-x^2) * dx/dz <| SR.GenDerivatives_Unary
d(atan(x))/dz -> 1/(1+x^2) * dx/dz <| SR.GenDerivatives_Unary
d(atan2(x,y))/dz -> 1 / (1 + (y/x)^2) * d(y/x)/dz <| SR.GenDerivatives_Binary
d(cos(x))/dz -> -sin(x) * dx/dz <| SR.GenDerivatives_Unary
d(dmax(x,y))/dz -> (x > y) ? dx/dz : ((y > x) ? dy/dz : dmax(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
d(dmin(x,y))/dz -> (x < y) ? dx/dz : ((y < x) ? dy/dz : dmin(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
d(frac(x))/dz -> dx/dz <| SR.GenDerivatives_Unary
d(IsIntToDouble(x))/dz -> 0lf <| SR.GenDerivatives_Unary
d(IsIntToFloat(x))/dz -> 0f <| SR.GenDerivatives_Unary
d(IsRound(x))/dz -> 0 <| SR.GenDerivatives_Unary
d(log_2(x))/dz -> 1/(x * ln(2)) * dx/dz <| SR.GenDerivatives_Unary
d(max(x,y))/dz -> (x > y) ? dx/dz : ((y > x) ? dy/dz : max(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
d(min(x,y))/dz -> (x < y) ? dx/dz : ((y < x) ? dy/dz : min(dx/dz, dy/dz) <| SR.GenDerivatives_Binary
d(sin(x))/dz -> cos(x) * dx/dz <| SR.GenDerivatives_Unary
d(x * x)/dz -> 2*dx/dz * x <| SR.GenDerivatives_Binary
d(x * y)/dz -> dx/dz * y + x * dy/dz <| SR.GenDerivatives_Binary
d(x / y)/dz -> dx/dz / y + x * -dy/dz / y^2 <| SR.GenDerivatives_Binary
d(x + y)/dz -> dx/dz + dy/dz <| SR.GenDerivatives_Binary
d(x)/dz -> dx/dz <| SR.GenDerivatives_Unary
d(-x)/dz -> -dx/dz <| SR.GenDerivatives_Unary
d(x^-0.5)/dz -> -0.5*x^-1.5 * dx/dz <| SR.GenDerivatives_Unary
d(x+eps)/dz -> dx/dz <| SR.GenDerivatives_Unary
D=>3[FG
D=SDBGt;
D0x%I64x
D1H1W2^2k2r2
D3D10_COMPILER
D3D10_SHADER_AVOID_FLOW_CONTROL
D3D10_SHADER_DEBUG
D3D10_SHADER_ENABLE_BACKWARDS_COMPATIBILITY
D3D10_SHADER_IEEE_STRICTNESS
D3D10_SHADER_NO_PRESHADER
D3D10_SHADER_PARTIAL_PRECISION
D3D10_SHADER_PREFER_FLOW_CONTROL
D3D10_SHADER_SKIP_OPTIMIZATION
D3D11 Assembler Error: Invalid Bytecode: %s
D3D11 Internal Compiler Error: Invalid Bytecode: %s
D3D12 constant/texture buffer template element can only be a struct
D3D12_ROOT_SIGNATURE_FLAG_LOCAL_ROOT_SIGNATURE combined with other flag(s) that don't make sense (root signature flags %x).
D3D12_ROOT_SIGNATURE_FLAG_LOCAL_ROOT_SIGNATURE not supported if device does not support raytracing (root signature flags %x).
D3DAssemble
D3DCOLORtoUBYTE4
D3DCompile
D3DCompile: backwards compatibility mode (/Gec) option is not supported for SM5_1+ targets
D3DCompile: cannot specify source and binary debug names
D3DCompile: Entry point cannot be specified for a library (mark library entry points with the export keyword)
D3DCompile: Entry point must specify the RootSignature define name
D3DCompile: Gfa option cannot be used in SM_5_1+ unless all_resources_bound flag is specified
D3DCompile: Invalid flags specified
D3DCompile: pEntrypoint pointer is invalid
D3DCompile: resources_may_alias option is only valid for cs_5_0+ targets
D3DCompile2
D3DCompileFromFile
d3dcompiler_47.dll
D3DCOMPILER_47.dll
d3dcompiler_47.dll
D3DCompiler_47.pdb
D3DCOMPILER_DISASSEMBLY_FORCE_HEX_LITERALS
D3DCOMPILER_FORCE_PREFER_FLOW
D3DCOMPILER_SAVE_REPLAY
D3DCOMPILER_USE_REPLAY
D3DCompressedData
D3DCompressShaders
D3DCreateBlob
D3DCreateFunctionLinkingGraph
D3DCreateLinker
D3DDecompressShaders
D3DDisassemble
D3DDisassemble10Effect
D3DDisassemble11Trace
D3DDisassembleRegion
D3DEffectCompiler
D3DGetBlobPart
D3DGetDebugInfo
D3DGetInputAndOutputSignatureBlob
D3DGetInputSignatureBlob
D3DGetOutputSignatureBlob
D3DGetTraceInstructionOffsets
D3DLoadModule
D3DPreprocess
D3DReadFileToBlob
D3DReflect
D3DReflectLibrary
D3DReturnFailure1
d3ds_dotswiz
d3ds_noiseswiz
D3DSerializeRootSignature: unknown root parameter type (%u)
D3DSerializeRootSignature: unsupported root signature version (%u)
D3DSetBlobPart
D3DStripShader
D3DWriteBlobToFile
D3DX: (WARN) An allocation of zero bytes should return a unique non-null pointer to at
D3DX: (WARN) D3DX11 relies upon this behavior.
D3DX: (WARN) least zero bytes. Deletion of a null pointer should quietly do nothing.
D3DX: (WARN) Overloaded ::new and ::delete operators do not conform to C++ standards:
D3DX_VERSION
dabs float_literal <| SFPS
dabs fp_flags <| SFPS
dabs fp_range <| SFPS
dabs fp_specials <| SFPS
dadd float_literal <| SFPS
dadd fp_flags <| SFPS
dadd fp_range <| SFPS
data member
DATA_STATIC
DATA_STATIC_WHILE_SET_AT_EXECUTE
DATA_VOLATILE
dataCRC
DataKind
dcl %s# does not support any modifiers.
dcl %s# does not support any modifiers. 
dcl %s# must be one of the following types: dcl_2d, dcl_cube or dcl_volume.
dcl %s# must have one of the following masks: x, xy, xyz or xyzw (alternatively: r, rg, rgb, or rgba).
dcl %s# must not specify a writemask (equivalent to a full mask). 
dcl %s# must not specify a writemask (equivalent to a full mask). When samplers are used for texture lookup, 4 components are always returned, including defaults for components that may not be present in the texture format set at the sampler. 
dcl %s# only supports the (optional) _pp modifier (partial precision hint), and/or the _centroid modifier (relevant to multisampling). No other modifiers supported.
dcl %s# only supports the _centroid modifier (optional hint), and/or _pp modifier (partial precision hint). No other modifiers supported.
dcl can't specify empty writemask.
dcl for %s register does not support any modifiers. 
dcl for input v# register must specify usage+index (semantic). i.e. dcl_texcoord5 v%d. Note that the semantics position0, positiont0, psize0, tessfactor(n) and sample(n) are not permitted.
dcl instruction is missing a parameter.
dcl instruction should have exactly 2 parameter tokens.  Aborting validation.
dcl must specify full writemask in this shader version (same as not specifying mask) for %s# registers.
dcl must specify non-empty mask.
dcl usage index, %d, is too high.  Max allowed is %d.
dcl usage 'sample' is not avaliable to the pixel shader. 
dcl usage 'tessfactor' is not avaliable to the pixel shader. 
dcl usage 'tessfactor' is not permitted for vertex input shaders.
dcl usage 'tessfactor' is not permitted for vertex shader input registers.
dcl usage: %s%d has already been specified.
dcl usage+index positiont0 cannot be used in a pixel shader.
dcl usage+index psize0 cannot be used in a pixel shader.
dcl usage+index: %s,%d has already been specified for an input register.
dcl usage+index: %s,%d has already been specified for an output register.
dcl_constantbuffer
dcl_func_output(a) -> o->append_dataflow() <| SMR.DataflowAnalysis
dcl_function_body
dcl_function_table
dcl_globalFlags
dcl_gsinstances
dcl_hs_fork_phase_instance_count
dcl_hs_join_phase_instance_count
dcl_hs_max_tessfactor
dcl_immediateConstantBuffer
dcl_indexableTemp
dcl_indexrange
dcl_input
dcl_input_control_point_count
dcl_input_ps
dcl_input_ps_sgv
dcl_input_ps_siv
dcl_input_sgv
dcl_input_siv
dcl_inputprimitive
dcl_interface
dcl_maxout
dcl_output
dcl_output_control_point_count
dcl_output_sgv
dcl_output_siv
dcl_outputtopology
dcl_resource
dcl_resource_raw
dcl_resource_structured
dcl_sampler
dcl_stream
dcl_temps
dcl_tessellator_domain
dcl_tessellator_output_primitive
dcl_tessellator_partitioning
dcl_tgsm_raw
dcl_tgsm_structured
dcl_thread_group
dcl_uav_raw
dcl_uav_structured
dcl_uav_typed
ddiv float_literal <| SFPS
ddiv fp_flags <| SFPS
ddiv fp_range <| SFPS
ddiv fp_specials <| SFPS
ddx_coarse
ddx_fine
ddy_coarse
ddy_fine
debug info exceeds maximum comment size; no debug info emitted
debug info for optimized code
Debug instructions are unsupported in shader libraries
debug_break
DEBUGMONITORTOKEN
DebugSetMute
decimal value truncated to 64 bits
Declaration for register %s%d overlaps previous declaration for the following component(s) of the same register (*): %s
Declaration statements in HS Control Point phase must appear before other instructions.
Declaration statements in HS Fork phase must appear before other instructions.
Declaration statements in HS Join phase must appear before other instructions.
Declaration statements must appear before other instructions.
Declared output vertex count (%d) multiplied by the total number of declared scalar components of output data (%d) equals %d.  This value cannot be greater than %d.
Declared Thread Group Count %d (X*Y*Z) is beyond the valid maximum of %d for Compute Shader version < 5_0.  Opcode #%d (count is 1-based). 
Declared Thread Group Count %d (X*Y*Z) is beyond the valid maximum of %d.  Opcode #%d (count is 1-based). 
Declared Thread Group X size %d outside valid range [%d..%d] for Compute Shader version < 5_0.  Opcode #%d (count is 1-based). 
Declared Thread Group X size %d outside valid range [%d..%d].  Opcode #%d (count is 1-based). 
Declared Thread Group Y size %d outside valid range [%d..%d] for Compute Shader version < 5_0.  Opcode #%d (count is 1-based). 
Declared Thread Group Y size %d outside valid range [%d..%d].  Opcode #%d (count is 1-based). 
Declared Thread Group Z size %d outside valid range [%d..%d].  Opcode #%d (count is 1-based). 
DECR_SAT
DecrementCounter
DECRSAT
def and dcl instructions must appear before other instructions.
def or dcl instructions must appear before other instructions.
def32
default
default statement doesn't match to the scope of a switch statement. Opcode #%d (count 1-based). Aborting validation.
default statement seen already.  Opcode #%d (count 1-based).
default value
DEFGH
defghijklmnopqrstuvw
define
defined
degrees
delete
DeleteCriticalSection
DeleteFileW
DENY_DOMAIN_SHADER_ROOT_ACCESS
DENY_GEOMETRY_SHADER_ROOT_ACCESS
DENY_HULL_SHADER_ROOT_ACCESS
DENY_PIXEL_SHADER_ROOT_ACCESS
DENY_VERTEX_SHADER_ROOT_ACCESS
Dependent tex-op sequence too long (%dth order). A 1st order dependent tex-op is a tex[ld*|kill] instruction in which either: (1) an r# reg is input (NOT t# reg), or (2) output r# reg was previously written, now being written AGAIN. A 2nd order dependent tex-op occurs if: a tex-op reads OR WRITES to an r# reg whose contents, BEFORE executing the tex-op, depend (perhaps indirectly) on the outcome of a 1st order dependent tex-op. An (n)th order dependent tex-op derives from an (n-1)th order tex-op. A given tex-op may be dependent to at most 3rd order (ps_2_0/x only).
Deprecated DX9 state '%s' is being ignored for %s
Deprecated DX9 state '%s' is being ignored for %s; use state '%s' instead
depth
Depth
DEPTH
DEPTH must be a scalar
Depth of dynamic 'if' nesting exceeds limit of %d (callnz with predicate counts as a dynamic 'if' nesting level). Aborting shader validation. 
Depth of dynamic 'if' nesting exceeds limit of %d, due to break_cmp that counts towards same limit. Aborting shader validation. 
Depth of dynamic 'if' nesting exceeds limit of %d. Aborting shader validation. 
Depth of loop nesting exceeds limit of %d. Aborting shader validation. 
Depth of static 'if' nesting exceeds limit of %d. Aborting shader validation. 
Depth of subroutine call nesting exceeds limit of %d. Aborting shader validation. 
DepthBias
DEPTHBIAS
DepthBiasClamp
DepthClipEnable
DepthEnable
DepthFunc
DEPTHGE
DEPTHLE
DepthStencil
DepthStencilState
DepthStencilView
DepthWriteMask
deriv_rtx
deriv_rtx_coarse
deriv_rtx_fine
deriv_rty
deriv_rty_coarse
deriv_rty_fine
Derivative being used before it was defined. consider moving the derivative assignment earlier in the program.
Derivative is not defined in a different branch of flow-control. Consider moving the derivative assignment before any flow control statements.
Derivatives of indexed variables are not yet implemented.
Derivatives of known values are unimplemented.
Descriptor range (descriptor table slot [%u], root parameter [%u]) overlaps with another incompatible descriptor range.
Descriptor range flag values can only be 0 or flag enum values, found: '%s'
Descriptor range flags cannot be specified for root_sig_1_0
Descriptor range flags cannot specify DESCRIPTORS_VOLATILE with the DATA_STATIC flag at the same time (descriptor range flags %x). DATA_STATIC_WHILE_SET_AT_EXECUTE is fine to combine with DESCRIPTORS_VOLATILE, since DESCRIPTORS_VOLATILE still requires descriptors don't change during execution. 
Descriptor range flags cannot specify more than one DATA_* flag at a time (descriptor range flags %x).
Descriptor range flags cannot specify more than one DESCRIPTOR_* flag at a time (descriptor range flags %x).
DESCRIPTOR_RANGE_OFFSET_APPEND
DESCRIPTORS_STATIC_KEEPING_BUFFER_BOUNDS_CHECKS
DESCRIPTORS_VOLATILE
DescriptorTable
Dest for SINCOS must be a temp (r#) register.
Dest mask for SINCOS must be one of: .x | .y | .xy 
Dest parameter can't specify min precision unless shader is from D3D10+ target.
Dest register cannot be the same as first source register for m*x* instructions.
Dest register for CRS cannot be the same as a source register.
Dest register for LRP cannot be the same as first or third source register.
Dest register for m*x* instructions cannot be the same as one of the additional registers implied by the second source register.
Dest register for POW cannot be the same as second source register.
Dest register for SINCOS cannot be the same as first source register.
Dest register relative index indexable-temp register component %d in x[%d][%d] uninitialized. Opcode #%d (count is 1-based)
Dest register relative index temp register component %d in r%d uninitialized. Opcode #%d (count is 1-based)
Dest register type for CRS must be temp (r#).
Dest register type for LRP must be temp (r#).
Dest register type for NRM must be temp (r#).
Dest register type for POW must be temp (r#).
Dest register type for SINCOS must be temp (r#).
Dest shift not allowed for tex* instructions.
Dest shifts not allowed for vertex shaders.
Dest write mask cannot be empty.
Dest write mask must be .rgb, .a, or .rgba (all).
Dest write mask must be .rgb, or .rgba (all) for dp3.
Dest writemask for NRM must be .xyzw (default) or .xyz (or equivalent rgba notation)
Dest writemask for SINCOS must be .xy, .x or .y.
DEST_ALPHA
DEST_COLOR
DESTALPHA
DestBlend
DESTBLEND
DESTBLENDALPHA
DestBlendAlpha
DESTCOLOR
destination
Destination for def instruction must be c# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine).
Destination for def instruction must be of the form c# (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine).
Destination for defb instruction must be b# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine).
Destination for defi instruction must be i# register (where # = reg number). In addition there may be no mask (equivalent to full .xyzw, which is fine).
Destination for texdepth must be r5.
Destination of texm3x2depth instruction (t%d) is not available elsewhere in shader.
Destination shift not allowed for tex* instructions.
detect errors induced by race conditions <| Explicit
determinant
DeviceIoControl
DeviceMemoryBarrier
DeviceMemoryBarrierWithGroupSync
dfma fp_flags <| SFPS
dfma fp_specials <| SFPS
dfuse float_literal <| SFPS
dfuse fp_flags <| SFPS
dfuse fp_specials <| SFPS
Different relative addressing of constant registers cannot be combined in one instruction.
Different relative addressing of input registers cannot be combined in one instruction.
DIFFUSE
Diffuse
DIFFUSEMATERIALSOURCE
dimension of conditional does not match value
DIRECT3D
Direct3D HLSL Compiler
Direct3D9: Shader Validator: 
DIRECTIONAL
disable
DISABLE
DisableThreadLibraryCalls
discard
discard_endif(a,b) -> append_arg(a,b,p_a) <| SMR.DataFlagAnalysis_PlaceHolder
discardable
discardif fp_flags <| SFPS
DISCRETE
distance
DITHERENABLE
div float_literal <| SFPS
div fp_flags <| SFPS
div fp_range <| SFPS
div fp_specials <| SFPS
div(a,b)->mul(a, rcp(b)) <| MR.Gen_RequiredTranslate
divide
division by a literal becomes multiplication by reciprocal <| MR.GenSimplifyInstructionsOpt1_NoExcl
division by zero in preprocessor expression
dmad -> dmul, dadd <| MR.Gen_RequiredTranslate
dmad float_literal <| SFPS
dmad fp_flags <| SFPS
dmad fp_range <| SFPS
dmad fp_specials <| SFPS
DMAPOFFSET
dmax 0/dmin 1 -> dsat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
dmax float_literal <| SFPS
dmax fp_flags <| SFPS
dmax fp_range <| SFPS
dmax fp_specials <| SFPS
dmax(dmax(i0, l1), l2) -> dmax(i0, dmax(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmax(i, dneg(i)) -> dabs <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
dmax(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmax(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmin 1/dmax 0 -> dsat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
dmin float_literal <| SFPS
dmin fp_flags <| SFPS
dmin fp_range <| SFPS
dmin fp_specials <| SFPS
dmin(dmin(i0, l1), l2) -> dmin(i0, dmin(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmin(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmin(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmov fp_flags <| SFPS
dmov mov <| SFPS
dmovc
dmovc float_literal <| SFPS
dmovc fp_flags <| SFPS
dmovc fp_specials <| SFPS
dmovc(!a,b,c) -> dmovc(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc((a<b),b,a) -> dmax(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc((a>=b),a,b) -> dmax(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(a,b,b) -> dmov(b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(bdlt(a, 0), |a|, a) -> dabs(a) <| MR.GenD3D10PreMod_NoExcl
dmovc(c,a,ignore) -> dmov(a) <| MR.GenSimplifyInstructionsAlways_Both
dmovc(c,ignore,a) -> dmov(a) <| MR.GenSimplifyInstructionsAlways_Both
dmovc(c,ignore,ignore) -> ignore(0) <| MR.GenSimplifyInstructionsAlways_Both
dmovc(false,b,c) -> dmov(c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmovc(true,b,c) -> dmov(b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dmul float_literal <| SFPS
dmul fp_flags <| SFPS
dmul fp_range <| SFPS
dneg float_literal <| SFPS
dneg fp_flags <| SFPS
dneg fp_range <| SFPS
dneg fp_specials <| SFPS
Do not reduce literals in no-opt compiles <| Explicit
Do not reduce switches in no-opt compiles <| Explicit
Do not remove unaliasable array loads in no-opt compiles <| Explicit
domain
DOMAIN
Domain Shader input control point count already declared. Aborting.  Opcode #%d (count is 1-based). 
Domain Shader input vDomain must be declared with at most a .xy mask when the domain is ISOLINE.
Domain Shader input vDomain must be declared with at most a .xy mask when the domain is QUAD.
Domain Shader input vDomain must be declared with at most a .xyz mask when the domain is TRI.
Domain Shader must declare a tessellator domain.
Domain Shader must declare an input control point count.
domain type
DomainShader
Don't flush denorm values to zero <| Explicit
Don't truncate double values to floats <| Explicit
Don't use marker values for clamped literal conversions <| Explicit
dot float_literal <| SFPS
dot fp_flags <| SFPS
dot fp_range <| SFPS
dot of partial nullity reduction <| Explicit
dot(normalized_v, normalized_v) == 1.0 when v has length <| MR.GenSimplifyInstructionsOpt1_NoExcl
Dot-product needs color/vector pipeline to execute, so instruction co-issued with it cannot write to color components.
Dot-product which writes alpha cannot co-issue, because both alpha and color/vector pipelines used.
DOTPRODUCT3
double
double add of zero identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
double d(1/x)/dz -> -dx/dz/x^2 <| SR.GenDerivatives_Unary
double drcp identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
double negative to original <| MR.GenSimplifyInstructionsOpt1_NoExcl
Double operations not supported unless globalFlags includes enableDoublePrecisionFloatOps.
double rcp identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
Double-precision extensions for 11.1
Double-precision floating point
double-precision floating point division by zero
doubles cannot be used as shader inputs or outputs. If you need to pass a double between shader stages you must pass it as two uints and use asuint and asdouble to convert between forms
dp2add
dp3 which writes alpha cannot co-issue since it uses up both the alpha and color pipes.
dp4 cannot be coissued.
dp4 instruction cannot be co-issued.
drcp_approx float_literal <| SFPS
drcp_approx fp_flags <| SFPS
drcp_approx fp_range <| SFPS
drcp_approx fp_specials <| SFPS
ds_%d_%d
ds_5_0
ds_5_1
DS_StencilRef
dsat float_literal <| SFPS
dsat fp_flags <| SFPS
dsat fp_range <| SFPS
dsplit fp_flags <| SFPS
dsplit fp_specials <| SFPS
dsplit int_literal <| SFPS
Dst modifiers not allowed for vertex shaders.
dsx float_literal <| SFPS
dsx fp_flags <| SFPS
dsx fp_range <| SFPS
dsx fp_specials <| SFPS
dsx_coarse float_literal <| SFPS
dsx_coarse fp_flags <| SFPS
dsx_coarse fp_range <| SFPS
dsx_coarse fp_specials <| SFPS
dsx_fine float_literal <| SFPS
dsx_fine fp_flags <| SFPS
dsx_fine fp_range <| SFPS
dsx_fine fp_specials <| SFPS
dsy float_literal <| SFPS
dsy fp_flags <| SFPS
dsy fp_range <| SFPS
dsy fp_specials <| SFPS
dsy(x)/dz -> dsy(dx/dz) <| SR.GenDerivatives_Unary
dsy_coarse float_literal <| SFPS
dsy_coarse fp_flags <| SFPS
dsy_coarse fp_range <| SFPS
dsy_coarse fp_specials <| SFPS
dsy_fine float_literal <| SFPS
dsy_fine fp_flags <| SFPS
dsy_fine fp_range <| SFPS
dsy_fine fp_specials <| SFPS
dtof float_literal <| SFPS
dtof fp_flags <| SFPS
dtof fp_range <| SFPS
dtof fp_specials <| SFPS
dtof(ftod(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
-dtof(x) -> dtof(-x) <| MR.GenSimplifyInstructionsOpt1_Excl
dtof(x)/dz -> dtof(dx/dz) <| SR.GenDerivatives_Unary
dtoi fp_flags <| SFPS
dtoi int_literal <| SFPS
dtoi int_range <| SFPS
dtoi(itod(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
dtou fp_flags <| SFPS
dtou int_literal <| SFPS
dtou int_range <| SFPS
dtou(utod(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
duplicate attribute %s
duplicate macro parameter '%s'
Duplicate non-system value semantic definition: %s and %s
Duplicate system value semantic definition: %s and %s
duplicate usage semantic ignored
duplicate usages specified
Duplicated input semantics can't change type, size, or layout ('%s').
dword
DX9 state '%s' is not supported in %s; convert to '%s' or use compatibility mode to ignore
DX9 state '%s' is not supported in %s; use compatibility mode to ignore
DX9-style '= sampler_state' syntax is deprecated in strict mode
DX9-style assignment syntax is deprecated in technique10 pass blocks in favor of new function call syntax
DX9-style 'compile' syntax is deprecated in strict mode
DX9-style intrinsics are disabled when not in dx9 compatibility mode.
DX9-style 'LHS = <RHS>' syntax is deprecated in strict mode
DXBCPQ
dynamic instruction count calculated by training
dynamic_cast
E #E$
E )E$)E
E :E@r
E ;E@|}
E SVW
E SVWPh
E$:E(
E$^_[
E(SVW
E,_^[
e0e0e0
E4_^[
Earlier texld instruction used _dz(=_db) modifier on source param. When a phase marker is present, the _dz modifier is only permitted after the phase marker.
Early depth-stencil
earlydepthstencil
edge count between a caller/callee and it's parent
EditAndContinueEnabled
Effect file is too large, try reducing the number of techniques or compiling without debug info
Effects deprecated for D3DCompiler_47
element type of texture too large. Cannot exceed 4 components
ELEMENTINDEX
elements
elements of typed buffers and textures cannot be arrays
elements of typed buffers and textures must fit in four 32-bit quantities
'else' already used for current 'if' construct. Aborting shader validation. 
'else' instruction does not match up to an 'if'. Aborting shader validation. 
else statement doesn't match to an if statement. Opcode #%d (count 1-based). Aborting validation.
else statement seen already.  Opcode #%d (count 1-based). Aborting validation.
EMISSIVEMATERIALSOURCE
Emit output arrays <| Explicit
Emit return instructions <| Explicit
emit write masks on sample instructions <| Explicit
emit_stream
emit_then_cut
emit_then_cut_stream
emitting a system-interpreted value which is not written in every execution path of the shader. Unconditional initialization may help. <| A%u (B%u)
emitting a system-interpreted value which may not be written in every execution path of the shader <| A%u (B%u)
enable instancing searches for programs with multiple outputs <| Explicit
enable11_1DoubleExtensions
enable11_1ShaderExtensions
ENABLEADAPTIVETESSELLATION
enableDoublePrecisionFloatOps
enableMinimumPrecision
enableRawAndStructuredBuffers
enableRawAndStructuredBuffers global flag can't be used (not needed) with Compute Shaders.  Opcode #%d (count is 1-based). 
end of file
end of line
End of program reached with incomplete flow control structure.
End of shader reached and '%s' construct was not completed with a '%s'. 
End of shader reached and 'if' construct was not completed with 'else'/'endif'. 
End of shader reached and rep construct was not completed with an endrep. 
End of shader reached without 'ret' to terminate subroutine.
endif
'endif' instruction does not match up to an 'if' or 'else'. Aborting shader validation. 
endif statement doesn't match to an if statement. Opcode #%d (count 1-based). Aborting validation.
endif(a,b) -> append_arg(a,b) <| SMR.RangeDataAnalysis
endif(a,b) -> append_arg(a,b,p_a) <| SMR.DataFlagAnalysis
endloop
'endloop' instruction does not match up to an 'loop'. Aborting shader validation. 
endloop statement doesn't match to a loop statement. Opcode #%d (count 1-based). Aborting validation.
endrep
'endrep' instruction does not match up to a 'rep'. Aborting shader validation. 
endswitch
endswitch statement doesn't match to a switch statement. Opcode #%d (count 1-based). Aborting validation.
EnterCriticalSection
entrypoint
EQUAL
error
error count exceeds %u, aborting
Error creating error string
error location reached from this location
error, duplicate case %u
error, duplicate default in switch statement
error: %s
Error: constant buffer %s has both user-defined offset and compiler-assigned offsets
Error: Effects expression assembly in invalid format!
Error: Effects expression assembly not found!
Error: Error getting Effects expression constant table.
Error: Error getting Effects expression literal block.
Error: Error getting texture shader literal block.
ERROR: Semantic %s is not supported in fx_4_1.
Error: Texture shader assembly not found!
Error: unexpected end of buffer
errorf
errorf 
eval bne on non-nan value <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval eq <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval ge <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval lt <| MR.GenSimplifyInstructionsOpt1_NoExcl
eval mul <| Explicit
Eval range add inf flag if range not bound <| Explicit
Eval range add NaN flag if integer mask says it's possible <| Explicit
eval(
eval_centroid
eval_centroid fp_flags <| SFPS
eval_sample fp_flags <| SFPS
eval_sample_index
eval_snapped
eval_snapped fp_flags <| SFPS
EvaluateAttributeAtSample
EvaluateAttributeCentroid
EvaluateAttributeSnapped
Even Fractional
Exceeded maximum number or index of output registers. Max allowed for this target is %d.
execute
Execute allowed.
exp float_literal <| SFPS
exp fp_flags <| SFPS
exp fp_range <| SFPS
exp fp_specials <| SFPS
exp(a*log(0)) = 0 identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
exp(log(x)) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
ExpandEnvironmentStringsW
expected %s parameter to be %s, got '%s'
Expected ',', found: '%s'
Expected a component mask which picks any one or 2 components for operand #%d of opcode #%d (counts are 1-based). 
Expected a descriptor range flag value, found: '%s'
Expected a register token (CBV, SRV, UAV, Sampler), found: '%s'
Expected a root descriptor flag value, found: '%s'
Expected a root signature flag value, found: '%s'
Expected component count of 0 for operand #%d of opcode #%d (counts are 1-based). 
Expected component count of 1 (or 4 component with select-1 mode) for operand #%d of opcode #%d (counts are 1-based). 
Expected component count of 4 (or 1 component immediate32, or in certain cases NULL or scalar operand allowed) for operand #%d of opcode #%d (counts are 1-based). 
Expected contiguous component mask starting at x (.x, .xy, .xyz, or .xyzw) for operand #%d of opcode #%d (counts are 1-based). 
Expected double-compatible component mask (xy, zw, or xyzw) for operand #%d of opcode #%d (counts are 1-based). 
Expected double-compatible swizzle for operand #%d of opcode #%d (counts are 1-based). 
Expected nonzero component mask (or in certain cases also NULL or single component output operand allowed) for operand #%d of opcode #%d (counts are 1-based). 
Expected relative address token.  Aborting validation.
Expected sample count > 0 but encountered %d for resource t%d.  Opcode #%d (count is 1-based). 
Expected sample count of 0 but encountered %d for resource t%d.  Opcode #%d (count is 1-based). 
Expected single component mask (or in certain cases also NULL or single component output operand allowed) for operand #%d of opcode #%d (counts are 1-based). 
explicit
export
export has explicitly assigned ordinal
export is CONSTANT
export is DATA
export is forwarder
export is NONAME
export is PRIVATE
export ordinal
expression has a minimum precision type and cannot be marked precise <| A%u (B%u), I%u (B%u)
expressions returning objects in an array or struct not yet implemented
expressions with side effects are illegal as attribute parameters
Extended 11.1 double operations not supported unless globalFlags includes enable11_1DoubleExtensions.
Extended 11.1 shader operations not supported unless globalFlags includes enable11_1ShaderExtensions.
extern
F ;A 
F ;B w
F ;B(
F @9C v'
F +G _^
f!F 3
f!G 3
F!T$ !D$
F$;F,s%
F$_^[
F(;G$uX
F(;G(w8r,;
F(_^[
F,tC3
f;^0vD
f;9ta
f;A@u#
f;C s@
f;C$ui
f;D$(w
f;E(r%w
f;F$u7
F;K,r
f;K0s
F;p0r
f;S@u
f;S0r
F;slr
F;t$$r
F;t$4r
F;t$hr
F;t$lr
F;t$pr
F;u r
F;w r
F;w@r
F<;A<s
F<;B<s
F<;C<s
F<9C<
F0;F8
F0;G,uP
F0;xDs
F0;xds
F0_^[
F0+F,
F0A+F,
F0SWP
F0t-3
f16tof32
f16tof32 bits_known <| SFPS
f16tof32 float_literal <| SFPS
f16tof32 fp_flags <| SFPS
f16tof32(i) -> conversion sequence <| MR.Gen_RequiredTranslate
f32tof16
f32tof16 fp_flags <| SFPS
f32tof16 int_literal <| SFPS
f32tof16 int_range <| SFPS
f32tof16(i) -> conversion sequence <| MR.Gen_RequiredTranslate
f3C f
F4;F<
F8;F<
F8;F<r
F8A;N4r
f9A4u/f
f9F4u
f9H"u 
f9P"u
faceforward
Failed compiling 10_level_9 PS version of the library function '%s'.
Failed compiling 10_level_9 VS version of the library function '%s'.
Failed to extract driver shader code.
Failed to extract input signature.
Failed to extract output signature.
Failed to extract patch constant signature.
Failed to log error, redirecting to debug output:
failed to open source file: '%s'
Failed to parse shader using reference shader parser: 0x%x
Fall-throughs in switch statements are not allowed.
false
far return
fastopt
fcall
fcall fp_flags <| SFPS
fcall statement not referencing an interface.  Opcode #%d (count 1-based).
fcall statement referencing an out of bounds function index (%d).  Opcode #%d (count 1-based).
fcall statement referencing an undeclared interface (%d).  Opcode #%d (count 1-based).
fcbody fp_flags <| SFPS
FCIAddFile
FCICreate
FCIDestroy
FCIFlushCabinet
Fd;Fhu
FDICopy
FDICreate
FDIDestroy
feature
FFACE
ffff40
FH;GHu
FH[_^
FH_[^
FH_^[
fHasEH
fHasSEH
FHSW3
FileDescription
fileName
FileVersion
FillMode
FILLMODE
FILTER
filter
Filter
FILTER_ANISOTROPIC
FILTER_COMPARISON_ANISOTROPIC
FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT
FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR
FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT
FILTER_COMPARISON_MIN_MAG_MIP_LINEAR
FILTER_COMPARISON_MIN_MAG_MIP_POINT
FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR
FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT
FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR
FILTER_MAXIMUM_ANISOTROPIC
FILTER_MAXIMUM_MIN_LINEAR_MAG_MIP_POINT
FILTER_MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR
FILTER_MAXIMUM_MIN_MAG_LINEAR_MIP_POINT
FILTER_MAXIMUM_MIN_MAG_MIP_LINEAR
FILTER_MAXIMUM_MIN_MAG_MIP_POINT
FILTER_MAXIMUM_MIN_MAG_POINT_MIP_LINEAR
FILTER_MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT
FILTER_MAXIMUM_MIN_POINT_MAG_MIP_LINEAR
FILTER_MIN_LINEAR_MAG_MIP_POINT
FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR
FILTER_MIN_MAG_LINEAR_MIP_POINT
FILTER_MIN_MAG_MIP_LINEAR
FILTER_MIN_MAG_MIP_POINT
FILTER_MIN_MAG_POINT_MIP_LINEAR
FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT
FILTER_MIN_POINT_MAG_MIP_LINEAR
FILTER_MINIMUM_ANISOTROPIC
FILTER_MINIMUM_MIN_LINEAR_MAG_MIP_POINT
FILTER_MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR
FILTER_MINIMUM_MIN_MAG_LINEAR_MIP_POINT
FILTER_MINIMUM_MIN_MAG_MIP_LINEAR
FILTER_MINIMUM_MIN_MAG_MIP_POINT
FILTER_MINIMUM_MIN_MAG_POINT_MIP_LINEAR
FILTER_MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT
FILTER_MINIMUM_MIN_POINT_MAG_MIP_LINEAR
final static size of live function, after inlining
finalLine*TessFactor requires ISOLINE tessellator domain.  Opcode #%d (count is 1-based). 
finalLineDensityTessFactor
finalLineDensityTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalLineDensityTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalLineDetailTessFactor
finalLineDetailTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalLineDetailTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuad*TessFactor requires QUAD tessellator domain.  Opcode #%d (count is 1-based). 
finalQuadUeq0EdgeTessFactor
finalQuadUeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadUeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadUeq1EdgeTessFactor
finalQuadUeq1EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadUeq1EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadUInsideTessFactor
finalQuadUInsideTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadUInsideTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadVeq0EdgeTessFactor
finalQuadVeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadVeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadVeq1EdgeTessFactor
finalQuadVeq1EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadVeq1EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalQuadVInsideTessFactor
finalQuadVInsideTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalQuadVInsideTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalTri*TessFactor requires TRI tessellator domain.  Opcode #%d (count is 1-based). 
finalTriInsideTessFactor
finalTriInsideTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalTriInsideTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalTriUEdgeTessFactor
finalTriUeq0EdgeTessFactor
finalTriUeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalTriUeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalTriVEdgeTessFactor
finalTriVeq0EdgeTessFactor
finalTriVeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalTriVeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finalTriWEdgeTessFactor
finalTriWeq0EdgeTessFactor
finalTriWeq0EdgeTessFactor already declared for input.  Opcode #%d (count is 1-based). 
finalTriWeq0EdgeTessFactor already declared for output.  Opcode #%d (count is 1-based). 
finite a + -a -> append_arg(0) <| SMR.RangeDataAnalysis
first
First arithmetic instruction cannot have co-issue ('+') set; there is no previous arithmetic instruction to pair with.
First source for cnd instruction must be 'r0.a'.
First source param for SGN cannot be the same register as the second or third params.
First source parameter for bem must be temp (r#) or constant (c#) register.
First source parameter for texld can't specify min precision unless shader is from D3D10+ target.
First source parameter for texld must be temp (r#) or texture coordinate input(t#) register.
First source parameter for texld* must be temp (r#), input (v#) or constant (c#) register.
First source parameter for texldl must be temp (r#), input (v#) or const (c#) register.
firstbit*(x) != -1 -> x != 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
firstbit*(x) == -1 -> x == 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
firstbit_hi
firstbit_hi bits_known <| SFPS
firstbit_hi fp_flags <| SFPS
firstbit_hi int_literal <| SFPS
firstbit_hi(i) -> shift/bine/add sequence <| MR.Gen_RequiredTranslate
firstbit_lo
firstbit_shi
firstbit_shi bits_known <| SFPS
firstbit_shi fp_flags <| SFPS
firstbit_shi int_literal <| SFPS
firstbit_shi(i) -> shift/bine/add sequence <| MR.Gen_RequiredTranslate
firstbithigh
firstbitlow
firstbitlow bits_known <| SFPS
firstbitlow fp_flags <| SFPS
firstbitlow int_literal <| SFPS
firstbitlow(i) -> shift/bine/add sequence <| MR.Gen_RequiredTranslate
FIXUP
FkF3PQL
FL;GLu
Flag specified was exclusively a parse flag and not a compile flag
flags
Flags parameter is invalid
Flags specified both compatibility and strict mode. These are mutually exclusive
flatten
float
float '%g'
float '%gf'
float '%gh'
float '%gl'
float constant
float d(1/x)/dz -> -dx/dz/x^2 <| SR.GenDerivatives_Unary
float1
float1x1
float1x2
float1x3
float1x4
float2
float2x1
float2x2
float2x3
float2x4
float3
float3x1
float3x2
float3x3
float3x4
float4
float4x1
float4x2
float4x3
float4x4
floating point division by zero
floating-point value out of integer range for conversion: %f
floating-point value out of unsigned range for conversion: %f
floor
floor float_literal <| SFPS
floor fp_flags <| SFPS
floor fp_range <| SFPS
floor fp_specials <| SFPS
flow control depth too deep to emit function call
flow control depth too deep to honor call or forcecase attribute
FlushViewOfFile
fma can only be used with double arguments
FOG must be a scalar
FOGCOLOR
FOGDENSITY
FOGENABLE
FOGEND
FOGSTART
FOGTABLEMODE
FOGVERTEXMODE
for better compilation results, consider re-enabling rule "%s"
for better compilation results, consider re-enabling rule 0x%08x
For Compute Shader versions < 5_0, the element count for all Structured Thread Group Shared Memory declarations 
For Compute Shader versions < 5_0, with %d threads in a group, at most %d bytes per thread of Thread Group Shared Memory 
For ps_1_2 or ps_1_3, the cmp or dp4 instructions cannot have a source register the same as the destination register.
forcecase
forced to unroll loop, but unrolling failed.
ForceDebuggable
forceEarlyDepthStencil
ForceShaderSkipOptimization
Format
Format for address register must be a0.x.
fourth
Fp;Fdu
Fp;Fht
fractional_even
fractional_odd
fragment info exceeds maximum comment size
Frame data for enclosing function.
frame pointer present
frame size
Frame.
FrameData
frameFunc
frc float_literal <| SFPS
frc fp_flags <| SFPS
frc fp_range <| SFPS
frc fp_specials <| SFPS
FRC of add with integer can bypass add <| Explicit
frc(a + int) = frc(a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
FreeLibrary
frexp
friend
FRONT
FrontCounterClockwise
FrontEndBuild
FrontEndMajor
FrontEndMinor
FrontEndQFE
FrontFaceStencilDepthFail
FrontFaceStencilFail
FrontFaceStencilFunc
FrontFaceStencilPass
FT t.
FT t/
FT tY
FT;GTs
FT@;FP
FT@t;Q
FT@t<Q
FT@tY
FT3GT
FtAon9$
ftob fp_flags <| SFPS
ftob int_literal <| SFPS
ftob int_range <| SFPS
ftob(trunc(btof(x))) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftod float_literal <| SFPS
ftod fp_flags <| SFPS
ftod fp_range <| SFPS
ftod fp_specials <| SFPS
-ftod(x) -> ftod(-x) <| MR.GenSimplifyInstructionsOpt1_Excl
ftod(x)/dz -> ftod(dx/dz) <| SR.GenDerivatives_Unary
ftoi fp_flags <| SFPS
ftoi int_literal <| SFPS
ftoi int_range <| SFPS
ftoi(itof(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ftou fp_flags <| SFPS
ftou int_literal <| SFPS
ftou int_range <| SFPS
ftou(utof(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
FtXNAP
FtXNAS
funcStart
Function
function
function '%s' missing implementation
function body (%d) already declared. Opcode #%d (count 1-based). 
function body (%d) defined without being declared. Opcode #%d (count 1-based). 
function body (%d) referenced without being defined. Opcode #%d (count 1-based). 
function body (%d) was never defined.
function body (%d) was never referenced.
function name
function parameters
function table (%d) already declared. Opcode #%d (count 1-based). 
function table (%d) was declared, but never referenced.
function_endif(a) -> append_arg(a, pred_a) <| SMR.DataFlagAnalysis
function_endif(a,b) -> append_arg(a,b,p_a) <| SMR.DataFlagAnalysis
functional defines in preprocessor expressions not yet implemented
functionif fp_flags <| SFPS
functionStart
fUsesBP
FVWVWh
fw,tW
fwidth
FX_^[]
fx_2_0
fx_4_0
fx_4_1
fx_5_0
fxgroup
fxl_2_0
fxl_4_0
FXLCt$A;
G ;A s
G ;C 
G ;C s
G ;C s"A;
G ;C u
G ;F u7
G ;F uM
G _^[
G _^Y]
G +B 
G$;C$u0
G$;F$u/
G(;F(u
G,:F,uE
G,;C,uF
G,^_[
G,3C,#G$
G;{ r
G;{PsN;U
G;|$,r
G;|$\r
G;|$Xr
G;~(r
G;~,r
G;~@r
G;~4r
G@;C@t
G@QPh
G@QPj
G<;A<s
G<;C<s
G<;C<u
G0;Ads
G0;B0tj
G0;F0u=
G0;G8u
G0;w(u
G0+G,
G0SVP
G0u0S
G4;F4u5
G4;G<t
G4;G<u
G8;C8u
G8+G4
G82C8$
Gather
gather2d fp_flags <| SFPS
gather2d_a fp_flags <| SFPS
gather2d_a_o fp_flags <| SFPS
gather2d_a_o_s fp_flags <| SFPS
gather2d_o fp_flags <| SFPS
gather2d_o_s fp_flags <| SFPS
gather4
gather4_c
gather4_c_s
gather4_po
gather4_po_c
gather4_po_c_s
gather4_po_s
gather4_s
GatherAlpha
GatherAlpha requires shader model 5 or higher
GatherBlue
GatherBlue requires shader model 5 or higher
GatherCmp
GatherCmpAlpha
GatherCmpBlue
GatherCmpGreen
GatherCmpRed
gathercube fp_flags <| SFPS
gathercube_a fp_flags <| SFPS
gathercube_a_s fp_flags <| SFPS
gathercube_c fp_flags <| SFPS
gathercube_c_a fp_flags <| SFPS
gathercube_c_a_s fp_flags <| SFPS
gathercube_c_s fp_flags <| SFPS
gathercube_s fp_flags <| SFPS
GatherGreen
GatherGreen requires shader model 5 or higher
GatherRed
GAUSSIANQUAD
GD t\V
GD+G@
GD+O@+G@
GDuV=
ge float_literal <| SFPS
ge fp_flags <| SFPS
ge fp_range <| SFPS
ge of known range reduction <| Explicit
ge(a, b) -> cmp(a - b, 1f, 0f) <| MR.Gen_RequiredTranslate
GenerateMips
GenerateMips is not supported in %s
GEOMETRY
GeometryShader
GetCurrentProcess
GetCurrentProcessId
GetCurrentThreadId
GetDimensions
GetEnvironmentVariableA
GetFileAttributesW
GetFileSize
GetFileSizeEx
GetFileType
GetFullPathNameA
GetFullPathNameW
GetLastError
GetModuleFileNameA
GetModuleHandleW
GetProcAddress
GetProcessHeap
GetRenderTargetSampleCount
GetRenderTargetSamplePosition
GetSamplePosition
GetSystemInfo
GetSystemTimeAsFileTime
GH_^[
Gh+Gd
GH+GD
GHt(R
GHWXYZ
GL;FLv
Global flags already declared once.  Opcode #%d (count is 1-based). 
global variables
global variables are implicitly constant, enable compatibility mode to allow modification
global variables are implicitly constant, variables of classes with interface inheritance can never be modified
globallycoherent
globallycoherent can only be used with Unordered Access View buffers
globallycoherent cannot be used with append/consume buffers
GOURAUD
Gp;Gh
GP+GL
GP+GLt
GP9u v>
GPSj`
gradient instruction used in a loop with varying iteration, attempting to unroll the loop
gradient instruction used in a loop with varying iteration; partial derivatives may have undefined value
gradient operation uses a value that may not be defined for all pixels (in %s UAV loads can not participate in gradient operations)
gradient-based operations must be moved out of flow control to prevent divergence. Performance may improve by using a non-gradient operation
GREATER
GREATER_EQUAL
GREATEREQUAL
GREEN
Group shared data for %s must be an array of elements
Group shared data for %s must have a count of elements (%u) equal to the number of threads in the thread group (%u)
Group shared data for %s must have an element size (%u) of at most %u bytes when compiling for %u theads
GroupMemoryBarrier
GroupMemoryBarrierWithGroupSync
groupshared
groupshared variables cannot contain resources such as textures, samplers or UAVs
GS has no input primitive, so no input regisers may be declared.  Input v[][%d] was declared.
GS Input
GS input primID already declared.  Opcode #%d (count is 1-based). 
GS input primitive already declared.  Opcode #%d (count is 1-based). 
GS input primitive can be a patch only if the GS version is gs_5_0 and greater.  Opcode #%d (count is 1-based). 
GS input primitive not declared. 
GS input primitive unrecognized.  Opcode #%d (count is 1-based). 
GS instance count already declared.  Opcode #%d (count is 1-based). 
GS instance count declaration cannot be greater than %d (%d specified).  Opcode #%d (count is 1-based). 
GS instance count must be at least 1
GS instance count must be at least 1 (%d specified).  Opcode #%d (count is 1-based). 
GS instance ID already declared.  Opcode #%d (count is 1-based). 
GS output primitive topology unrecognized.  Opcode #%d (count is 1-based). 
GS output topology already declared.  Opcode #%d (count is 1-based). 
GS output topology in stream m%d already declared.  Opcode #%d (count is 1-based). 
GS output topology not declared for stream m%d. 
GS output vertex count declaration can't be more than %d vertices (%d specified).  Opcode #%d (count is 1-based). 
gs_%d_%d
gs_4_0
gs_4_1
gs_5_0
gs_5_1
GT;CT
GT@t-hho
GT3BT
GT3CT
gw t=
Gx@;Gt
H#E$P
H#E<P
h./01hhhhh22234
H<t79M
H0[0{0
h0l0p0t0x0
H0t79M
h4e9m;
hAon9
has valid PGO counts
hasAlloca
HasAssignmentOperator
hasAsynchronousEH
hasC++EH
HasCastOperator
hasDebugInfo
HashDigestLength
hasInlineAssembly
hasLongJump
hasManagedCode
HasNestedTypes
hasSecurityChecks
hasSetJump
hasStructuredEH
hCLI4
hCTAB
hCTABS
HD+H@
HeapAlloc
HeapCreate
HeapDestroy
HeapFree
height
hex value truncated to 64 bits
HFA double
HFA float
hFX10
hhhKTMUVVWWhXYZ[\]^_`abcdefg
hISG1
hISGN
hISGNj
hLFS0
hLIBH
hlsl_full_path
HLSL_VERSION
hlslDefines
hlslEntry
hlslFlags
hlslTarget
Hoist predicated code into outermost predicate <| Explicit
hOSG1
hOSG5
hOSGN
hOSGNj
hPCSG
hPCSGj
HPRh<
hPSG1
HPVh(
hRDEF
HRESULT
hRPLY
hRTS0
hs_%d_%d
hs_5_0
hs_5_0 control point
hs_5_0 patch constant
hs_5_1
hs_control_point_phase
hs_decls
hs_fork_phase
hs_join_phase
hSDBG
hSFI0
hSHDR
hSHEX
hSPDB
hSTAT
Hull Shader declared with IsoLine Domain must specify output primitive point or line. triangle_cw or triangle_ccw output are not compatible with the IsoLine Domain.
Hull Shader declared with Quad Domain must specify output primitive point, triangle_cw or triangle_ccw. line output is not compatible with the Quad domain.
Hull Shader declared with Tri Domain must specify output primitive point, triangle_cw or triangle_ccw. line output is not compatible with the Tri domain.
Hull Shader declsphase must declare a tessellator domain.
Hull Shader declsphase must declare a tessellator output primitive.
Hull Shader declsphase must declare a tessellator partitioning.
Hull Shader declsphase must declare an input control point count.
Hull Shader declsphase must declare an output control point count.
Hull Shader Fork Phase Instance Count already declared in this phase. Aborting.  Opcode #%d (count is 1-based). 
Hull Shader Fork Phase Instance Count must be [%d..%d].  %d specified.  Opcode #%d (count is 1-based). 
Hull Shader fork phase instance ID already declared.  Opcode #%d (count is 1-based). 
Hull Shader Fork Phase reads component(s) of output control point [%d] which were not output by the Control Point Phase.
Hull Shader input control point count already declared. Aborting.  Opcode #%d (count is 1-based). 
Hull Shader Join Phase Instance Count already declared in this phase. Aborting.  Opcode #%d (count is 1-based). 
Hull Shader Join Phase Instance Count must be [%d..%d].  %d specified.  Opcode #%d (count is 1-based). 
Hull Shader join phase instance ID already declared.  Opcode #%d (count is 1-based). 
Hull Shader Join Phase reads component(s) of output control point [%d] which were not output by the Control Point Phase.
Hull Shader MaxTessFactor must be [%f..%f].  %f specified.  Opcode #%d (count is 1-based). 
Hull Shader must start with HSDecls phase.
Hull Shader output control point count already declared. Aborting.  Opcode #%d (count is 1-based). 
Hull Shader output control point ID already declared.  Opcode #%d (count is 1-based). 
Hull Shader output max tessfactor already declared. Aborting.  Opcode #%d (count is 1-based). 
HullShader
hXNAP
hXNAS
I ;H 
i + (I - i) -> append_arg(I) <| SMR.RangeDataAnalysis
i + -i -> append_arg(0) <| SMR.RangeDataAnalysis
i%d already def'd in the shader. 
i%d.w has no meaning; it must simply be 0. 
i%d.x (which represents loop or rep iteration count) cannot be greater than %d. i%d.x is currently def'd as %d. 
i%d.x (which represents loop or rep iteration count) cannot be negative. i%d.x is currently def'd as %d. 
i%d.x (which represents rep iteration count) cannot be greater than %d. i%d.x is currently def'd as %d. 
i%d.x (which represents rep iteration count) cannot be negative. i%d.x is currently def'd as %d. 
i%d.y (which represents loop initial value) must be in the range [0, %d]. i%d.y is currently def'd as %d. 
i%d.yzw have no meaning in this shader model; they must simply be 0. 
i%d.z (which represents loop step value) must be in the range [-%d, %d]. i%d.z is currently def'd as %d. 
I<;1v
I0;Hds
i1W2f2q2}2
I3t$,3
iadd bits_known <| SFPS
iadd fp_flags <| SFPS
iadd int_literal <| SFPS
iadd int_range <| SFPS
iadd zero reduces to no-op mov <| MR.GenSimplifyInstructionsOpt1_NoExcl
iadd(a, b) : if( and_is_zero(a, b) ) -> or(a, b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ibfe bits_known <| SFPS
ibfe fp_flags <| SFPS
ibfe int_literal <| SFPS
ibfe(i) -> extraction sequence <| MR.Gen_RequiredTranslate
ibfe(w, o, ((uint)a >> s) & m) : if( w + o + s < 32 ) -> ibfe(w, o + s, a & (m << s)) <| MR.GenSimplifyInstructionsOpt1_Excl
ibfe(w, o, (a >> s) & m) : if( o + s < 32 ) -> ibfe(w, o + s, a & (m << s)) <| MR.GenSimplifyInstructionsOpt1_Excl
ibfe(w, o, (uint)a >> s) : if( o + s + w < 32 ) -> ibfe(w, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ibfe(w, o, a >> s) : if( o + s < 32 ) -> ibfe(w, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ibfe(w, o, a) >> s : if( o + s < 32 && w >= s ) -> ibfe(w - s, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ID of base symbol for base pointer
ID of the register holding base pointer to locals
ID of the register holding base pointer to parameters
ID3D10Effect::ParseSODecl - invalid mask declaration '%s'
ID3D10Effect::ParseSODecl - Invalid output slot
ID3D10Effect::ParseSODecl - Non-digit '%c' in output slot
ID3D11FunctionLinkingGraph::CallFunction: %s::%s function has non-matching prototypes (different parameter counts)
ID3D11FunctionLinkingGraph::CallFunction: %s::%s function has non-matching prototypes (parameter %u)
ID3D11FunctionLinkingGraph::CallFunction: a function cannot be called after the output signature has been set
ID3D11FunctionLinkingGraph::CallFunction: function '%s' input parameter %u has unsupported register mapping
ID3D11FunctionLinkingGraph::CallFunction: function '%s' output parameter %u has unsupported register mapping
ID3D11FunctionLinkingGraph::CallFunction: function '%s' prototype is not found in the module
ID3D11FunctionLinkingGraph::CallFunction: function name cannot be empty
ID3D11FunctionLinkingGraph::CallFunction: NULL parameter
ID3D11FunctionLinkingGraph::CreateModuleInstance: FLG has no nodes
ID3D11FunctionLinkingGraph::CreateModuleInstance: FLG module instance has already been created
ID3D11FunctionLinkingGraph::CreateModuleInstance: NULL parameter
ID3D11FunctionLinkingGraph::CreateModuleInstance: uninitialized parameter #%u component '%c' passed to function '%s::%s' at call site #%u
ID3D11FunctionLinkingGraph::CreateModuleInstance: uninitialized shader output signature parameter #%u, component '%c'
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: %s parameter component '%c' is not defined
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: bad destination swizzle '%s'
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: bad source swizzle '%s'
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: cannot pass values for parameters of type void
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: destination parameter component '%c' has already been initialized
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: destination parameter must be an INOUT or IN parameter
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: destination swizzle '%s' cannot have replicated components
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: illegal character in the swizzle string '%s'
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: illegal destination parameter index
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: illegal source parameter index
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: incompatible column dimensions
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: incompatible element types
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: incompatible row dimensions
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: incompatible type classes
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: NULL parameter
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: possible loss of precision when passing value from <%u, %d> to <%u, %d> (<NodeId, ParamId>)
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: source node must preceed destination node in FLG
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: source parameter must be an INOUT or OUT parameter
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: source value has too few components
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: swizzle is not supported for matrices
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: swizzle string cannot be empty
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: value must be consumed by an input parameter
ID3D11FunctionLinkingGraph::PassValueWithSwizzle: value must be produced by an output parameter
ID3D11FunctionLinkingGraph::SetInputSignature: input signature has already been set
ID3D11FunctionLinkingGraph::SetInputSignature: input signature has duplicate parameter names/semantics
ID3D11FunctionLinkingGraph::SetInputSignature: input signature must be the first FLG node
ID3D11FunctionLinkingGraph::SetInputSignature: NULL parameter
ID3D11FunctionLinkingGraph::SetInputSignature: too many parameters (%u) in the input signature (max=%u)
ID3D11FunctionLinkingGraph::SetOutputSignature: input and output signatures have duplicate parameter names
ID3D11FunctionLinkingGraph::SetOutputSignature: NULL parameter
ID3D11FunctionLinkingGraph::SetOutputSignature: output signature has already been specified
ID3D11FunctionLinkingGraph::SetOutputSignature: output signature has duplicate parameter names/semantics
ID3D11FunctionLinkingGraph::SetOutputSignature: output signature must be the last FLG node
ID3D11FunctionLinkingGraph::SetOutputSignature: too many parameters (%u) in the output signature (max=%u)
ID3D11FunctionLinkingGraph::SetSignature: illegal name for parameter %u
ID3D11FunctionLinkingGraph::SetSignature: illegal semantic name for parameter %u
ID3D11FunctionLinkingGraph::SetSignature: illegal type for parameter %u
ID3D11FunctionLinkingGraph::SetSignature: NumColums must be between 1 and 4 for parameter %u
ID3D11FunctionLinkingGraph::SetSignature: NumRows must be between 1 and 4 for parameter %u
ID3D11FunctionLinkingGraph::SetSignature: unknown class for parameter %u
ID3D11FunctionLinkingGraph::SetSignature: unknown interpolation mode for parameter %u
ID3D11Linker::AddClipPlaneFromCBuffer: cbuffer entry index is too large (max=%u)
ID3D11Linker::AddClipPlaneFromCBuffer: cbuffer slot index is too large (max=%u)
ID3D11Linker::AddClipPlaneFromCBuffer: clipplane for cbuffer %u entry %u has already been specified
ID3D11Linker::AddClipPlaneFromCBuffer: the maximum allowed number of clipplane fron a cbuffer is %u
ID3D11Linker::Link: %s semantic '%s' can only have one row and number of components between [%u,%u]
ID3D11Linker::Link: %s sematic %s number must be in range [%u, %u] for shader target '%s'
ID3D11Linker::Link: a duplicate resource names (%s) are not allowed (use namespaces to disambiguate)
ID3D11Linker::Link: all components of %s semantic '%s' must be initialized by '%s' shaders
ID3D11Linker::Link: bad %s semantic name '%s'
ID3D11Linker::Link: Cannot use clipplanes attribute without specifying a 4-component SV_Position output
ID3D11Linker::Link: cbuffer (size=%u) remapping <vslot %u>-><slot %u, offset %u> in function '%s::%s' exceeds the maximum cbuffer size (%u)
ID3D11Linker::Link: cbuffer slot %u in function '%s::%s' maps to real slot %u that is too big (max=%u)
ID3D11Linker::Link: clipplanes can only specified for Vertex shaders
ID3D11Linker::Link: failed to generate byte code
ID3D11Linker::Link: failed to pack %s signature
ID3D11Linker::Link: failed to remap SRV to UAV (slot=%u)
ID3D11Linker::Link: function '%s::%s' byte code (version '%u.%u') cannot be used for the requested shader target '%s'
ID3D11Linker::Link: function '%s::%s' is missing a legacy shader blob necessary to link '%s' target
ID3D11Linker::Link: function '%s::%s' is not found in registered module instances
ID3D11Linker::Link: function '%s::%s' legacy byte code (version '%u.%u') cannot be used to link shader target '%s'
ID3D11Linker::Link: function '%s::%s' prototype and signature flags do not match for parameter %u
ID3D11Linker::Link: function '%s::%s' prototype and signature semantics do not match for parameter %u
ID3D11Linker::Link: function '%s::%s' prototype and signature types do not match for parameter %u
ID3D11Linker::Link: function '%s::%s' prototype does not match function signature
ID3D11Linker::Link: illegal remapping specified for resource slot range [%u, %u] in function '%s::%s'
ID3D11Linker::Link: illegal remapping specified for sampler slot range [%u, %u] in function '%s::%s'
ID3D11Linker::Link: illegal remapping specified for UAV slot range [%u, %u] in function '%s::%s'
ID3D11Linker::Link: immediate cbuffer (%u entries) exceeds the limit of %u entries
ID3D11Linker::Link: input semantic '%s' cannot be read by '%s' shaders
ID3D11Linker::Link: integer types must have constant interpolation mode for %s semantic '%s'
ID3D11Linker::Link: invalid %s SV_ semantic '%s' for shader target '%s'
ID3D11Linker::Link: invalid class specified for %s semantic '%s'
ID3D11Linker::Link: invalid interpolation mode specified for %s semantic '%s'
ID3D11Linker::Link: invalid type specified for %s semantic '%s'
ID3D11Linker::Link: not enough temporary registers (max=%u).
ID3D11Linker::Link: NULL parameter
ID3D11Linker::Link: only one Depth sematic can be spesified for shader target '%s'
ID3D11Linker::Link: output semantic '%s' cannot be written by '%s' shaders
ID3D11Linker::Link: overlapping %s sematics %s are not supported
ID3D11Linker::Link: pixel shaders cannot declare arbitrary output semantics ('%s')
ID3D11Linker::Link: remapping has not been specified for cbuffer slot %u in function '%s::%s'
ID3D11Linker::Link: remapping has not been specified for resource slot %u
ID3D11Linker::Link: remapping has not been specified for UAV slot %u
ID3D11Linker::Link: remapping of resource (slot %u) to UAV (slot %u) in function '%s::%s' is allowed only for buffers
ID3D11Linker::Link: remapping of resource (slot %u) to UAV (slot %u) is allowed only for buffers
ID3D11Linker::Link: resource slot %u maps to real resource slot %u that is too big (max=%u)
ID3D11Linker::Link: resource slot %u maps to real UAV slot %u that is too big (max=%u)
ID3D11Linker::Link: several UAVs/SRVs with incompatible properties map to slot %u
ID3D11Linker::Link: several virtual resources with incompatible properties map to real %s slot %u
ID3D11Linker::Link: several virtual samplers with incompatible sampler modes map to slot %u
ID3D11Linker::Link: SV_ClipDistance and SV_CullDistance occupy %u %s registers, only two are allowed
ID3D11Linker::Link: SV_ClipDistance semantics cannot be used when using the clipplanes attribute
ID3D11Linker::Link: SV_Target outputs must be contiguous from SV_Target0 to SV_TargetN for shader target '%s'
ID3D11Linker::Link: the number of sample entries exceeded the limit of %u
ID3D11Linker::Link: the shader requires %u defb constants, which exceeds the allowed limit of %u
ID3D11Linker::Link: the shader requires %u defc constants, which exceeds the allowed limit of %u
ID3D11Linker::Link: the shader requires %u defi constants, which exceeds the allowed limit of %u
ID3D11Linker::Link: total number of registers %u exceeds %u.
ID3D11Linker::Link: UAV slot %u maps to real slot %u that is too big (max=%u)
ID3D11Linker::Link: validation error:  %s
ID3D11Linker::SetEntry: entry cannot be NULL
ID3D11Linker::SetEntry: entry has already been set
ID3D11Linker::SetEntry: only FLG and cs_5_0 entries are supported currently
ID3D11Linker::SetEntry: shader target name cannot be NULL
ID3D11Linker::SetEntry: unsupported shader target '%s'
ID3D11Linker::UseLibraryWithNamespace: NULL parameter
ID3DXEffectCompiler: Arrays must be either numeric, structure, string or shader
ID3DXEffectCompiler: Assignment cannot be a structure
ID3DXEffectCompiler: Can't set shader'
ID3DXEffectCompiler: Compilation failed
ID3DXEffectCompiler: DMAPOFFSET sampler state can only be used with D3DDMAPSAMPLER (i.e. sampler index 256)
ID3DXEffectCompiler: Dword expressions for state '%s' must evaluate to NULL
ID3DXEffectCompiler: Error in type checking
ID3DXEffectCompiler: Error initializing annotation type
ID3DXEffectCompiler: Error initializing assignment type
ID3DXEffectCompiler: Error initializing variable type
ID3DXEffectCompiler: FVFs must not evaluate to NULL
ID3DXEffectCompiler: Geometry shader can only be set in fx_4_0 or higher.'
ID3DXEffectCompiler: Index is required for state '%s'
ID3DXEffectCompiler: Initializer list elements cannot be complex expressions or variables
ID3DXEffectCompiler: Initializers must be numeric scalars
ID3DXEffectCompiler: Internal error initializing assignment - missing type case
ID3DXEffectCompiler: Internal Error: Unexpected state.
ID3DXEffectCompiler: Invalid integer expression assignment
ID3DXEffectCompiler: Invalid sampler index %d
ID3DXEffectCompiler: Max index for effect state '%s' is %d
ID3DXEffectCompiler: Only numeric types and strings are allowed as annotations
ID3DXEffectCompiler: Only numeric types are allowed inside structures
ID3DXEffectCompiler: Only pass allowed within a technique
ID3DXEffectCompiler: State '%s' accepts only dwords and ids
ID3DXEffectCompiler: State '%s' cannot be assigned an array or structure
ID3DXEffectCompiler: State '%s' does not accept '%s' as a value
ID3DXEffectCompiler: State '%s' is not indexed
ID3DXEffectCompiler: State '%s' must be assigned a 3-vector or a 4-vector or a uint scalar
ID3DXEffectCompiler: State '%s' must be assigned a numeric scalar or a 4-float vector
ID3DXEffectCompiler: State '%s' must be assigned a numeric value
ID3DXEffectCompiler: State '%s' must be assigned a scalar
ID3DXEffectCompiler: State '%s' was assigned an incompatible type
ID3DXEffectCompiler: State '%s' was assigned an unsupported value
ID3DXEffectCompiler: State '%s' was not assigned a sampler type
ID3DXEffectCompiler: State '%s' was not assigned a stateblock type
ID3DXEffectCompiler: State '%s' was not assigned a texture type
ID3DXEffectCompiler: There was a problem getting annotations
ID3DXEffectCompiler: There was a problem getting variable type
ID3DXEffectCompiler: There was a problem in the parse tree
ID3DXEffectCompiler: There was an error initializing parameter annotation handles
ID3DXEffectCompiler: There was an error initializing parameter handles
ID3DXEffectCompiler: There was an error initializing pass annotation handles
ID3DXEffectCompiler: There was an error initializing technique annotation handles
ID3DXEffectCompiler: There was an error initializing the compiler
ID3DXEffectCompiler: There were no techniques
ID3DXEffectCompiler: This sampler is used with a DX10-style texture intrinsic. This is not implemented in this version of the compiler.
ID3DXEffectCompiler: Unexpected component type
ID3DXEffectCompiler: Unexpected error
ID3DXEffectCompiler: Unexpected node encountered when trying to determine type
ID3DXEffectCompiler: Unexpected template type
ID3DXEffectCompiler: Unexpected value type of state '%s' (internal error)
ID3DXEffectCompiler: Unrecognized state '%s'
ID3DXEffectCompiler: Unsupported sampler or stateblock expression (static usage not supported).
ID3DXEffectCompiler::CompileEffect: Could not compile expression containing shader array
ID3DXEffectCompiler::CompileEffect: Only 1-d shader arrays allowed
ID3DXEffectCompiler::CompileEffect: Shader arrays index %d out of bounds [0, %d]
ID3DXEffectCompiler::CompileEffect: Shader arrays index was not float or int
ID3DXEffectCompiler::CompileEffect: Shader arrays must be a previously defined parameter
ID3DXEffectCompiler::CompileEffect: There was an error compiling expression
ID3DXEffectCompiler::CompileEffect: There was an error compiling HLL shader parameter
ID3DXEffectCompiler::CompileEffect: Unrecognized value type
Identifier invalid or not found (were you attempting a forward reference?)
IDirect3DShaderValidator9::Begin called out of order. ::End must be called first.
IDirect3DShaderValidator9::End called out of order. Call to ::Begin, followed by calls to ::Instruction must occur first.
IDirect3DShaderValidator9::Instruction called out of order. ::Begin must be called first.
IDirect3DShaderValidator9::Instruction called out of order. After end token there should be no more instructions.  Call ::End next.
IDirect3DShaderValidator9::Instruction called with NULL == pdwInst or 0 == cdw.
idiv bits_known <| SFPS
idiv currently not supported (instruction deprecated). For now, try using unsigned int types for div instead
idiv fp_flags <| SFPS
idiv int_literal <| SFPS
idiv int_range <| SFPS
IEEE-safe mode clamps float literals to 32-bit values, %g is losing precision (this warning will only be shown once per compile)
if statement conditional expressions must evaluate to a scalar
if statement was flattened due to nesting limits but it contains side effects and can't be flattened
if(!a) -> ifn(a) <| MR.GenD3D10PostMod_Both
if(A){B = A ? C : D} -> if(A){B = C} <| Explicit
if(bieq(x,0)) -> ifn(x) <| MR.GenD3D10PostMod_Both
if(bilt(0,x)) -> if(x) <| MR.GenD3D10PostMod_Both
if(bine(x,0)) -> if(x) <| MR.GenD3D10PostMod_Both
if(bine(x,0)) -> if(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
if(bult(0,x)) -> if(x) <| MR.GenD3D10PostMod_Both
if(x){...} else {} -> if(x) {...} <| Explicit
if(x){...} if(x){...} -> if(x) {... ...} <| Explicit
if(x){} else {...} -> if(!x) {...} <| Explicit
if_cmp
if_eq(x + y, 0) -> if_eq(x, -y) <| MR.Gen_PreModTarget_Both
if_ge(-a^2,a^2) -> if_eq(a,0) <| MR.Gen_PreModTarget_Both
if_ge(neg(abs(x)), 0) -> if_eq0 <| MR.Gen_PreModTarget_Both
if_ge(x + y, 0) -> if_ge(x, -y) <| MR.Gen_PreModTarget_Both
if_lt(-a^2,a^2) -> if_ne(a,0) <| MR.Gen_PreModTarget_Both
if_lt(neg(abs(x)), 0) -> if_ne0 <| MR.Gen_PreModTarget_Both
if_lt(x + y, 0) -> if_lt(x, -y) <| MR.Gen_PreModTarget_Both
if_ne(x + y, 0) -> if_ne(x, -y) <| MR.Gen_PreModTarget_Both
if_ne(x, 0) -> if_ne(x, -x) <| MR.Gen_PreModTarget_Both
if+cmp_ge -> if_ge <| MR.Gen_PreModTarget_Both
if+cmp_ge0 -> if_ge0 <| MR.Gen_PreModTarget_Both
if+cmp_lt -> if_lt <| MR.Gen_PreModTarget_Both
if+cmp_lt0 -> if_lt0 <| MR.Gen_PreModTarget_Both
if+ge -> if_ge <| MR.Gen_PreModTarget_Both
if+lt -> if_lt <| MR.Gen_PreModTarget_Both
IFCEt
ifdef
ifndef
IGE a,a -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
ignore double move(a) -> append_arg(a) <| SMR.RangeDataAnalysis
ignore move(a) -> append_arg(a) <| SMR.RangeDataAnalysis
ILDNt
Illegal character in shader file
Illegal initializer
Illegal initializer for a numeric variable
ILT a,a -> false <| MR.GenSimplifyInstructionsOpt1_NoExcl
imad bits_known <| SFPS
imad fp_flags <| SFPS
imad int_literal <| SFPS
imad int_range <| SFPS
imad match 1 (a + b*c) <| MR.GenMad
imad match 2 (a + b+b) <| MR.GenMad
imaginary square root
imax bits_known <| SFPS
imax fp_flags <| SFPS
imax int_literal <| SFPS
imax int_range <| SFPS
imax(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imax(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imax(imax(i0, l1), l2) -> imax(i0, imax(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imax(x,y) where one is >= the other <| Explicit
imin bits_known <| SFPS
imin fp_flags <| SFPS
imin int_literal <| SFPS
imin int_range <| SFPS
imin(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imin(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imin(imin(i0, l1), l2) -> imin(i0, imin(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
imin(x,y) where one is <= the other <| Explicit
imm_atomic_alloc
imm_atomic_alloc and imm_atomic_consume can't be combined with other atomic operations on an Append UAV (%d). Opcode #%d (counts are 1-based).
imm_atomic_alloc and imm_atomic_consume on a given UAV (%d) cannot both be in the same shader. Opcode #%d (counts are 1-based).
imm_atomic_alloc and imm_atomic_consume require as Structured Buffer UAV (slot %d). Opcode #%d (counts are 1-based).
imm_atomic_alloc fp_flags <| SFPS
imm_atomic_and
imm_atomic_and fp_flags <| SFPS
imm_atomic_cmp_exch
imm_atomic_cmp_exch fp_flags <| SFPS
imm_atomic_consume
imm_atomic_consume fp_flags <| SFPS
imm_atomic_exch
imm_atomic_exch fp_flags <| SFPS
imm_atomic_iadd
imm_atomic_iadd fp_flags <| SFPS
imm_atomic_imax
imm_atomic_imax fp_flags <| SFPS
imm_atomic_imin
imm_atomic_imin fp_flags <| SFPS
imm_atomic_or
imm_atomic_or fp_flags <| SFPS
imm_atomic_umax
imm_atomic_umax fp_flags <| SFPS
imm_atomic_umin
imm_atomic_umin fp_flags <| SFPS
imm_atomic_xor
imm_atomic_xor fp_flags <| SFPS
Immediate constant buffer already declared, repeated declaration on opcode #%d (count is 1-based). 
Immediate constant buffer size must be a multiple (not incl. 0) of 32bit*4-tuples in size, but no larger than %d 32bit*4-tuples (%d bytes declared).  Opcode #%d (count is 1-based). 
imod bits_known <| SFPS
imod fp_flags <| SFPS
imod int_literal <| SFPS
imod int_range <| SFPS
implicit truncation of vector type
implicitly 
Import:
imul bits_known <| SFPS
imul fp_flags <| SFPS
imul int_literal <| SFPS
imul int_range <| SFPS
imul one reduces to no-op mov <| MR.GenSimplifyInstructionsOpt1_NoExcl
imul(a, iv_pow2) -> ishl(a, get_lowest_bit(iv_pow2)) <| MR.GenD3D10_OptimizeEarlyTranslate
imul(iadd(a, iv1), iv2) -> iadd(imul(a, iv2), imul(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
imul(ishl(iv1, a), iv2) -> ishl(imul(iv1, iv2), a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
in %s uints can only be used with known-positive values, use int if possible
include
Incompatible min precision type for operand #%d of opcode #%d (counts are 1-based). Expected float.
Incompatible min precision type for operand #%d of opcode #%d (counts are 1-based). Expected int or uint.
Incomplete texm* sequence.
Inconsistent semantic definition: %s and %s
incorrect bind semantic
incorrect number of arguments to numeric-type constructor
Incorrect number of operands for opcode #%d (count is 1-based).  Expecting %d, encountered %d.
Incorrect number of parameters for BindInterfaces
Incorrect number of rows or columns
Incorrect register type '%s' in CBV (expected b#)
Incorrect register type '%s' in Sampler/StaticSampler (expected s#)
Incorrect register type '%s' in SRV (expected t#)
Incorrect register type '%s' in UAV (expected u#)
INCR_SAT
IncrementCounter
IncrementCounter/DecrementCounter are only valid on RWStructuredBuffer objects
INCRSAT
indefinite arccosine
indefinite arcsine
indefinite derivative calculation
indefinite logarithm
index
Index Dimension %d out of range (%d specified, max allowed is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Index Dimension %d's relative address indexable temp is out of range (%d specified, max allowed is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Index Dimension %d's relative address indexable temp's dimension %d index is out of range (%d specified, max allowed is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Index Dimension %d's relative address temp is out of range (%d specified, max allowed based on temp declaration is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
Index Dimension %d's relative address temp is out of range (%d specified, max allowed is %d) for operand #%d of opcode #%d (counts are 1-based). Aborting.
index for an array of complex types containing doubles must be a literal expression
Index is required for state '%s'
index of input assembly file
Index ranges declared on Patch Constant Data cannot cross over related blocks of hardware TessFactors. An index range is declared from register [%d] to [%d], which crosses over a block of TessFactors that starts with %s in register [%d] and ends in %s in register [%d].
Indexable function parameters are unsupported (parameter: %u, "%s".
Indexable temp register index, [%d], too high.  Opcode #%d (count is 1-based). Aborting.
Indexable temp x%d already declared.  Opcode #%d (count is 1-based). 
Indexed expressions are illegal as attribute parameters
INDEXEDVERTEXBLENDENABLE
Indexing of t# resources with current instruction requires opcode to specify resource dimension and return type. Operand #%d of opcode #%d (counts are 1-based). Aborting.
IndirectVirtualBaseClass
Individual instruction in co-issue pair cannot write both alpha and color component(s).
ineg bits_known <| SFPS
ineg fp_flags <| SFPS
ineg int_literal <| SFPS
ineg int_range <| SFPS
ineg(and(ne(x,0),1)) -> ne(x,0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ineg(ineg(x)) -> mov(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
infinite loop detected - loop never exits
infinite loop detected - loop writes no values
initial value
Initialize arrays to void <| Explicit
InitializeConditionVariable
InitializeCriticalSection
InitializeCriticalSectionAndSpinCount
initializedData
initializer
Initializer used on a global 'const' variable. This requires setting an external constant. If a literal is desired, use 'static const' instead.
InitializeSListHead
InjectedSource
inline
inner array index within group shared element must be a literal expression for %s
INNERCOV
inout
inout 
Input
input
input assembly file name
Input cannot be dcl'd with usage+index positiont0, as vertex data containing this semantic has special meaning to the API: skip vertex processing altogether.
Input control point count must be [%d..%d].  %d specified.  Opcode #%d (count is 1-based). 
Input control point count must be [0..%d].  %d specified.  Opcode #%d (count is 1-based). 
Input domain point already declared.  Opcode #%d (count is 1-based). 
Input domain point declaration can't have an empty mask.  Opcode #%d (count is 1-based). 
Input index range declaration out of range.  Opcode #%d (count is 1-based). 
Input index range defined from %d to %d does not include any declared input registers. 
Input primitive ID already declared in this HS phase.  Opcode #%d (count is 1-based). 
Input primitive ID already declared.  Opcode #%d (count is 1-based). 
Input register v%d was not declared with a dcl statement.  Attempt to read component%s(*): %s
Input signature cannot be defined for a library function.
Input signature does not specify component %d of register %d which is declared in the shader code. 
Input signature name mismatch with declaration in shader code for component %d in register %d. 
Input signature parameter #%d (1-based) specifies out of range register %d. 
Input signature parameter #%d (1-based) specifies register %d (or components in the register) that have already been defined. 
input types for geometry shader must be arrays
InputAssemblyFiles
InputPatch
Inputs
InsideScale
instance
instance constructor of a class with virtual base
Instance ID
instance_id
instanceID already declared for input.  Opcode #%d (count is 1-based). 
INSTID
Instruction cannot have co-issue ('+') set without a previous arithmetic instruction to pair with.
instruction coissue is not supported in this shader version
Instruction length specified for instruction (%d) does not match the token count encountered (%d). Aborting validation.
Instruction modifiers are not allowed for tex* instructions.
Instruction modifiers not allowed for tex* instructions.
Instruction modifiers other than _sat or _pp not permitted. (_sat is permitted only on arithmetic ops, except frc or SINCOS)
Instruction not supported by %s shader.
Instruction not supported by this vertex shader version.
Instruction not supported by version %s pixel shader.
Instruction not supported by version %s shader.
instruction predication is not supported in this shader version
Instruction shifts not permitted.
int or unsigned int type required
int1x1
int1x2
int1x3
int1x4
int2x1
int2x2
int2x3
int2x4
int3x1
int3x2
int3x3
int3x4
int4x1
int4x2
int4x3
int4x4
Integer
integer
integer '%dl'
integer '%I64d'
integer '%I64uu64'
integer '%u'
integer '%uul'
integer add sequence simplification <| Explicit
Integer addition negative identities <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer constant
integer constant register '%s' must be defined as a variable of type int3 or int4 only
Integer divide by zero
integer divides may be much slower, try using uints if possible.
integer inputs unsupported on %s
integer modulus may be much slower, try using uints if possible.
integer movc((a<b),b,a) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer movc((a>=b),a,b) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
integer multiply by literal identity <| Explicit
integer multiply by negative one identity <| Explicit
integer multiply by one identity <| Explicit
integer multiply by zero identity <| Explicit
integer negate modifier match <| Explicit
Integer Power of 2
integral
interface
interface arrays cannot be multi-dimensional
interface calls cannot be indexed with varying values
interface decl declares an interface index %d that is not a base register in the interface metadata.  Opcode #%d (count 1-based).
interface decl declares an interface index %d that is not the interface metadata.  Opcode #%d (count 1-based).
interface decl declares an interface index (%d) that has already been declared.  Opcode #%d (count 1-based).
interface decl declares an invalid interface index %d.  Opcode #%d (count 1-based).
interface decl expects a table of size %d, but table %d has %d elements.  Opcode #%d (count 1-based).
interface decl for interface index %d has different function table data than the interface metadata.  Opcode #%d (count 1-based).
interface decl references undefined function table (%d).  Opcode #%d (count 1-based).
Interface metadata expects interface %d to be declared, but it was not.
Interface metadata expects interface %d to be of size %d, but it was declared as size %d.
Interface metadata instance %d refers to undeclared constant buffer %d.
Interface metadata instance %d refers to undeclared constant buffer offset [%d,%d].
Interface metadata instance %d refers to undeclared sampler %d.
Interface metadata instance %d refers to undeclared texture %d.
interface pointer (%d) was declared, but never referenced.
interface references must resolve to non-varying objects
interface variables can only be initialized with concrete classes
Interface-reachable members containing UAVs or group shared variables are not yet implemented
interfaces
interfaces cannot be embedded in other types
interfaces cannot inherit from other types
interlocked targets must be groupshared or UAV elements
InterlockedAdd
InterlockedAnd
InterlockedCompareExchange
InterlockedCompareStore
InterlockedExchange
InterlockedMax
InterlockedMin
InterlockedOr
InterlockedXor
Internal Error - there was a problem getting a type size
internal error gathering debug file information
Internal error in compiler
internal error: 64-bit arg component %u not aligned <| A%u (B%u)
internal error: addressing inconsistent pool
internal error: AND operator inputs not bool
internal error: argument missing context <| A%u (B%u)
internal error: argument pulled into unrelated predicate
internal error: argument used without having been initialized <| A%u (B%u), I%u (B%u)
internal error: argument was never used <| (A%u (B%u))
internal error: argument was never used <| (A%u (B%u), I%u (B%u))
internal error: binary instruction expected
internal error: blob content mismatch between level9 and d3d10 shader
internal error: blob mismatch between level9 and d3d10 shader
internal error: blob size mismatch between level9 and d3d10 shader
internal error: cannot read from argument pool <| (A%u (B%u))
internal error: cannot write to argument pool <| (A%u (B%u), I%u (B%u))
internal error: chain register invalid
internal error: compilation aborted unexpectedly
internal error: compiler-generated value has a minimum precision type and is marked precise <| A%u (B%u)
internal error: component out of range
internal error: constant buffer used as address
internal error: debug info append failed, byte count (%d) too large?
internal error: DST test failure
internal error: emitting a denorm
internal error: expected binary instruction for scalar RHS
internal error: expected scalar RHS for instruction
internal error: expression expected
internal error: failed to add code section to debug info
internal error: failed to add module to debug info
internal error: failed to add section contribution
internal error: failed to add section header to debug info
internal error: failed to append section header to pdb
internal error: failed to close debug info
internal error: failed to close debug info in PDB
internal error: failed to close module in debug info
internal error: failed to close PDB
internal error: failed to close section header in debug info
internal error: failed to close source file store
internal error: failed to close source file store in PDB
internal error: failed to close type info
internal error: failed to commit inline type info in PDB
internal error: failed to commit PDB
internal error: failed to commit type info in PDB
internal error: failed to create debug info in PDB
internal error: failed to create inline type info in PDB
internal error: failed to create source file store in PDB
internal error: failed to create type info in PDB
internal error: failed to devirtualize a contained interface call
internal error: failed to emit instruction
internal error: failed to open PDB for writing in stream
internal error: failed to write debug data to pdb stream
internal error: flattened side effect
internal error: gradient instruction sent to preshader
internal error: IF with size greater then 1 found
internal error: inconsistent addressing
internal error: inconsistent derivative writer
internal error: input register missing semantic
internal error: instruction list and count mismatch
internal error: instruction list too long
internal error: instruction missing outputs
internal error: instruction size mismatch
internal error: invalid access of unbound variable
Internal error: invalid read of more specific predicate
internal error: invalid register
internal error: invalid sequence/cast expression
internal error: invalid swizzle found
internal error: l-value expected
internal error: modifier used on address
internal error: multiple write to same output
internal error: no profile exists for this pixel shader version
internal error: no profile exists for this shader version
internal error: no profile exists for this vertex shader version
internal error: no semantic found on i/o argument
internal error: no storage type for block output
internal error: non ordinal input/output found
internal error: non-vectorized pool violated port constraints
internal error: not all rules initialized
internal error: operand type mismatch
internal error: OR operater inputs not bool
internal error: out of memory
internal error: output argument was never initialized <| (A%u (B%u))
internal error: output found with no semantic
internal error: output register missing semantic
internal error: overlapping output writes
internal error: pdb append failed
internal error: PDB data too large
internal error: PDB stream truncated
internal error: production failed
internal error: reading from value known not to be read <| (A%u (B%u))
internal error: result register invalid
internal error: result violated port constraints
internal error: RootSignature append failed, byte count (%d) too large?
internal error: Rule class id invalid
internal error: scalar instruction with too many inputs
internal error: stack underflow
internal error: statistics append failed, byte count (%d) too large?
internal error: this-relative %s '%s' found outsideof function scope
internal error: unable to add non-conflicting symbol
internal error: unable to process intrinsic
internal error: unassociated return
internal error: unexpected Alias on texture declaration
internal error: unexpected input register type
internal error: unexpected output register type
internal error: unknown node
Internal error: unpredicated endif input
internal error: unpredicated incomplete
internal error: unpredicated loop_in
Internal error: unread predicate
Internal error: unrecognized assignment type
internal error: unrecognized expression
internal error: unrecognized geometry shader input primitive type
Internal error: unrecognized SB API Call
internal error: unrecognized statement
internal error: unrecognized value
internal error: vectorized instruction too large
internal warning: optimization did not converge
internal warning: PDB Error string is "%S"
InternalName
Interpolation mode cannot vary for different components of a single input register (v%d).  Opcode #%d (count is 1-based). 
Interpolation mode for PS clip or cull distance must be linear or linear centroid, or in 4.1, linear_sample  (register v%d).  Opcode #%d (count is 1-based). 
Interpolation mode for PS input position must be linear_noperspective or linear_noperspective_centroid (shader model 4.1+ allows linear_noperspective_sample as well). 
Interpolation mode for PS input position must be linear_noperspective_centroid or linear_noperspective_sample when outputting oDepthGE or oDepthLE and not running at sample frequency (which is forced by inputting SV_SampleIndex or declaring an input linear_sample or linear_noperspective_sample). 
Interpolation mode for PS renderTargetArrayIndex or viewportArrayIndex must be constant (register v%d).  Opcode #%d (count is 1-based). 
Interpolation mode for PS SGV must be constant (register v%d).  Opcode #%d (count is 1-based). 
Interpolation mode on input v# register used with eval_* instruction must be linear, linear_centroid, linear_noperspective, linear_noperspective_centroid, linear_sample or linear_noperspective_sample. Opcode #%d (count is 1-based). 
intrinsic function
intrinsic function '%s' is not yet implemented
intrinsic method
Intro
INV_BLEND_FACTOR
INV_DEST_ALPHA
INV_DEST_COLOR
INV_SRC_ALPHA
INV_SRC_COLOR
INV_SRC1_ALPHA
INV_SRC1_COLOR
invalid
invalid %s %s
Invalid %s input semantic '%s'.
invalid %s semantic '%s': Legal indices are in [%d,%d]
Invalid %s semantics - POSITIONT0
Invalid assignment index (%u). Maximum allowed is %u.
invalid compiler flag %s
invalid complement expression
Invalid component mask in indexable temp decl: 0x%x.  Opcode #%d (count is 1-based). Aborting. 
Invalid component selection mode for vCycleCounter.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid component selection mode for vInputThreadGroupID.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid component selection mode for vInputThreadID.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid component selection mode for vInputThreadIDInGroup.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid const register num: %d. Max allowed is %d.
Invalid constant bool (b#) register num: %d. Max allowed is %d.
Invalid constant integer (i#) register num: %d. Max allowed is %d.
Invalid dest reg num: %d. Max allowed for this reg type is %d.
Invalid destination register number: %d. Max allowed for this register type is %d.
Invalid destination shift.
Invalid dst modifier for vertex shader.
Invalid dst modifier.
Invalid dst shift.
Invalid index dimension %d for relative address temp register within dimension 1 of operand.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid index dimension for relative address indexable temp register within dimension %d of operand.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid indexing mode for first dimension.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid input register '%s' specified
Invalid instruction for Hull Shader Control Point phase.
Invalid instruction for Hull Shader Decls phase.
Invalid instruction for Hull Shader Fork phase.
Invalid instruction for Hull Shader Join phase.
Invalid instruction for Hull Shader postamble section (subroutines and function bodies).
Invalid instruction modifier.
invalid instruction modifiers '%s'
invalid interface binding parameter
Invalid interface metadata: duplicated type in interface %d's type list.
Invalid interface metadata: instance buffer overrun.
Invalid interface metadata: instance name buffer overrun.
Invalid interface metadata: instance type buffer overrun.
Invalid interface metadata: interface %u unimplemented.
Invalid interface metadata: interface buffer overrun.
Invalid interface metadata: interface count mismatch.
Invalid interface metadata: no types defined.
Invalid interface metadata: too many instances.
Invalid interface metadata: too many interface slots.
Invalid interface metadata: too many types.
Invalid interface metadata: type %d violates type stride limits.
Invalid interface metadata: type buffer overrun.
Invalid interface metadata: type name buffer overrun.
Invalid interface metadata: unterminated instance name.
Invalid interface metadata: unterminated type name.
Invalid interface metadata: variable %d violates limits on member offsets.
Invalid interpolation mode for register v%d.  Opcode #%d (count is 1-based). 
invalid mask '%s'
Invalid name or shader for SGV dcl.  Opcode #%d (count is 1-based). 
Invalid name or shader for SIV dcl.  Opcode #%d (count is 1-based). 
Invalid operand type for operand #%d of opcode #%d (counts are 1-based). 
invalid or unsupported integer constant expression
Invalid output register '%s' specified
invalid packoffset location '%s'
Invalid parameter count.
Invalid pixel shader input register '%s' specified
invalid preprocessor command '%s'
invalid reference to input semantic '%s%d'
invalid reference to output semantic '%s%d'
Invalid reg num %d (%s source param).  Max allowed for this type is %d.
Invalid reg num for MISCTYPE.
Invalid reg num: %d for %s source param. Max allowed for this type is %d.
Invalid reg type (%s source param).
Invalid reg type for %s source param.
Invalid reg type for dest param.
invalid register '%s'
invalid register '%s[%u]'
invalid register '%s[...]'
Invalid register number, %d, specified for a# (address) register. Max # supported is %d (%s source param).
Invalid register number, %d, specified for aL register. Max # supported is %d (%s source param).
Invalid register number: %d. Max allowed for %s# register is %d.
invalid register semantic '%s', or variable must be bound to multiple register banks (%c register binding required)
invalid register specification, expected 'b' binding
invalid register specification, expected 'b' or 'c' binding
invalid register specification, expected 't' binding
Invalid register type for dcl.  Must be input register (v#), output register (o#) or sampler (s#).
Invalid register type for dcl.  Must be input register (v#), sampler (s#), position (vPos) or face (vFace).
Invalid register type for dcl.  Must be input register (v#).
Invalid register type for dcl.  Must be t#, v# or s#.
Invalid register type for destination param.
invalid register, input, or constant name '%s'
Invalid relative indexing register type for dimension %d.  Operand #%d of opcode #%d (counts are 1-based). Aborting.
Invalid representation for index dimension %d.  Opcode #%d, operand #%d (counts are 1-based). 
Invalid resource dimension on resource t%d.  Opcode #%d (count is 1-based). 
Invalid resource dimension on resource u%d.  Opcode #%d (count is 1-based). 
Invalid resource return type on component %d of resource t%d.  Opcode #%d (count is 1-based). 
Invalid resource return type on component %d of resource u%d.  Opcode #%d (count is 1-based). 
Invalid sampler mode on sampler s%d.  Opcode #%d (count is 1-based). 
invalid semantic '%s' on pixel shader output
Invalid shader type used with %s
Invalid src mod for %s source param.
Invalid src mod for tex* instruction (%s source param).
Invalid src swizzle for %s source param.
Invalid stream index s%d.  Index must be between 0 and %d Opcode #%d (count is 1-based). 
Invalid StreamOut decl
Invalid StreamOut decl: %s
invalid subscript '%s'
invalid swizzle '%s'
Invalid Tessellator Domain specified. Must be isoline, tri or quad. Aborting. Opcode #%d (count is 1-based). 
Invalid Tessellator Output Primitive specified. Must be point, line, triangleCW or triangleCCW. Aborting. Opcode #%d (count is 1-based). 
Invalid Tessellator Partitioning specified. Must be integer, pow2, fractional_odd or fractional_even. Aborting. Opcode #%d (count is 1-based). 
Invalid texm* register.
Invalid texm* sequence.
invalid type for index - index must be a scalar, or a vector with the correct number of dimensions
invalid type used for '%s' %s semantics
invalid type used for '%s' %s semantics, must be %s
invalid usage modifier applied to %cbuffer
invalid variable reference in static variable initializer.  Locals cannot be used to initialize static variables
INVBLENDFACTOR
INVDESTALPHA
INVDESTCOLOR
INVERT
INVSRCALPHA
INVSRCCOLOR
is Accelerator group shared local
is Accelerator stub function
is compiled with /guard:cf
is compiled with /ltcg:pgo
is compiled with /sdl
is HLSL data
is interface class/struct
Is it compiled with -Bzalign
is live range of Accelerator pointer tag
is multiple inheritance
is pointer to data member
is pointer to member function
is ref class/struct
is single inheritance
is the function optimized for speed
is value class/struct
is virtual inheritance
is WinRT pointer
is_front_face
isAggregated
isCTypes
isCVTCIL
IsDebuggerPresent
isfinite
isFrontFace already declared for input.  Opcode #%d (count is 1-based). 
isFrontFace already declared for output.  Opcode #%d (count is 1-based). 
ISG1t
ISGNt
ISGNu5
ishl bits_known <| SFPS
ishl fp_flags <| SFPS
ishl int_literal <| SFPS
ishl(and(a, m), n) : if( and_is_identity_ignore_upper_n_bits(a, m, n) -> ishl(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(and(m, a), n) : if( and_is_identity_ignore_upper_n_bits(a, m, n) -> ishl(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(iadd(a, iv1), iv2) -> iadd(ishl(a, iv2), ishl(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(imul(a, iv1), iv2) : if(low_bit_clear(iv2)) -> imul(ishl(a, iv2/2), ishl(iv1, iv2/2)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(ineg(a), iv1) -> ineg(ishl(a, iv1)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(ishl(a, b), c) : if( nooverflow_mod_32(b, c) ) -> ishl(a, iadd(b, c)) <| MR.GenSimplifyInstructionsOpt1_Excl
ishl(or(a, m), n) : if( or_is_identity_ignore_upper_n_bits(a, m, n) -> ishl(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ishl(or(m, a), n) : if( or_is_identity_ignore_upper_n_bits(a, m, n) -> ishl(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
isHotpatchable
ishr bits_known <| SFPS
ishr fp_flags <| SFPS
ishr int_literal <| SFPS
ishr(ishr(a, b), c) : if( nooverflow_mod_32(b, c) ) -> ishr(a, iadd(b, c)) <| MR.GenSimplifyInstructionsOpt1_Excl
isinf
isMSILNetmodule
IsNaked
isnan
isoline
Isoline
ISOLINE
IsProcessorFeaturePresent
isSafeBuffers
isSplitted
isStripped
It is invalid to use eval_* on position input due to hardware limitation.  Opcode #%d (count is 1-based). 
iterator
itob bits_known <| SFPS
itob fp_flags <| SFPS
itob int_literal <| SFPS
itob int_range <| SFPS
itob(x) -> bine(x,0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
itod fp_flags <| SFPS
itof fp_flags <| SFPS
itof(ftoi(x)) -> trunc(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
J ;H 
j j@j
j!j@j
j"j@j
j#j@j
j$j@j
j%j@j
j&j@j
j(j@j
j)j@j
j*hH~
j*j@j
j,j@j
j.j@j
j/j@j
j:j@j
j;j@j
j?j@j
j@j@j
j[j@j
j\j@j
j]j@j
j^j@j
j_h\}
j_j@j
j`hl}
j`j@j
j+hh~
j+j@j
j<j@j
j=j@j
j>j@j
J0;Hds
j0j@j
j1j@j
j2j@j
j3j@j
j4j@j
j5j@j
j6j@j
j7j@j
j8j@j
j9j@j
jAj@j
jaj@j
jbhhE
jBj@j
jbj@j
jCj@j
jcj@j
jDj@j
jdj@j
jej@j
jEj@j
jFj@j
jfj@j
jgj@j
jGj@j
jhhL}
jhj@j
jHj@j
jij@j
jIj@j
j'j@j
j-j@j
jjj@j
jJj@j
jjjjh
jjjjj
jjjjjj
jjjjjjjj
jkj@j
jKj@j
jklmnopqrs
jlj@j
jLj@j
jmj@j
jMj@j
jnj@j
jNj@j
Join phase declared the same component(s) of output patch constant register o[#d] as already declared for output by a previous fork phase or other joint phase.
Join phase declaring component(s) of input patch constant register vpc[%d] which have not been output by previous fork phase(s) or other join phase(s).
jOj@j
joj@j
jpj@j
jPj@j
jQh F
jQh(F
jQhdE
jqj@j
jQj@j
jrj@j
jRj@j
jsj@j
jSj@j
jThHS
jTj@j
jtj@j
jUh(}
jUj@j
juj@j
jVh4}
jVj@j
jWh@}
jWj@j
jXj@j
jYj@j
jZj@j
K;X8wl
K@9BH
K<9K4
K<9Q$
K0_^[
K2Z2'767
K4@_^
K4+ClP
K49K<
k97u@j
kernel32.dll
KHOJGB
KHr w
KLF;q
KLj@Q
klmnk
KLMNOPQ
kN 4QPS
Known literals reduced to mov <| Explicit
L REL A*(L2<0) (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2<0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2>0) (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*(L2>0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*L2 where L2 < 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*L2 where L2 > 0 divides L as an INT <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A*L2 where L2 divides L as a UINT <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A+A (double) <| MR.GenSimplifyInstructionsOpt1_NoExcl
L REL A+A <| MR.GenSimplifyInstructionsOpt1_NoExcl
L$ ;L$
L$ ;L$L
L$ ;N
L$ ;O,
L$ ^[3
L$ 9L$
L$ 9L$l
L$ 9O,
L$ j P
L$ PW
L$ SQ
L$$f;D$(w
L$$PWj
L$$QP
L$$tO
L$(;T$
L$(3L$
L$(9t
L$(VR
L$(WP
L$,_^[3
L$,+H8
L$,+O8
L$,Ph
L$/QP
L$@;D$
L$@PVj
L$@WR
L$\F;
L$\QS
L$\SP
L$`3L$
L$|_^[3
L$|9O
L$|PSj
L$|Qj
L$<;D$$
L$<;L$T
L$<_^[3
L$<9L$T
L$<Qj
L$<QQh
L$<WP
L$0;O
L$09O
L$0QRPV
L$0t8
L$0Wj
L$0WR
L$0WRV
L$4;H
L$49H
L$49L$,vK
L$8;\$0r
L$8PVj
L$8PWj
L$8Qj
L$8u)
L$8VW
L$d;T$
L$D9L$,vF
L$DPj
L$DQPj
L$dSVW
L$DVR
L$DVW
L$FQP
L$H;L$
L$HQP
L$HQQh
L$HQR
L$I_^
L$JQP
L$KQP
L$l;H0s
L$L;M
L$l9O0
L$lVVWS
L$LWj
L$p;L$
L$p;L$D
L$T;L$
L$t;N
L$T_^
L$t9O
L$TF;u
L$TPhCLI4
L$TPhCTAB
L$tSP
L$XPj
L$XQj
L$XRP
L$Xt'
L=RSDSu
label
label (%d) already defined. Opcode #%d (count 1-based). 
label (%d) being defined without any callers. Shader Model 5+ requires all callers to a subroutine to appear before the subroutine definition. Aborting.Opcode #%d (count 1-based). 
label (%d) called but not defined.
label (%d) defined but never called.
label (%d) must be preceded by a ret. Opcode #%d (count 1-based). Aborting validation.
label (%d) must not be nested inside flow control. Opcode #%d (count 1-based). Aborting validation.
label (%d) was never used in the shader
Label is defined inside a subroutine or main program. Label must follow the ret instruction. Aborting shader validation. 
'label' is only permitted directly after a 'ret' instruction. Aborting shader validation. 
label parameter doesn't allow min precision.
Language
LASTBETA_D3DCOLOR
LASTBETA_UBYTE4
LASTPIXEL
late-resolve interface calls nested too deeply
LCMapStringW
ld does not support raw or structured buffers.  Opcode #%d, operand #%d (counts are 1-based). 
ld requires resource declared as texture1D/2D/3D/1DArray/2DArray.  Opcode #%d, operand #%d (counts are 1-based). 
ld_raw
ld_raw cannot be used on a resource that is not declared as raw (resource index [%d]). Opcode #%d (counts are 1-based).
ld_raw requires resource declared as Raw Buffer.  Opcode #%d, operand #%d (counts are 1-based). 
ld_raw_s
ld_structured
ld_structured cannot be used on a resource that is not declared as structured (resource index [%d]). Opcode #%d (counts are 1-based).
ld_structured requires resource declared as Structured Buffer.  Opcode #%d, operand #%d (counts are 1-based). 
ld_structured_s
ld_uav_typed
ld_uav_typed cannot be used on a UAV that is not declared as typed (u%d). Opcode #%d (counts are 1-based).
ld_uav_typed_s
ld2dms requires resource declared as texture2DMS/texture2DMSArray.  Opcode #%d, operand #%d (counts are 1-based). 
ldexp
ldms_s
LeaveCriticalSection
Legacy !A * (A + B) => !A * B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy !A + (A + B) => 1 + B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy (!A * A) => 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy (!A + A) => 1 + B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy (A || A) => A <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy A * !(A * B) => A * !B <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy -BOOL < BOOL => BOOL <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy C + (A * B) + (A * !B) => C + A <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy NOT (A || A) => NOT A <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy NOT GE => LT <| MR.GenSimplifyInstructionsOpt1_NoExcl
Legacy NOT LT => GE <| MR.GenSimplifyInstructionsOpt1_NoExcl
LegacyLocalResourceArrays
LegalCopyright
Length
length
Length
length
Length in bytes of segment.
length of live range
Length of source in bytes.
lengthBlock
lengthLocals
lengthParams
lengthProlog
lengthSavedRegisters
LERP(!A,B,C) -> LERP(A, C, B) <| MR.GenSimplifyInstructionsOpt1_NoExcl
lerp(fbool, a, 0) -> append_arg(a,0) <| SMR.RangeDataAnalysis
lerp(fbool, a, b) -> append_arg(a,b) <| SMR.RangeDataAnalysis
lerp(fbool, finite a, 0) -> append_arg(a,0) <| SMR.RangeDataAnalysis
lerp(fbool, finite a, finite b) -> append_arg(a,b) <| SMR.RangeDataAnalysis
LESS_EQUAL
LESSEQUAL
Level9
levels
LexicalParent
LexicalParentId
LF_ALIAS
LF_ALIAS_ST
LF_ARGLIST
LF_ARGLIST_16t
LF_ARRAY
LF_ARRAY_16t
LF_ARRAY_ST
LF_BARRAY
LF_BARRAY_16t
LF_BCLASS
LF_BCLASS_16t
LF_BINTERFACE
LF_BITFIELD
LF_BITFIELD_16t
LF_BUILDINFO
LF_CLASS
LF_CLASS_16t
LF_CLASS_ST
LF_COBOL0
LF_COBOL0_16t
LF_COBOL1
LF_DEFARG
LF_DEFARG_16t
LF_DEFARG_ST
LF_DERIVED
LF_DERIVED_16t
LF_DIMARRAY
LF_DIMARRAY_16t
LF_DIMARRAY_ST
LF_DIMCONLU
LF_DIMCONLU_16t
LF_DIMCONU
LF_DIMCONU_16t
LF_DIMVARLU
LF_DIMVARLU_16t
LF_DIMVARU
LF_DIMVARU_16t
LF_ENDPRECOMP
LF_ENUM
LF_ENUM_16t
LF_ENUM_ST
LF_ENUMERATE
LF_ENUMERATE_ST
LF_FIELDLIST
LF_FIELDLIST_16t
LF_FRIENDCLS
LF_FRIENDCLS_16t
LF_FRIENDFCN
LF_FRIENDFCN_16t
LF_FRIENDFCN_ST
LF_FUNC_ID
LF_HLSL
LF_INDEX
LF_INDEX_16t
LF_INTERFACE
LF_IVBCLASS
LF_IVBCLASS_16t
LF_LABEL
LF_LIST
LF_MANAGED
LF_MANAGED_ST
LF_MATRIX
LF_MEMBER
LF_MEMBER_16t
LF_MEMBER_ST
LF_MEMBERMODIFY
LF_MEMBERMODIFY_ST
LF_METHOD
LF_METHOD_16t
LF_METHOD_ST
LF_METHODLIST
LF_METHODLIST_16t
LF_MFUNC_ID
LF_MFUNCTION
LF_MFUNCTION_16t
LF_MODIFIER
LF_MODIFIER_16t
LF_MODIFIER_EX
LF_NESTTYPE
LF_NESTTYPE_16t
LF_NESTTYPE_ST
LF_NESTTYPEEX
LF_NESTTYPEEX_ST
LF_NULL
LF_OEM
LF_OEM_16t
LF_OEM2
LF_ONEMETHOD
LF_ONEMETHOD_16t
LF_ONEMETHOD_ST
LF_POINTER
LF_POINTER_16t
LF_PRECOMP
LF_PRECOMP_16t
LF_PRECOMP_ST
LF_PROCEDURE
LF_PROCEDURE_16t
LF_REFSYM
LF_SKIP
LF_SKIP_16t
LF_STMEMBER
LF_STMEMBER_16t
LF_STMEMBER_ST
LF_STRIDED_ARRAY
LF_STRING_ID
LF_STRUCTURE
LF_STRUCTURE_16t
LF_STRUCTURE_ST
LF_SUBSTR_LIST
LF_TYPESERVER
LF_TYPESERVER_ST
LF_TYPESERVER2
LF_UDT_SRC_LINE
LF_UNION
LF_UNION_16t
LF_UNION_ST
LF_VBCLASS
LF_VBCLASS_16t
LF_VECTOR
LF_VFTABLE
LF_VFTPATH
LF_VFTPATH_16t
LF_VFUNCOFF
LF_VFUNCOFF_16t
LF_VFUNCTAB
LF_VFUNCTAB_16t
LF_VTSHAPE
LFS0t
lib_%d_%d
lib_4_0
lib_4_0_level_9_1
lib_4_0_level_9_1_ps
lib_4_0_level_9_1_ps_only
lib_4_0_level_9_1_vs
lib_4_0_level_9_1_vs_only
lib_4_0_level_9_3
lib_4_0_level_9_3_ps_only
lib_4_0_level_9_3_vs
lib_4_0_level_9_3_vs_only
lib_4_1
lib_5_0
LIBFug
LIBHt
Library entry points cannot be overloaded ('%s')
LibraryName
LIGHTAMBIENT
LIGHTATTENUATION0
LIGHTATTENUATION1
LIGHTATTENUATION2
LIGHTDIFFUSE
LIGHTDIRECTION
LIGHTENABLE
LIGHTFALLOFF
LIGHTING
LIGHTPHI
LIGHTPOSITION
LIGHTRANGE
LIGHTSPECULAR
LIGHTTHETA
LIGHTTYPE
limit
lineadj
LINEAR
linear
LINEDEN
LINEDET
lineNumber
lineNumberEnd
LineNumbers
LineStream
Literal floating-point value out of integer range for conversion: %f
Literal floating-point value out of unsigned range for conversion: %f
Literal in Log * Mul * Exp pattern <| Explicit
literal loop terminated early due to out of bounds array access
LiveRangeStartAddressOffset
LiveRangeStartAddressSection
LiveRangeStartRelativeVirtualAddress
LMIRSZWT
lmnop
load fp_flags <| SFPS
load_o fp_flags <| SFPS
load_o_s fp_flags <| SFPS
load_s fp_flags <| SFPS
load_uav fp_flags <| SFPS
load_uav_s fp_flags <| SFPS
Load2
load2d_msaa fp_flags <| SFPS
load2d_msaa_o fp_flags <| SFPS
load2d_msaa_o_s fp_flags <| SFPS
load2darray_msaa fp_flags <| SFPS
load2darray_msaa_o fp_flags <| SFPS
load2darray_msaa_o_s fp_flags <| SFPS
Load3
Load4
LoadLibraryExW
local
Local root signatures only support shader visibility flag D3D12_SHADER_VISIBILITY_ALL.  ShaderVisibility value: %u (root parameter [%u]).
Local root signatures only support shader visibility flag D3D12_SHADER_VISIBILITY_ALL.  ShaderVisibility value: %u (static sampler [%u]).
local variables
LocalAlloc
LocalFree
LOCALVIEWER
location is dependent on control flow
location semantics cannot be specified on members
location semantics do not apply to %ss
LocationType
lod instruction requires sampler declared in default mode.  Opcode #%d, operand #%d (counts are 1-based). 
lod requires resource declared as texture1D/2D/3D/Cube/CubeArray/1DArray/2DArray.  Opcode #%d, operand #%d (counts are 1-based). 
log float_literal <| SFPS
log fp_flags <| SFPS
log fp_range <| SFPS
log fp_specials <| SFPS
log(exp(x)) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
log10
loop doesn't allow min precision on parameters.
loop doesn't seem to do anything, consider removing [loop]
loop doesn't seem to do anything, forcing loop to unroll
loop executes for more than %d iterations (maximum for this shader target), forcing loop to unroll
loop only executes for %d iteration(s), consider removing [loop]
loop only executes for %d iteration(s), forcing loop to unroll
loop requires first parameter to be loop counter (aL). 
loop simulation finished early, use /O1 or above for potentially better codegen
loop variables
loop will not exit early, try to make sure the loop condition as tight as possible
loop(a) -> append_sources() (loop predicate linkage) <| SMR.DataFlagAnalysis_NoPlaceHolder
loop/rep don't allow min precision on parameters.
loop_endif(a) -> append_arg(a, pred_a) <| SMR.DataFlagAnalysis
loop_endif(a,b) -> append_arg(a,b,p_a) <| SMR.DataFlagAnalysis
loop_in(completed a) -> o->append_inloop() <| SMR.DataFlagAnalysis
loop_in(completed a) -> o->append_inloop() <| SMR.RangeDataAnalysis
loopif fp_flags <| SFPS
loopif_consume fp_flags <| SFPS
LowerBound
LowerBoundId
lstrcmpiA
lt float_literal <| SFPS
lt fp_flags <| SFPS
lt fp_range <| SFPS
lt of known range reduction <| Explicit
lt(a, b) -> cmp(a - b, 0f, 1f) <| MR.Gen_RequiredTranslate
L-value Reference
l-value specifies const object
M$PRQ
M*x* matrix instructions cannot write to scalar output register.
M*x* matrix instructions cannot write to scalar output registers (oFog, oPts).
MachineType
mad float_literal <| SFPS
mad fp_flags <| SFPS
mad fp_range <| SFPS
mad fp_specials <| SFPS
mad match 1 (a + b*c) <| MR.GenMad
mad match 2 (a - b*c) <| MR.GenMad
mad match 3 (a + b+b) <| MR.GenMad
mad match 4 (a - b+b) <| MR.GenMad
MAGFILTER
malformed #hlsl_full_path
Managed
MapViewOfFile
MapViewOfFileEx
Masks (and if pixel shader, also interpolation mode) on all input registers in an index range must be identical. Input register %s[%d] does not match with others in the index range from %d to %d. 
MATERIAL
MATERIALAMBIENT
MATERIALDIFFUSE
MATERIALEMISSIVE
MATERIALPOWER
MATERIALSPECULAR
Matrices cannot be specified in temp registers with the fragment linker
matrix
matrix dimensions must be between 1 and %u
matrix dimensions must be literal scalar expressions
matrix element type must be a scalar type
matrix is row major
matrix types cannot be both column_major and row_major
max 0/min 1 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
max float_literal <| SFPS
max fp_flags <| SFPS
max fp_range <| SFPS
max fp_specials <| SFPS
Max index for effect state '%s' is %d
max of known positive identity <| Explicit
max of neg idenity to abs instruction match <| Explicit
max(a, -a) -> abs <| MR.Gen_RequiredTranslate
max(a, b) -> cmp(a - b, a, b) <| MR.Gen_RequiredTranslate
max(i, neg(i)) -> abs <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
max(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
max(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
max(max(i0, l1), l2) -> max(i0, max(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
max(x,y) where range of one is >= the other (ieee safe version) <| Explicit
max(x,y) where range of one is >= the other <| Explicit
MAXANISOTROPY
maxAnisotropy
MaxAnisotropy
maximum %s %s register index (%u) exceeded - note that the minimum index is %u%s
maximum %s %s register index (%u) exceeded%s
Maximum %s control point count (%u) exceeded (%u).
maximum %s register index exceeded, target has %d slots, manual bind to slot %s failed
maximum address register index exceeded
maximum bool register index exceeded
maximum cbuffer exceeded. target has %u slots
maximum cbuffer exceeded. target has %u slots, manual bind to slot %u failed
maximum constant register index exceeded - Try reducing number of constants referenced
maximum input register index exceeded
maximum loop register index exceeded
maximum number of inputs exceeded
maximum number of interface pointers exceeded (%s max is %u)
maximum number of samplers exceeded. %s target can have a maximum of %u samplers
Maximum of 3 cmp instructions allowed.
Maximum of 4 dp4 instructions allowed.
maximum predicate register index exceeded
maximum sampler register index exceeded
Maximum semantic index (%d) exceeded: %d
maximum temp register index exceeded
MAXLOD
maxLOD
MaxLOD
MaxLOD be in the range [-INF to +INF].  %f specified.
MAXMIPLEVEL
maxStack
MAXTESSELLATIONLEVEL
maxtessfactor
maxvertexcount
MaxVertexCount
members
memcpy
memmove
memory exhausted
memory space kind
memset
merge and flip discard_nz test with an earlier bieq comparison <| MR.GenSimplifyInstructionsOpt1_NoExcl
merge and flip discard_z test with an earlier bieq comparison <| MR.GenSimplifyInstructionsOpt1_NoExcl
merge discard_nz test with an earlier bine comparison <| MR.GenSimplifyInstructionsOpt1_NoExcl
merge discard_z test with an earlier bine comparison <| MR.GenSimplifyInstructionsOpt1_NoExcl
message
method
Method and Parameters
methods
MGxyNVHIWXYQ1234567
Microsoft
Microsoft (R) D3D Shader Disassembler
Microsoft (R) D3DX9 Shader Assembler 10.1
Microsoft (R) D3DX9 Shader Disassembler
Microsoft (R) HLSL Shader Compiler 10.1
Microsoft (R) Optimizing Compiler
Microsoft (R) Shader Linker
Microsoft C/C++ MSF 7.00
Microsoft C/C++ program database 2.00
Microsoft Corporation
min 1/max 0 -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_Excl
min float_literal <| SFPS
min fp_flags <| SFPS
min fp_range <| SFPS
min fp_specials <| SFPS
min of known positive identity <| Explicit
Min precision not allowed on dest parameter.
Min precision not allowed on predicate register.
Min precision not allowed on predicate/loop/addr register.
Min precision types not allowed for operand #%d of opcode #%d (counts are 1-based). 
min(a, b) -> cmp(a - b, b, a) <| MR.Gen_RequiredTranslate
min(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
min(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
min(min(i0, l1), l2) -> min(i0, min(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
min(x,y) where range of one is <= the other (ieee safe version) <| Explicit
min(x,y) where range of one is <= the other <| Explicit
MIN_LINEAR_MAG_MIP_POINT
MIN_LINEAR_MAG_POINT_MIP_LINEAR
MIN_MAG_LINEAR_MIP_POINT
MIN_MAG_MIP_LINEAR
MIN_MAG_MIP_POINT
MIN_MAG_POINT_MIP_LINEAR
MIN_POINT_MAG_LINEAR_MIP_POINT
MIN_POINT_MAG_MIP_LINEAR
min10float
min12int
min16f
min16float
min16i
min16int
min16u
min16uint
min2_8f
min8float
min8uint
MINFILTER
Minimum precision types used in a shader that does not have minimum precision support enabled. 
Minimum-precision data types
minLOD
MinLOD
MINTESSELLATIONLEVEL
MIPFILTER
MIPLODBIAS
mipLODBias
MipLODBias
MIPMAPLODBIAS
MIRROR
MIRROR_ONCE
MIRRORONCE
Mismatch between shader declaration of 11.1 double extensions and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare 11.1 double extensions use and a Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Mismatch between shader declaration of 11.1 double extensions and shader declaration of double precision floats. If a shader declares 11.1 double extensions use it must also declare double precision float use. 
Mismatch between shader declaration of 11.1 shader extensions and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare 11.1 shader extensions use and a Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Mismatch between shader declaration of double precision floats and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare double precision float use and a Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Mismatch between shader declaration of minimum precision and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare minimum precision use and a Shader Feature Info blob must specify the same thing as well, or neither should request it. 
Mismatch between shader declaration of raw and structured buffers for shader 4_x and accompanying Shader Feature Info blob (or lack thereof). Both the shader must declare raw and structured buffer use and a Shader Feature Info blob must specify the same thing as well, or neither should request it. 
mixed
MNOPQRS
MODULATE
MODULATE2X
MODULATE4X
MODULATEALPHA_ADDCOLOR
MODULATECOLOR_ADDALPHA
MODULATEINVALPHA_ADDCOLOR
MODULATEINVCOLOR_ADDALPHA
Module %d
modulo
More than 2 constants (even identical ones) cannot be read by an instruction. (There is one exception: this rule does not apply to the SINCOS instruction.)
MostRecentApplication
mov fp_flags <| SFPS
mov mov <| SFPS
mov of sampler register reduction <| Explicit
mova instruction can only write to the address register.
movc and comparison sequence reductions <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc float_literal <| SFPS
movc fp_flags <| SFPS
movc fp_specials <| SFPS
movc(!a,b,c) -> movc(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc((a<b),b,a) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc((a>=b),a,b) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, and(b, c), 0) -> and(and(a, b), c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, b, and(c, b)) -> and(or(a, c), b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, b, i/ushr/l(a, n)) -> movc(a, b, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, b, movc(c, b, d)) -> movc(or(a, c), b, d) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, i/ushr/l(a, n), 0) -> i/ushr/l(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a, true, b) -> or(a, b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a,b,b) -> mov(b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a,b,c) -> append_arg(b, c) <| SMR.RangeDataAnalysis
movc(a,false,true) -> bieq(a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(a,true,false) -> bine(a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(b & iv_pow2, (b & m) | -iv_pow2, b) -> ibfe(get_first_bit(iv_pow2), 0, (b&m)) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(b & iv_pow2, b | -iv_pow2, b) -> ibfe(get_first_bit(iv_pow2), 0, b) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(b & iv_pow2, bfi(w, 0, (b & m), -iv_pow2)) -> ibfe(get_first_bit(iv_pow2), 0, (b&m)) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(b & iv_pow2, bfi(w, 0, b, -iv_pow2), b) -> ibfe(get_first_bit(iv_pow2), 0, b) <| MR.GenD3D10_OptimizeEarlyTranslate
movc(b, a, b) -> movc (b, a, 0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(blt(a, 0), |a|, a) -> abs(a) <| MR.GenD3D10PreMod_NoExcl
movc(bool b, bool b, false) -> mov b <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool b, FALSE, TRUE) -> not b <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool b, TRUE, bool c) -> or(b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool b, TRUE, FALSE) -> mov b <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(bool,x,0) -> and(bool,x) <| MR.GenSimplifyInstructionsOpt2_NoExcl
movc(c,a,ignore) -> mov(a) <| MR.GenSimplifyInstructionsAlways_Both
movc(c,d=movc(c,a,b),f) -> movc(c,a,f) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(c,f,d=movc(c,a,b)) -> movc(c,f,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(c,ignore,a) -> mov(a) <| MR.GenSimplifyInstructionsAlways_Both
movc(c,ignore,ignore) -> ignore(0) <| MR.GenSimplifyInstructionsAlways_Both
movc(false,b,c) -> append_arg(b) <| SMR.RangeDataAnalysis
movc(false,b,c) -> mov(c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(i/ushr(a, n),v1, v2) : if(lower_n_bits_are_zero(a, n)) -> movc (a, v1, v2) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(ishl(a, n),v1, v2) : if(upper_n_bits_are_zero(a, n)) -> movc (a, v1, v2) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(movc(a,FALSE,TRUE),b,c) -> movc(a,c,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(movc(a,TRUE,FALSE),b,c) -> movc(a,b,c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(true,b,c) -> append_arg(b) <| SMR.RangeDataAnalysis
movc(true,b,c) -> mov(b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc(u/ishr/l(a, n), movc(a, b, c), d) -> movc(u/ishr/l(a, n), b, d) <| MR.GenSimplifyInstructionsOpt1_NoExcl
movc, binary_compute on same value -> binary_compute, movc <| MR.GenShuffleCompute_NoExcl
movc, binary_compute on values -> binary_compute, movc <| MR.GenShuffleCompute_NoExcl
movc, binary_compute on values lhs -> binary_compute, movc <| MR.GenShuffleCompute_Excl
movc, binary_compute on values rhs -> binary_compute, movc <| MR.GenShuffleCompute_Excl
movc, quat arg1 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg1 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg1 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg2 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg2 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg2 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg3 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg3 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg3 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg4 on values -> quat, movc <| MR.GenShuffleCompute_NoExcl
movc, quat arg4 on values lhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, quat arg4 on values rhs -> quat, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg1 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
movc, ternary arg1 on values lhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg1 on values rhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg2 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
movc, ternary arg2 on values lhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg2 on values rhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg3 on values -> ternary, movc <| MR.GenShuffleCompute_NoExcl
movc, ternary arg3 on values lhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, ternary arg3 on values rhs -> ternary, movc <| MR.GenShuffleCompute_Excl
movc, unary_compute on values -> unary_compute, movc <| MR.GenShuffleCompute_NoExcl
movc, unary_compute on values lhs -> unary_compute, movc <| MR.GenShuffleCompute_Excl
movc, unary_compute on values rhs -> unary_compute, movc <| MR.GenShuffleCompute_Excl
MSAA Sample Index must be a literal
MSAA Sample Index must be in the range 0 to %u
msad bits_known <| SFPS
msad fp_flags <| SFPS
msad int_literal <| SFPS
msad int_range <| SFPS
msad4
mul float_literal <| SFPS
mul fp_flags <| SFPS
mul fp_range <| SFPS
mul of a half times add of same value identity <| Explicit
mul of a number times its inverse identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
mul of double one identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
mul of one identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
mul(1f,a) -> append_arg(a) <| SMR.RangeDataAnalysis
mul(fbool,a) -> append_arg(0f,a) <| SMR.RangeDataAnalysis
mul(fbool,finite a) -> append_arg(0f,a) <| SMR.RangeDataAnalysis
Mulitply by 1 reduces to no-op move <| Explicit
MultiByteToWideChar
multiple concrete base types specified
Multiple constant registers cannot be read by a matrix op.
Multiple dependent texture reads are disallowed (%s source param).  Texture read results can be used as an address for subsequent read, but the results from that read cannot be used as an address in yet another subsequent read.
Multiple fork phase programs cannot declare partially overlapping index ranges for output Patch Constant Data. One index range is from register [%d] to [%d], while the another is from [%d] to [%d].
Multiple fork phase programs declared the same component(s) of output patch constant register o[#d].
Multiple fork/join phase programs cannot declare partially overlapping index ranges for output Patch Constant Data. One index range is from register [%d] to [%d], while the another is from [%d] to [%d].
Multiple Hull Shader phases cannot call the same interface body. If this is an important feature, support could be considered in the future. Opcode #%d (count is 1-based)
Multiple Hull Shader phases cannot call the same subroutine. If this is an important feature, support could be considered in the future. Opcode #%d (count is 1-based)
Multiple input registers cannot be read by a matrix op.
Multiple input/texture registers cannot be read by a matrix op.
Multiple phase markers not permitted.  Aborting shader validation.
multiple variables found with the same user-specified location
multiply
Multiply by 0 reduces to literal 0 <| Explicit
Multiply by -1 reduces to NEG operation <| Explicit
Multiply by 2, 4, or 8 <| Explicit
MULTIPLYADD
MULTISAMPLEANTIALIAS
MultisampleEnable
MULTISAMPLEMASK
must be equal to the number of threads in the group (%d in this case).  %d elements were specified for g%d. 
Must use texture register a dest param for tex* instructions.
mutable
N ;H8s
N0;Hds
n0+1R1r1
Named register components cannot appear to the left (xyzw order) of components that are not named in a given register. TessFactors are an exception. Affected register is input %d. 
Named register components cannot appear to the left (xyzw order) of components that are not named in a given register. TessFactors are an exception. Affected register is output %d in stream m%d. 
Named register components cannot appear to the left (xyzw order) of components that are not named in a given register. TessFactors are an exception. Affected register is output %d. 
namespace
namespace %s
NaN and infinity literals not allowed by shader model
Needs to be replaced with a real rule
neg float_literal <| SFPS
neg fp_flags <| SFPS
neg fp_range <| SFPS
neg fp_specials <| SFPS
negate
negate and divide modifiers cannot be combined
negate modifier match <| Explicit
Negate modifier not allowed for operand #%d of opcode #%d (counts are 1-based). 
negative bool less then another bool identity <| Explicit
Negative value compared with zero <| Explicit
Negative values for cmp and clip can be rordered <| Explicit
Nested
NEVER
NEWFPO
NF;sPr
Nl@;C
Nl+Nh
NLC;Y
NLG;y
no classes implement '%s'
No include handler specified, can't perform a #include. Use D3DX APIs or provide your own include handler.
NoInline
nointerpolation
nointerpolation 
nointerpolation usage unsupported on %s
noise
Non system-generated input signature parameter (%s) cannot appear after a system generated value.
non-empty case statements must have break or return
non-literal parameter(s) found for attribute %s
non-matrix types cannot be declared 'row_major' or 'column_major'
non-numeric case expression
non-numeric sample count
non-numeric vertex count
non-scalar case expression
non-trivial object expressions not yet implemented
NonUniformResourceIndex
'NonUniformResourceIndex' requires shader model 5 or higher
nop instruction cannot be co-issued.
noperspective
noperspective 
noperspective centroid 
noperspective sample 
noperspective usage unsupported on %s
NOPQ9:?@H
NOPQRS
NoReturn
Normal
normal
NORMAL
NORMALDEGREE
normalize
normalize(normalize(v)) -> normalize(v) <| MR.GenSimplifyInstructionsOpt1_NoExcl
NORMALIZENORMALS
Not all elements of SV_Position were written
NOT BEQ => BNE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BGE => BLT (safe) <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BGE => BLT <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BIEQ => BINE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BIGE => BILT <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BILT => BIGE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BINE => BIEQ <| MR.GenSimplifyInstructionsOpt1_Excl
not bits_known <| SFPS
NOT BLT => BGE (safe) <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BLT => BGE <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BNE => BEQ <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BUGE => BULT <| MR.GenSimplifyInstructionsOpt1_Excl
NOT BULT => BUGE <| MR.GenSimplifyInstructionsOpt1_Excl
not cannot be used with other modifiers
not enough actual parameters for macro '%s'
not fp_flags <| SFPS
not int_literal <| SFPS
NOT_EQUAL
notCached
note that in IEEE strict mode, all values are implicitly marked precise
Note that the %s component of %s%d was previously initialized, but then became uninitialized by a previous instruction (e.g. SINCOS clobbers components).
NOTEQUAL
notPaged
nullify clip ops on known positive values <| MR.GenSimplifyInstructionsOpt1_NoExcl
nullify discard ops on known false values <| MR.GenSimplifyInstructionsOpt1_NoExcl
num32BitConstants
num32BitConstants must be defined for each RootConstants
number of Accelerator pointer tags
number of columns in a matrix
number of HLSL register indices
Number of instruction slots used too high: %d. Max. allowed is %d.
number of live ranges
number of modifiers
number of rows in a matrix
numDescriptors
NumDescriptors cannot be 0 (descriptor table slot [%u], root parameter [%u]).
Numeric variables ('%s') can't be shared; share the containing cbuffer instead
numthreads
NX^[]
nx1^_`abc"
O ;H 
o = $IsStandardLoad(a, chain) -> append_addressed(o, chain) (all sources) <| SMR.DataFlagAnalysis_NoPlaceHolder
o = dfuse(ab) -> o->append_dfuse() <| SMR.DataFlagAnalysis
O 9H 
O Qh`
O,_^]
O@_^]
O<;K<s
O0HPS
o1g2{2
O4_^[
O8T>[
object element type cannot be an object type
object file name
Object filename.
object literals are not allowed inside functions
ObjectFileName
ObjectLength
ObjectPointerType
Objects not allowed in structures
object's templated type must have at least one element
oC%d already written. (oCn registers can only be written at most once each)
oCn registers may only be written using the mov instruction.
octal value truncated to 64 bits
Odd Fractional
oDepth
oDepth already written.
oDepth may not be written by the %s instruction.
oDepth may only be written using the mov instruction.
oDepthGE
oDepthLE
OEMId
OEMSymbolId
Offset
offset
Offset in physical section.
offset into UDT
offset of exception handler
offset texture instructions must take offset which can resolve to integer literal in the range -8 to 7
OL;GPu
OMAPFROM
OMAPTO
oMask
OMSetRenderTargets
On current device, %s requires the condition%s parameter to be boolean constant register (b#). 
On current device, %s requires the condition%s parameter to be predicate register (p0). 
one of "integer", "pow2", "fractional_even", or "fractional_odd"
one of "point", "line", "triangle_cw", or "triangle_ccw"
one of "tri", "quad", or "isoline"
one of '%s'
One of the instructions in a co-issue pair must write to alpha only (.a writemask).
Only 3_x and earlier targets are supported on this compiler.
Only 4_x targets supported on this compiler.
only a0.x is allowed as a relative address register in vs_1_1
Only immediate32 indexing permitted for operand #%d of opcode #%d (counts are 1-based). Aborting.
Only numeric types and strings are allowed as annotations
Only numeric variables ('%s') can be added to a cbuffer
only one address register reference allowed in a relative address expression
only one address register reference is allowed in a relative address expression
Only one use of texdepth is permitted.
Only single-dimensional object arrays are allowed
Only the mov instruction is allowed to write to the address register.
Only the mova instruction is allowed to write to the address register.
only vs_1_1, vs_2_0, vs_2_x, vs_2_sw, ps_2_0, ps_2_x, and ps_2_sw are supported for assembly fragments
operator
operator cannot be used with a bool lvalue
opqro
OPSV3
or bits_known <| SFPS
or fp_flags <| SFPS
or int_flags <| SFPS
or int_literal <| SFPS
or(a, b) : if( and_is_zero(a, b) ) -> iadd(a, b) <| MR.GenD3D10PostMod_Both
or(a, iv2) : if( can_reduce_or(a, iv2) ) -> or(a, get_reduced_or(a, iv2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(and(a, iv1), iv2) if(and_ne_zero(iv1, iv2) -> or(and(a, iv1 & ~iv2), iv2) <| MR.GenSimplifyInstructionsOpt1_Excl
or(bfalse,a) -> append_arg(a) <| SMR.RangeDataAnalysis
or(ine(x,0),ine(y,0)) -> ine(or(x,y),0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(or(a, b), c) : if( or_is_identity(c, b) ) -> or(a, c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(or(b, a), c) : if( or_is_identity(c, b) ) -> or(a, c) <| MR.GenSimplifyInstructionsOpt1_NoExcl
or(true,a) -> append_arg(true,a) <| SMR.RangeDataAnalysis
original
OriginalFilename
OSG1u
OSG5t.A;
OSGNt
OSGNt.A;
OSGNu
OSGNuX
oShOSGN
oStencilRef
Ot_[]
out of memory
Out of memory
out of memory during compilation
out of memory while parsing
Out of memory.
Out of memory. Aborting shader validation. 
out parameters require l-value arguments
out parameters require l-value arguments (given argument is implicitly const, such as a global)
output
Output
output %s%u used more than once
Output control point count must be [0..%d].  %d specified.  Opcode #%d (count is 1-based). 
Output index range declaration out of range.  Opcode #%d (count is 1-based). 
Output index range defined from %d to %d includes output register %d that was not declared. 
output parameter 
Output register cannot be dcl'd with usage 'sample'.
Output register dcl'd with usage+index psize0 takes as special meaning as a scalar, so no writemask must be specified (identical to full write mask). In addition, no other semantics may declared for the same output register as one assigned to psize0. 
Output signature cannot be defined for a library function.
Output signature does not specify component %d of register %d which is declared in the shader code. 
Output signature name mismatch with declaration in shader code for component %d in register %d. 
Output signature parameter #%d (1-based) specifies out of range register %d. 
Output signature parameter #%d (1-based) specifies register %d (or components in the register) that have already been defined. 
Output value '%s' is not completely initialized
Output variable 
output_consume fp_flags <| SFPS
outputcontrolpoints
OutputDebugStringA
OutputPatch
Outputs
outputtopology
Overflow for descriptor range (descriptor table slot [%u], root parameter [%u])
Overflow for shader register range: BaseShaderRegister=%u, NumDescriptor=%u; (descriptor table slot [%u], root parameter [%u]).
Overflow of resource binding range
Overlapping input index range decl encountered.  Opcode #%d (count is 1-based). 
Overlapping output index range decl encountered.  Opcode #%d (count is 1-based). 
overlapping output semantics
overlapping register semantics not yet implemented '%c%u'
overlapping register semantics not yet implemented 'c%u'
overloaded function not found
OverloadedOperator
p,A;N
P@;Q@r
P<;Q<r)w
p<`t6
p<`t8
p4_^[
pack_matrix
Packed
packoffset
packoffset cannot have a target qualifier
packoffset is only allowed in a constant buffer
Parameter '%s' can be specified only once
parameter count mismatch (%s)
Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.) 
Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.).  The exception is (on shader version > ps_2_0) if the condition is the predicate register, p0, in which case a replicate swizzle must be used in order to select a component. i.e. .x | .y | .z | .w (or rgba equivalent) 
Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.).  The exception is (on shader version > vs_2_0) if the condition is the predicate register, p0, in which case a replicate swizzle must be used in order to select a component. i.e. .x | .y | .z | .w (or rgba equivalent) 
Parameter(s) for %s instruction must specify default swizzle (.xyzw, or none specified.).  The exception is if the condition is the predicate register, p0, in which case a replicate swizzle must be used in order to select a component. i.e. .x | .y | .z | .w (or rgba equivalent)
Parameters
partial precision is not supported for target %s. Min-precision types may offer similar functionality.
Partials
partitioning
partitioning mode
passes
PASSTHRU
Patch Constant
Patch constant signature name mismatch with declaration in shader code for component %d in register %d. 
Patch constant signature parameter #%d (1-based) specifies out of range register %d. 
Patch constant signature parameter #%d (1-based) specifies register %d (or components in the register) that have already been defined. 
Patch constant signature signature does not specify component %d of register %d which is declared in the shader code. 
Patch semantics must live in the enclosed type, outer semantic ignored.
patchconstantfunc
PATCHEDGESTYLE
PATCHSEGMENTS
PCSGt
-PCSGt*-
PCSGu(
PDATA
PDB is available at IL merge time
pdr_?
pdr_m
pdr_robj
pdr_s
pdr_sc
pdr_t
pdr_tb
pdr_ts
pdr_ub
pdr_us
pdr_ut
PERFu[
Ph    
Ph0{.
PhAon9
phase
Phase marker cannot be co-issued.
phase this function is a member of for PGO multiphased builds
PhCLIT
PhCTAB
PhFXLC
PhISGNhISG1
PhISGNhISGN
PhLFS0hLFS0
PhLIBF
PhLIBH
PHONG
PhOSGNhOSG1
PhOSGNhOSGN
PhRDEFhRDEF
PhSHEX
PhSTAT
PIXEL
Pixel Shader allows output semantics to be SV_Target, SV_Depth, SV_DepthGreaterEqual, SV_DepthLessEqual, SV_Coverage only, or SV_StencilRef.  Output signature parameter #%d (1-based) specifies semantic %s. 
pixel shader must minimally write all four components of %s
pixel shader must minimally write all four components of COLOR0
Pixel shader must minimally write to oC0 (with a mov instruction).
pixelfragment
PixelShader
pixelshader
PIXELSHADER
PIXELSHADERCONSTANT
PIXELSHADERCONSTANT1
PIXELSHADERCONSTANT2
PIXELSHADERCONSTANT3
PIXELSHADERCONSTANT4
PIXELSHADERCONSTANTB
PIXELSHADERCONSTANTF
PIXELSHADERCONSTANTI
Pj hP@
Pj(QQV
PjthSTAT
placement_mov fp_flags <| SFPS
placement_mov mov <| SFPS
Platform
PLt"=
PLtF=
PLwQt:
point
POINT
Point
pointer based on value of a symbol
POINTSCALE_A
POINTSCALE_B
POINTSCALE_C
POINTSCALEENABLE
POINTSIZE
POINTSIZE_MAX
POINTSIZE_MIN
POINTSPRITEENABLE
PointStream
pos cmp sequence -> sat <| MR.Gen_OptimizeEarlyTranslate_SAT_NoExcl
Position
POSITION
position
position already declared for input.  Opcode #%d (count is 1-based). 
position already declared for output.  Opcode #%d (count is 1-based). 
position declaration must have xyzw mask.  Opcode #%d (count is 1-based). 
POSITIONDEGREE
POSITIONT
PositionT
positiont
positive sqrt(x*x) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
Possible %ss are:
Possible integer divide by zero
Post-call locations: 
potentially unintended use of a comma expression in a return statement
potentially unintended use of a comma expression in a variable initializer
pow(f, e) will not work for negative f, use abs(f) or conditionally handle negative values if you expect them
PPPPh
PPPPj
PPPPR
PPRSh
ppShader pointer is invalid
PPSRj
PQhdB
PQhH{
PQhP&
PQhp]
PQhP4
PQhPt
PQhx4
PQQh(`
PQSh 
PQSVQ
PQSVW
pragma
precise
precise 
Precise mask not permitted for opcode #%d (counts are 1-based). 
pred move(a) -> append_arg(a) <| SMR.RangeDataAnalysis
predicate doesn't allow min precision.
predicate parameter doesn't allow min precision.
Predicate register (p0) parameter to %s instruction must specify replicate swizzle in order to select component. i.e. .x | .y | .z | .w (or rgba equivalent)
Predicate register read, but uninitialized. Note that the predicate register must be written by setp before it is used, and that flow control instructions invalidate the predicate register's contents. Affected components(*): %s
predicates are not supported in this shader version
PREMODULATE
preshader
preshader abs -> max(i, neg(i)) <| MR.Gen_RequiredTranslate_Preshader
preshader sat -> min(max(i, 0), 1) <| MR.Gen_RequiredTranslate_Preshader
PRESW
Previous writer to the first source register of lrp instruction should apply the saturate destination modifier.  This ensures consistent behaviour across different hardware. Affected components(*) of first source register: %s
PRhlg
PRhxw
PRIMID
primitive_id
primitiveID already declared for input.  Opcode #%d (count is 1-based). 
primitiveID already declared for output.  Opcode #%d (count is 1-based). 
printf
printf 
Prior locations: 
private
PRIVt
Process2DQuadTessFactorsAvg
Process2DQuadTessFactorsMax
Process2DQuadTessFactorsMin
ProcessIsolineTessFactors
ProcessQuadTessFactorsAvg
ProcessQuadTessFactorsMax
ProcessQuadTessFactorsMin
ProcessTriTessFactorsAvg
ProcessTriTessFactorsMax
ProcessTriTessFactorsMin
ProductName
ProductVersion
program
PROJECTED
PROJECTIONTRANSFORM
propagate range info through mov <| Explicit
propagate special floating point values through add <| Explicit
propagate special floating point values through asin <| Explicit
propagate special floating point values through atan2 <| Explicit
propagate special floating point values through div <| Explicit
propagate special floating point values through log <| Explicit
propagate special floating point values through mul <| Explicit
propagate special floating point values through rcp <| Explicit
propagate special floating point values through rsq <| Explicit
propagate special floating point values through sqrt <| Explicit
propogate swizzles <| Explicit
protected
proto
PRQhDZ
PRQhLZ
PS Inner Coverage
PS input vCoverage already declared.  Opcode #%d (count is 1-based). 
PS input vCoverage declared, cannot also declare vInnerCoverage (features are mutually exclusive).  Opcode #%d (count is 1-based). 
PS input vInnerCoverage already declared.  Opcode #%d (count is 1-based). 
PS input vInnerCoverage declared, cannot also declare vCoverage (features are mutually exclusive).  Opcode #%d (count is 1-based). 
PS input vInnerCoverage requires feature flag enableInnerCoverage.  Opcode #%d (count is 1-based). 
PS ouputs must be declared in slots less than UAVs.  Output declared in slot %d while UAV declared in slot %d.  Opcode #%d (count is 1-based). 
PS output coverage mask already declared.  Opcode #%d (count is 1-based). 
PS output depth already declared.  Opcode #%d (count is 1-based). 
PS output depth already declared.  The previous declaration was of a different type.  Opcode #%d (count is 1-based). 
PS Output Stencil Ref
PS output stencil ref already declared.  Opcode #%d (count is 1-based). 
PS output stencil ref requires feature flag enableStencilRef.  Opcode #%d (count is 1-based). 
ps.1.0
ps.1.1
ps.1.2
ps.1.3
ps.1.4
ps.2.0
ps.2.a
ps.2.b
ps.2.sw
ps.2.x
ps.3.0
ps.3.sw
ps_%d_%d
ps_1_0
ps_1_0 is no longer supported.  It turned out that pixel shader capable hardware will always support at least ps_1_1 (which is not as limited a model as ps_1_0 was). To convert a ps_1_0 shader up to ps_1_1, the only change needed is to make the version number 1_1. 
ps_1_0 is no longer supported; using ps_1_1
ps_1_1
ps_1_2
ps_1_3
ps_1_4
ps_1_x is no longer supported; use /Gec in fxc to automatically upgrade to ps_2_0
ps_1_x is no longer supported; using ps_2_0
ps_2_0
ps_2_0 does not support predication.
ps_2_a
ps_2_b
ps_2_sw
ps_2_x
ps_2_x extended instruction not supported by the hardware (dynamic flow control not supported).
ps_2_x extended instruction not supported by the hardware (gradient instructions not supported).
ps_2_x extended instruction not supported by the hardware (neither predication or static flow control supported).
ps_2_x extended instruction not supported by the hardware (predication not supported).
ps_2_x extended instruction not supported by the hardware (static flow control not supported).
ps_3_0
ps_3_sw
ps_4_0
ps_4_0_level_9_0
ps_4_0_level_9_1
ps_4_0_level_9_3
ps_4_1
ps_5_0
ps_5_1
PSh80
Psize
PSIZE
psize
PSize
PSIZE must be a scalar
PSj j
PSjPj
PSQh(
PSQhH
PSRh(
PSRhP
PSRWh
PSVW3
PSVWj
public
PVSRQ
PWj(j
PWjPj
PYRAMIDALQUAD
Q,_^[
Q3y4 ;
Q4;Q8
QD+Q@V
QhDBUG
QhPRES
Qjbh` 
Qjch` 
QjHRPV
Qjih` 
Qjsj@h
Qjsj@j
Qjtj@j
Qjuj@j
Qkkbal
qL@F;B
QPh@d
QPhHJ
QPhp"
QPj0j
QQQQf
QQQQP
QQSVW
QRPhSDTL
QRSTUV
QSPhCRPT
QSPhSDTL
QSPhSMID
QSVWj
QSVWj0
Qt"h8
QUADEDGE
QUADINT
QUADRATIC
Quadrilateral
QueryPerformanceCounter
QUINTIC
Qw4tg
QWVhRTS0
r | (a & n) : if( known_bfi_bitmask_noshift(n,a,r) && and_is_zero(n,r) ) -> bfi(bfi_bitwidth_noshift(n,a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
r | (a = bfi(w, o, v, 0i)) : if( mask_is_zero(w,o,r) ) -> bfi(w, o, v, r) <| MR.GenSimplifyInstructionsOpt1_Excl
r | (n & a) : if( known_bfi_bitmask_noshift(n,a,r) && and_is_zero(n,r) ) -> bfi(bfi_bitwidth_noshift(n,a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
r | a : if( known_bfi_bitmask_noshift_impmask(a,r) && and_is_zero(a,r) ) -> bfi(bfi_bitwidth_noshift_impmask(a,r), 0i, a, r) <| MR.GenD3D10_OptimizeEarlyTranslate_Excl
r HPQhX.
r PQWh
r RSh(
r!HPR
r!HPSh
r#_^3
r#HPQh
r%HPQWh *
r%HPSQh *
r%HPWSh *
r&PQWhH
r(QPh
r)9|$$w#r
r)HPhdE
r,PQWhH
r.HPRh
r/w+cnt
r@;0s=
r0 must be written by shader. Uninitialized component%s(*): %s
r0 must be written by shader. Uninitialized component%s(*): %s. Note that an unfortunate effect of the phase marker in the shader is that the moment it is encountered in certain hardware, values previously written to alpha in any r# register, including r0, are lost. So after a phase marker, the alpha component of r0 must be written.
r0 must be written by shader. Uninitialized component%s(*): %s. Note that when texcrd is used with a .xy(==.rg) writemask, as it is in this shader, a side effect is that anything previously written to the z(==b) component of the destination r# register is lost and this component becomes uninitialized. The blue component of r0 must to be written after the texcrd.
r0 must be written by shader. Uninitialized component%s(*): %s. Note that when texcrd is used with a .xy(==.rg) writemask, as it is in this shader, a side effect is that anything previously written to the z(==b) component of the destination r# register is lost and this component becomes uninitialized. The blue component of r0 must to be written after the texcrd. Also: Note that an unfortunate effect of the phase marker in the shader is that the moment it is encountered in certain hardware, values previously written to alpha in any r# register, including r0, are lost. So after a phase marker, the alpha component of r0 must be written.
r4HPRh<
r6HPRh
r7HPWh
race condition writing to shared memory detected, consider making this write conditional.
race condition writing to shared memory detected, note that threads will be writing the same value, but performance may be diminished due to contention.
race condition writing to shared resource detected, consider making this write conditional.
race condition writing to shared resource detected, note that threads will be writing the same value, but performance may be diminished due to contention.
radians
range sequence reduction <| Explicit
RANGEFOGENABLE
raSearch
raSearchStart
Raster Ordered UAVs
Rasterizer
rasterizer
RasterizerOrdered objects are only allowed in 5.0+ pixel shaders
RasterizerOrderedBuffer
RasterizerOrderedByteAddressBuffer
RasterizerOrderedStructuredBuffer
RasterizerOrderedTexture1D
RasterizerOrderedTexture1DArray
RasterizerOrderedTexture2D
RasterizerOrderedTexture2DArray
RasterizerOrderedTexture3D
RasterizerState
Raw or Structured buffers can't be declared in shader model 4_* VS/GS/PS without enabling them via a global flags declaration.. 
raw_buffer
RawDensityFactor
RawDetailFactor
RawEdgeFactors
rcp float_literal <| SFPS
rcp fp_flags <| SFPS
rcp fp_range <| SFPS
rcp fp_specials <| SFPS
rcp(mul(x, rsq(x)) = rsq(x) identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
rcp_approx
rcp_approx float_literal <| SFPS
rcp_approx fp_flags <| SFPS
rcp_approx fp_range <| SFPS
rcp_approx fp_specials <| SFPS
RD11t
RDEFt
RDEFt)
Read allowed.
Read of uninitialized component%s(*) in %s%d: %s
Read of uninitialized component%s(*) in %s%d: %s. Note that an unfortunate effect of the phase marker earlier in the shader is that the moment it is encountered in certain hardware, values previously written to alpha in any r# register, including the one noted here, are lost. In order to read alpha from an r# register after the phase marker, write to it first.
Read of uninitialized component%s(*) in %s%d: %s. Note that when texcrd is used with a .xy(==.rg) writemask, as it is in this shader, a side effect is that anything previously written to the z(==b) component of the destination r# register is lost and this component becomes uninitialized. In order to read blue again, write to it first.
Read of uninitialized component%s(*) in %s%d: %s. Note that when texcrd is used with a .xy(==.rg) writemask, as it is in this shader, a side effect is that anything previously written to the z(==b) component of the destination r# register is lost and this component becomes uninitialized. In order to read blue again, write to it first. Also: Note that an unfortunate effect of the phase marker earlier in the shader is that the moment it is encountered in certain hardware, values previously written to alpha in any r# register, including the one noted here, are lost. In order to read alpha from an r# register after the phase marker, write to it first.
ReadFile
Reading from texture buffers is unsupported on %s
Reading uninitialized value
reading uninitialized value
redefinition of '%s'
Redefinition of derivative, derivatives may only be assigned once.
redefinition of formal parameter '%s'
Redefinition of pass "%s"
redefinition of type with interface
redefinition of type with struct/class
reduce literal lit instruction <| Explicit
reduce mov instruction <| Explicit
refactoringAllowed
reference
Reference of register oDepth does mot match declaration (dcl_oDepthGE or dcl_oDepthLE).  Opcode #%d, operand #%d (counts are 1-based). 
Reference of register oDepthGE does mot match declaration (dcl_oDepth or dcl_oDepthLE).  Opcode #%d, operand #%d (counts are 1-based). 
Reference of register oDepthLE does mot match declaration (dcl_oDepth or dcl_oDepthGE).  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of indexable temp x%d[] within relative index of an operand.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of indexable temp x%d[].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of input vCycleCounter.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of input vInputThreadGroupID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of input vInputThreadID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared components of input vInputThreadIDInGroup.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared constant buffer cb%d[].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared immediate constant buffer.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared indexable temp x%d[].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base v%s[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base vcp[][%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base vocp[][%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of index range input starting at base vpc[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of input v%s[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of input vcp[][%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of input vocp[][%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input or undeclared components of input vpc[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared input vInputThreadIDInGroupFlattened.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared output or undeclared components of index range output starting at base o[%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared output or undeclared components of output o%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oDepth.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oDepthGE.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oDepthLE.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oMask.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register oStencilRef.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vCoverage.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vForkPhaseInstanceID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vGSInstanceID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vInnerCoverage.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vJoinPhaseInstanceID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vOutputControlPointID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared register vPrimitiveID.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared resource t%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared sampler s%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared stream m%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared temp r%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared thread group shared memory g%d[].  Opcode #%d, operand #%d (counts are 1-based). 
Reference of undeclared UAV u%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, [%d], on cb%d[size==%d] (if size is listed as 0, it means default size is used, which is %d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, [%d], on g%d[size==%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, [%d], on immediate constant buffer [size==%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, [%d], on x%d[size==%d].  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of bounds, cb%d.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range of indexable temp x%d[] within relative index of an operand.  Index [%d] specified, but based on the indexable temp declaration, the max index allowed is [%d].  Operand #%d of opcode #%d (counts are 1-based). Aborting.
Reference out of range on vertex axis for input v[%d][].  Input control point has %d vertices.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range on vertex axis for input v[%d][].  Input primitive type has %d vertices.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range on vertex axis for input vcp[%d][].  Input control point has %d vertices.  Opcode #%d, operand #%d (counts are 1-based). 
Reference out of range on vertex axis for input vocp[%d][].  Output control points has %d vertices.  Opcode #%d, operand #%d (counts are 1-based). 
reflect
refract
Reg num: %d for %s source param on matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d.
RegCloseKey
RegEnumKeyExA
register
register %s not valid
Register %s%d has already been declared.
Register data that has been read by a texbem or texbeml instruction cannot be read later, except by another texbem/l.
register offset must be a literal scalar expression
register or offset bind %s not valid
register or offset bind %s.%s not valid
Register r%d (and thus texture stage %d) already used as a destination for a tex* instruction in this block of the shader. Reuse of a texture stage in ps_1_4 may only be accmplished by splitting the tex* ops across a phase marker.
register type kind
RegisterId
Registers in an input index range cannot have system names associated with them (TessFactors are an exception).  Input register %s[%d] has a name and is in an index range from %d to %d. 
Registers in an output index range cannot have system names associated with them (TessFactors are an exception).  Output register o%d has a name and is in an index range from o%d to o%d. 
RegOpenKeyExA
RegOpenKeyExW
RegQueryValueExA
RegQueryValueExW
reinterpret_cast
Related TessFactor names (such as edges) must be declared in the same component of consecutive Patch Constant registers, in the correct order. %s expected in %s[%d].%s since %s is in %s[%d].%s.
Related TessFactor names (such as edges) must be declared in the same component of consecutive Patch Constant registers, in the correct order. %s is in %s[%d].%s, which would put %s past the end of the available registers, since it is %d name after %s in the order.
Relative address for input (v#) can only be aL register (%s source param).
Relative address must specify a single component selector (.x, .y, .z or .w) to indicate relative address component. Aborting validation.
relative address references too deep
Relative address register for constant (c#) must be a# register or aL register (%s source param).
Relative address register must be a# register or aL register (%s source param).
Relative address register must be aL register (%s source param).
relative addressing not allowed for pixel shaders
relative addressing not supported in vs_1_0 instruction set
Relative addressing of constant register must reference a0.x only.
Relative addressing of destination not permitted on destination in this shader model.
Relative addressing of destination only permitted on output registers (o#).
relative addressing of destination parameters is not supported in this shader version
Relative addressing of o# register requires aL register.
relative addressing of predicates is not supported in this shader version
Relative addressing of source register only permitted on input (v#) and constant (c#) registers (%s source param).
Relative addressing only permitted on constant registers (%s source param).
Relative addressing only permitted on input (v#) registers (%s source param).
Relative indexing input register from base %s[%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base %s[0] not allowed when register 0 has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vcp[][%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vcp[0] not allowed when register 0 has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vocp[][%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vpc[%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing input register from base vpc[0] not allowed when register 0 has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing not allowed for cb%d since it was not declared for dynamic indexing..  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing output register from base o[%d] not allowed when register %d has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
Relative indexing output register from base o[0] not allowed when register 0 has not been declared in an index range.  Opcode #%d, operand #%d (counts are 1-based). 
RelativeVirtualAddress
relocCRC
remove
Remove args for CBuffers that are never read <| Explicit
remove clip chains that are merged with known-success clips <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove clips that are merged with known-success clips <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove discard chains that are merged with known-success discards <| MR.GenSimplifyInstructionsOpt1_NoExcl
remove discards that are merged with known-success discards <| MR.GenSimplifyInstructionsOpt1_NoExcl
Remove temp array stores that are immediately overwritten <| Explicit
rendertarget_array_index
renderTargetArrayIndex already declared for input.  Opcode #%d (count is 1-based). 
renderTargetArrayIndex already declared for output.  Opcode #%d (count is 1-based). 
renderTargetArrayIndex or viewportArrayIndex must have scalar mask in declaration.  Opcode #%d (count is 1-based). 
RenderTargetView
RenderTargetWriteMask
reorder instructions to minimize register load <| Explicit
rep doesn't allow min precision on parameter.
rep requires parameter to be integer constant register (i#). 
REPLACE
replace bitwise double-complement with move <| MR.GenSimplifyInstructionsOpt1_NoExcl
Required TessFactor name %s for %s domain not found declared anywhere in Patch Constant data. 
Reserved bit(s) set in dcl info token!  Aborting validation.
Reserved bit(s) set in destination parameter token!  Aborting validation.
Reserved bit(s) set in instruction parameter token!  Aborting validation.
Reserved bit(s) set in parameter %d source token!  Aborting validation.
Reserved bit(s) set in relative address token for source parameter %d!  Aborting validation.
Reserved bit(s) set in source %d parameter token!  Aborting validation.
reserved0
ResetEvent
resinfo
resinfo fp_flags <| SFPS
resinfo requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray/2DMS/2DMSArray.  Opcode #%d, operand #%d (counts are 1-based). 
resinfo_uint fp_flags <| SFPS
resource
resource '%s' binding conflicts with template shader
resource '%s' binding not present in template shader
Resource being indexed is uninitialized.
Resource bind info for
Resource dimension and return type extended opcodes not expected on opcode #%d (counts are 1-based). 
Resource t%d already declared.  Opcode #%d (count is 1-based). 
Resources being indexed cannot come from conditional expressions, they must come from literal expressions.
resources such as textures, samplers or UAVs cannot contain other resources
RestartStrip
result
RESULTARG
ret can only be followed by case/default/endswitch/endloop/else/endif/label. Opcode #%d (count 1-based). Aborting validation.
'ret' instruction not permitted from inside any flow control block. Aborting shader validation. 
return
return address of the frame
return C++ style UDT
return fp_flags <| SFPS
return from interrupt
return never match (to NOP) <| MR.GenSimplifyInstructionsAlways_Both
return type of texture too large. Cannot exceed 4 components
return(a,bieq(x,0)) -> returnn(a,x) <| MR.Gen_PreModTarget_Both
return(a,bine(x)) -> return(a,x) <| MR.Gen_PreModTarget_Both
return(a,not(x)) -> returnn(a,x) <| MR.Gen_PreModTarget_Both
return_consume fp_flags <| SFPS
returna match <| MR.GenD3D10PostMod_Both
REV_SUBTRACT
reversebits
reversebits bits_known <| SFPS
reversebits fp_flags <| SFPS
reversebits int_literal <| SFPS
reversebits(i) -> and/shift/or sequence <| MR.Gen_RequiredTranslate
REVSUBTRACT
rFHPR
Rich>
Root descriptor flag values can only be 0 or flag enum values, found: '%s'
Root descriptor flags cannot be specified for root_sig_1_0
Root descriptor flags cannot specify more than one DATA_* flag at a time (root descriptor flags %x).
Root parameter [%u] descriptor table entry [%u] specifies RegisterSpace=%#x, which is invalid since RegisterSpace values in the range [%#x,%#x] are reserved for system use.
Root parameter [%u] specifies RegisterSpace=%#x, which is invalid since RegisterSpace values in the range [%#x,%#x] are reserved for system use.
root signature
Root signature flag values can only be 0 or flag enum values, found: '%s'
RootConstants
RootFlags
RootFlags cannot be specified more than once
rootsig_1_0
rootsig_1_1
RootSignature
RootSignature attribute parameter must be a string
RootSignature creation failed: %s
RootSignature is allowed only for 5.0+ targets
RootSignature is not allowed in HS patch constant function
RootSignature verification failed: %s
round
round float_literal <| SFPS
round fp_flags <| SFPS
round fp_range <| SFPS
round fp_specials <| SFPS
round_ne
round_ni
round_pi
round_z
RoundedDensityFactor
RoundedDetailFactorr
RoundedEdgeFactors
RoundedInsideFactor
RoundedInsideFactors
row_major
row_major 
row_major %s%ux%u
RPCRT4.dll
RPLYP
RPLYu
RQh I
RQh(m
RQhhH
RQhlG
RQVQj
RSDSi
rsq float_literal <| SFPS
rsq fp_flags <| SFPS
rsq fp_range <| SFPS
rsq fp_specials <| SFPS
rsq result can be assumed positive <| Explicit
rsq(x) * rsq(x) -> rcp(x) <| MR.GenSimplifyInstructionsOpt1_Excl
rsq(x) * rsq(x) -> rcp(x) for positive x <| MR.GenSimplifyInstructionsOpt1_Excl
rsqrt
RTINDEX
RTS0t
rTSVW
ruledisable
R-value Reference
RWBuffer
RWByteAddressBuffer
RWStructuredBuffer
RWStructuredBuffer(Decrementable)
RWStructuredBuffer(Incrementable)
RWStructuredBuffers may increment or decrement their counters, but not both.
RWTexture1D
RWTexture1DArray
RWTexture2D
RWTexture2DArray
RWTexture3D
S#9SPv&;sPs
S_ALIGN
S_ANNOTATION
S_ANNOTATIONREF
S_ARMSWITCHTABLE
S_ATTR_FRAMEREL
S_ATTR_MANYREG
S_ATTR_REGISTER
S_ATTR_REGREL
S_BLOCK16
S_BLOCK32
S_BLOCK32_ST
S_BPREL16
S_BPREL32
S_BPREL32_16t
S_BPREL32_ST
S_BUILDINFO
S_CALLEES
S_CALLERS
S_CALLSITEINFO
S_CEXMODEL16
S_CEXMODEL32
S_COBOLUDT
S_COBOLUDT_16t
S_COBOLUDT_ST
S_COFFGROUP
S_COMPILE
S_COMPILE2
S_COMPILE2_ST
S_COMPILE3
S_CONSTANT
S_CONSTANT_16t
S_CONSTANT_ST
S_CVRESERVE
S_DATAREF
S_DATAREF_ST
S_DEFRANGE
S_DEFRANGE_DPC_PTR_TAG
S_DEFRANGE_FRAMEPOINTER_REL
S_DEFRANGE_FRAMEPOINTER_REL_FULL_SCOPE
S_DEFRANGE_HLSL
S_DEFRANGE_REGISTER
S_DEFRANGE_REGISTER_REL
S_DEFRANGE_SUBFIELD
S_DEFRANGE_SUBFIELD_REGISTER
S_DISCARDED
S_DPC_SYM_TAG_MAP
S_END
S_ENDARG
S_ENTRYTHIS
S_ENVBLOCK
S_EXPORT
S_FILESTATIC
S_FRAMECOOKIE
S_FRAMEPROC
S_GDATA_HLSL
S_GDATA_HLSL32
S_GDATA_HLSL32_EX
S_GDATA16
S_GDATA32
S_GDATA32_16t
S_GDATA32_ST
S_GMANDATA
S_GMANDATA_ST
S_GMANPROC
S_GMANPROC_ST
S_GPROC16
S_GPROC32
S_GPROC32_16t
S_GPROC32_ID
S_GPROC32_ST
S_GPROCIA64
S_GPROCIA64_ID
S_GPROCIA64_ST
S_GPROCMIPS
S_GPROCMIPS_16t
S_GPROCMIPS_ID
S_GPROCMIPS_ST
S_GTHREAD32
S_GTHREAD32_16t
S_GTHREAD32_ST
S_HEAPALLOCSITE
S_INLINESITE
S_INLINESITE_END
S_INLINESITE2
S_LABEL16
S_LABEL32
S_LABEL32_ST
S_LDATA_HLSL
S_LDATA_HLSL32
S_LDATA_HLSL32_EX
S_LDATA16
S_LDATA32
S_LDATA32_16t
S_LDATA32_ST
S_LMANDATA
S_LMANDATA_ST
S_LMANPROC
S_LMANPROC_ST
S_LOCAL
S_LOCAL_DPC_GROUPSHARED
S_LOCALSLOT
S_LOCALSLOT_ST
S_LPROC16
S_LPROC32
S_LPROC32_16t
S_LPROC32_DPC
S_LPROC32_DPC_ID
S_LPROC32_ID
S_LPROC32_ST
S_LPROCIA64
S_LPROCIA64_ID
S_LPROCIA64_ST
S_LPROCMIPS
S_LPROCMIPS_16t
S_LPROCMIPS_ID
S_LPROCMIPS_ST
S_LPROCREF
S_LPROCREF_ST
S_LTHREAD32
S_LTHREAD32_16t
S_LTHREAD32_ST
S_MANCONSTANT
S_MANFRAMEREL
S_MANFRAMEREL_ST
S_MANMANYREG
S_MANMANYREG_ST
S_MANMANYREG2
S_MANMANYREG2_ST
S_MANREGISTER
S_MANREGISTER_ST
S_MANREGREL
S_MANREGREL_ST
S_MANSLOT
S_MANSLOT_ST
S_MANTYPREF
S_MANYREG
S_MANYREG_16t
S_MANYREG_ST
S_MANYREG2
S_MANYREG2_ST
S_OBJNAME
S_OBJNAME_ST
S_OEM
S_PARAMSLOT
S_PARAMSLOT_ST
S_PDBMAP
S_POGODATA
S_PROC_ID_END
S_PROCREF
S_PROCREF_ST
S_PUB16
S_PUB32
S_PUB32_16t
S_PUB32_ST
S_REF_MINIPDB
S_REGISTER
S_REGISTER_16t
S_REGISTER_ST
S_REGREL16
S_REGREL32
S_REGREL32_16t
S_REGREL32_ST
S_RESERVED1
S_RESERVED2
S_RESERVED3
S_RESERVED4
S_RETURN
S_SECTION
S_SEPCODE
S_SKIP
S_SLINK32
S_SSEARCH
S_THUNK16
S_THUNK32
S_THUNK32_ST
S_TOKENREF
S_TRAMPOLINE
S_UDT
S_UDT_16t
S_UDT_ST
S_UNAMESPACE
S_UNAMESPACE_ST
S_VFTABLE16
S_VFTABLE32
S_VFTABLE32_16t
S_WITH16
S_WITH32
S_WITH32_ST
S0;p<
S0;q<
s3z3 ;';
s4f;w
S8;p4
S8;q4
S82W8
Sample
SAMPLE
sample
sample 
Sample Bias value is limited to the range [-16.00, 15.99], using %f instead of %f
sample count must be non-zero
sample interpolation usage unsupported on %s
Sample interpolation usage unsupported on %s
sample/_l/_d requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray.  Opcode #%d, operand #%d (counts are 1-based). 
sample/_l/_d/_cl_s instructions require sampler declared in default mode.  Opcode #%d, operand #%d (counts are 1-based). 
sample_* instructions require resource to be declared to return UNORM, SNORM or FLOAT.  Opcode #%d, operand #%d (counts are 1-based). 
sample_b
sample_b requires resource declared as texture1D/2D/3D/Cube/1DArray/2DArray.  Opcode #%d, operand #%d (counts are 1-based). 
sample_b requires sampler declared in default mode.  Opcode #%d, operand #%d (counts are 1-based). 
sample_b_cl_s
sample_c
sample_c_* instructions require resource declared as texture1D/2D/Cube, but arrays not allowed.  Opcode #%d, operand #%d (counts are 1-based). 
sample_c_* instructions require resource declared as texture1D/2D/Cube/1DArray/2DArray/CubeArray.  Opcode #%d, operand #%d (counts are 1-based). 
sample_c_* instructions require sampler declared in comparison mode.  Opcode #%d, operand #%d (counts are 1-based). 
sample_c_cl_s
sample_c_lz
sample_c_lz_s
sample_cl_s
sample_d
sample_d_cl_s
sample_l
sample_l_s
sample1d fp_flags <| SFPS
sample1d_a fp_flags <| SFPS
sample1d_a_o fp_flags <| SFPS
sample1d_a_o_cl_s fp_flags <| SFPS
sample1d_bias fp_flags <| SFPS
sample1d_bias_a fp_flags <| SFPS
sample1d_bias_a_o fp_flags <| SFPS
sample1d_bias_a_o_cl_s fp_flags <| SFPS
sample1d_bias_l fp_flags <| SFPS
sample1d_bias_o fp_flags <| SFPS
sample1d_bias_o_cl_s fp_flags <| SFPS
sample1d_c fp_flags <| SFPS
sample1d_c_a fp_flags <| SFPS
sample1d_c_a_o fp_flags <| SFPS
sample1d_c_a_o_cl_s fp_flags <| SFPS
sample1d_c_lz fp_flags <| SFPS
sample1d_c_lz_a fp_flags <| SFPS
sample1d_c_lz_a_o fp_flags <| SFPS
sample1d_c_lz_a_o_s fp_flags <| SFPS
sample1d_c_lz_o fp_flags <| SFPS
sample1d_c_lz_o_s fp_flags <| SFPS
sample1d_c_o fp_flags <| SFPS
sample1d_c_o_cl_s fp_flags <| SFPS
sample1d_dd fp_flags <| SFPS
sample1d_dd_a fp_flags <| SFPS
sample1d_dd_a_o fp_flags <| SFPS
sample1d_dd_a_o_cl_s fp_flags <| SFPS
sample1d_dd_o fp_flags <| SFPS
sample1d_dd_o_cl_s fp_flags <| SFPS
sample1d_lod fp_flags <| SFPS
sample1d_lod_a fp_flags <| SFPS
sample1d_lod_a_o fp_flags <| SFPS
sample1d_lod_a_o_s fp_flags <| SFPS
sample1d_lod_l fp_flags <| SFPS
sample1d_lod_o fp_flags <| SFPS
sample1d_lod_o_s fp_flags <| SFPS
sample1d_o fp_flags <| SFPS
sample1d_o_cl_s fp_flags <| SFPS
sample2d fp_flags <| SFPS
sample2d_a fp_flags <| SFPS
sample2d_a_o fp_flags <| SFPS
sample2d_a_o_cl_s fp_flags <| SFPS
sample2d_bias fp_flags <| SFPS
sample2d_bias_a fp_flags <| SFPS
sample2d_bias_a_o fp_flags <| SFPS
sample2d_bias_a_o_cl_s fp_flags <| SFPS
sample2d_bias_l fp_flags <| SFPS
sample2d_bias_o fp_flags <| SFPS
sample2d_bias_o_cl_s fp_flags <| SFPS
sample2d_c fp_flags <| SFPS
sample2d_c_a fp_flags <| SFPS
sample2d_c_a_o fp_flags <| SFPS
sample2d_c_a_o_cl_s fp_flags <| SFPS
sample2d_c_lz fp_flags <| SFPS
sample2d_c_lz_a fp_flags <| SFPS
sample2d_c_lz_a_o fp_flags <| SFPS
sample2d_c_lz_a_o_s fp_flags <| SFPS
sample2d_c_lz_o fp_flags <| SFPS
sample2d_c_lz_o_s fp_flags <| SFPS
sample2d_c_o fp_flags <| SFPS
sample2d_c_o_cl_s fp_flags <| SFPS
sample2d_dd fp_flags <| SFPS
sample2d_dd_a fp_flags <| SFPS
sample2d_dd_a_o fp_flags <| SFPS
sample2d_dd_a_o_cl_s fp_flags <| SFPS
sample2d_dd_o fp_flags <| SFPS
sample2d_dd_o_cl_s fp_flags <| SFPS
sample2d_lod fp_flags <| SFPS
sample2d_lod_a fp_flags <| SFPS
sample2d_lod_a_o fp_flags <| SFPS
sample2d_lod_a_o_s fp_flags <| SFPS
sample2d_lod_l fp_flags <| SFPS
sample2d_lod_o fp_flags <| SFPS
sample2d_lod_o_s fp_flags <| SFPS
sample2d_o fp_flags <| SFPS
sample2d_o_cl_s fp_flags <| SFPS
sample3d fp_flags <| SFPS
sample3d_bias fp_flags <| SFPS
sample3d_bias_l fp_flags <| SFPS
sample3d_bias_o fp_flags <| SFPS
sample3d_bias_o_cl_s fp_flags <| SFPS
sample3d_dd fp_flags <| SFPS
sample3d_dd_o fp_flags <| SFPS
sample3d_dd_o_cl_s fp_flags <| SFPS
sample3d_lod fp_flags <| SFPS
sample3d_lod_l fp_flags <| SFPS
sample3d_lod_o fp_flags <| SFPS
sample3d_lod_o_s fp_flags <| SFPS
sample3d_o fp_flags <| SFPS
sample3d_o_cl_s fp_flags <| SFPS
SampleBias
SampleCmp
SampleCmpLevelZero
samplecube fp_flags <| SFPS
samplecube_a fp_flags <| SFPS
samplecube_a_cl_s fp_flags <| SFPS
samplecube_bias fp_flags <| SFPS
samplecube_bias_a fp_flags <| SFPS
samplecube_bias_a_cl_s fp_flags <| SFPS
samplecube_bias_cl_s fp_flags <| SFPS
samplecube_bias_l fp_flags <| SFPS
samplecube_c fp_flags <| SFPS
samplecube_c_a fp_flags <| SFPS
samplecube_c_a_cl_s fp_flags <| SFPS
samplecube_c_cl_s fp_flags <| SFPS
samplecube_c_lz fp_flags <| SFPS
samplecube_c_lz_a fp_flags <| SFPS
samplecube_c_lz_a_s fp_flags <| SFPS
samplecube_c_lz_s fp_flags <| SFPS
samplecube_cl_s fp_flags <| SFPS
samplecube_dd fp_flags <| SFPS
samplecube_dd_a fp_flags <| SFPS
samplecube_dd_a_cl_s fp_flags <| SFPS
samplecube_dd_cl_s fp_flags <| SFPS
samplecube_lod fp_flags <| SFPS
samplecube_lod_a fp_flags <| SFPS
samplecube_lod_a_s fp_flags <| SFPS
samplecube_lod_l fp_flags <| SFPS
samplecube_lod_s fp_flags <| SFPS
SampleGrad
sampleIndex
sampleIndex already declared for input.  Opcode #%d (count is 1-based). 
sampleinfo
sampleinfo fp_flags <| SFPS
sampleinfo_rt fp_flags <| SFPS
sampleinfo_uint fp_flags <| SFPS
sampleinfo_uint_rt fp_flags <| SFPS
SampleLevel
samplepos
samplepos fp_flags <| SFPS
samplepos_rt fp_flags <| SFPS
SAMPLER
sampler
Sampler
Sampler %s%d already declared. 
Sampler descriptor ranges can't specify DATA_* flags since there is no data pointed to by samplers (descriptor range flags %x).
Sampler descriptor ranges can't specify DESCRIPTORS_STATIC_KEEPING_BUFFER_BOUNDS_CHECKS, since there are no bounds to check (descriptor range flags %x).
sampler mismatch: sampler used inconsistently
Sampler parameter must come from a literal expression.
sampler register (s%u) used more than once
sampler register s#
Sampler register s# must be defined for each static sampler
Sampler register s%d has not been declared.
sampler requires an 's' or 't' register
Sampler s%d already declared.  Opcode #%d (count is 1-based). 
sampler slot start
Sampler variable '%s' does not specify the sampler type.  Explicit sampler types required for asm fragments.
Sampler: s%u
sampler_c
sampler_state
sampler1D
sampler2D
sampler3D
SamplerComparisonState
samplerCUBE
Samplers cannot be mixed with other resource types in a descriptor table (root parameter [%u]).
Samplers: s%u-s%u
SamplerState
samples
sat float_literal <| SFPS
sat fp_flags <| SFPS
sat fp_range <| SFPS
sat instruction to sat modifier match <| Explicit
saturate
Saturate modifier not permitted for opcode #%d (counts are 1-based). 
sbyte
Scalar output register must have full write mask.
Scalar output registers (oFog, oPts) must have full write mask.
scalar registers cannot be masked
scalar registers cannot be swizzled
scalar value expected
scalar, vector, or matrix expected
ScissorEnable
SCISSORTESTENABLE
scope
Scoped
SCt =
Sd;Sh
SDBGP
SDTLt
search for instancing opportunities in hull shaders <| Explicit
second
Second and third source parameters for SINCOS cannot be the same constant register.
Second and third source parameters for SINCOS cannot have a modifier.
Second and third source parameters for SINCOS must use default swizzle (no swizzle specified, or .xyzw). 
Second and third source params for SGN cannot use a source selector, and cannot have a modifier. 
Second and third source params for SGN must both be different temp (r#) registers.
Second source parameter for bem must be temp (r#) register.
Second source parameter for SINCOS must be a constant register.
Second source parameter for texld can't specify min precision.
Second source parameter for texld must be sampler stage (s#).
Second source parameter for texld* must be sampler stage (s#).
Second source parameter for texldl must be sampler stage (s#).
Second source parameter for texm3x3spec must be c#.
Second source paramter for SINCOS must be a constant register.
secondary array dimensions must be explicit
section number of exception handler
SECTIONHEADERS
SECTIONHEADERSORIG
Sections
SegmentMap
SELECTARG1
SELECTARG2
SELECTMASK
semantic '%s' unsupported on %s
Semantic length is limited to %d characters
semantics in type overridden by variable/function or enclosing type
SEPARATEALPHABLENDENABLE
Sequence of compares <| Explicit
SetBlendState
SetComputeShader
SetDepthStencilState
SetDomainShader
SetEndOfFile
SetEvent
SetFileAttributesW
SetFilePointer
SetFilePointerEx
SetGeometryShader
SetHullShader
SetLastError
SetPixelShader
SetRasterizerState
SetUnhandledExceptionFilter
SetVertexShader
SGV must have scalar mask in declaration.  Opcode #%d (count is 1-based). 
SHA256
SHADEMODE
Shader CBV descriptor range (BaseShaderRegister=%u, NumDescriptors=%u, RegisterSpace=%u) is not fully bound in root signature
shader exceeds maximum supported number of interface call sites (%d).  Opcode #%d (count 1-based).
Shader extensions for 11.1
Shader has root bindings but root signature uses a DENY flag to disallow root binding access to the shader stage.
Shader has too much flow control complexity for the target (%s). 
Shader missing end token.
Shader model %s doesn't allow reading from position semantics.
Shader model %s is not allowed in D3D10 techniques
Shader Model 5+ requires that subroutine definitions appear after any call(s) to the subroutine. This also implies recursion is not allowed, although that may or may not be the case here.  Aborting. Opcode #%d (count 1-based).
shader register
shader register must be defined for each CBV/SRV/UAV
Shader register range of type %s %s overlaps with another shader register range %s.
Shader sampler descriptor range (BaseShaderRegister=%u, NumDescriptors=%u, RegisterSpace=%u) is not fully bound in root signature
Shader SRV descriptor range (BaseShaderRegister=%u, NumDescriptors=%u, RegisterSpace=%u) is not fully bound in root signature
Shader UAV descriptor range (BaseShaderRegister=%u, NumDescriptors=%u, RegisterSpace=%u) is not fully bound in root signature
Shader uses texture addressing operations in a dependency chain that is too complex for the target shader model (%s) to handle.
Shader uses texture addressing operations in a dependency chain that is too complex for the target shader model (%s) to handle.  
Shader uses too many (%u) indexable literal values, the maximum allowed is %u, consider using less constant arrays
shader version expected
Shader@0x%p
SHADER_VISIBILITY_ALL
SHADER_VISIBILITY_DOMAIN
SHADER_VISIBILITY_GEOMETRY
SHADER_VISIBILITY_HULL
SHADER_VISIBILITY_PIXEL
SHADER_VISIBILITY_VERTEX
ShaderFeatureInfo blob must not specify 4x raw and structured buffers for Compute Shaders, or for any shader 5_0+.
Shaders compiled for %s can only have a single group shared data item
share
shared
SHDRP
SHDRQ
SHDRt
SHEXP
SHEXs#
SHEXt
ShFX10
shift of commutative inputs <| Explicit
shift of commutative literals <| Explicit
short
ShSFI0
ShSHDR
SHwFt.=
Signature
signed
signed char
signed integer division is not supported on minimum-precision types. Cast to int to use 32-bit division.
signed integer remainder is not supported on minimum-precision types. Cast to int to use 32-bit division.
signed/unsigned mismatch between destination and value, unsigned assumed
signed/unsigned mismatch, unsigned assumed
simplify array merges that repeatedly chain in the same value <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that bring in chain input <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that bring in chain input via mov left <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that bring in chain input via mov right <| MR.GenSimplifyInstructionsOpt1_NoExcl
simplify chain merges that repeatedly chain in the same value <| MR.GenSimplifyInstructionsOpt1_NoExcl
Simplify cmp sequences on possibly NaN/Inf values <| Explicit
Simplify conditions on instructions which only care about sign on possibly NaN/Inf values <| Explicit
simplify flow control that writes the same value in each flow control path <| Explicit
Simplify integer fraction on possibly NaN/Inf values <| Explicit
Simplify pow on possibly NaN/Inf values <| Explicit
sin float_literal <| SFPS
sin fp_flags <| SFPS
sin fp_range <| SFPS
sin fp_specials <| SFPS
-sin(x) -> sin(-x) <| MR.GenSimplifyInstructionsOpt1_Excl
sincos
sincos float_literal <| SFPS
sincos fp_flags <| SFPS
sincos fp_range <| SFPS
sincos fp_specials <| SFPS
single
single 
size in UDT
size of frame in bytes
sizeof
skh D
skh$D
skipOptimization
Sleep
SleepConditionVariableCS
SlopeScaledDepthBias
SLOPESCALEDEPTHBIAS
SMIDt
smoothstep
snorm
snorm 
Software\Microsoft\Direct3D\Direct3D12
Software\Microsoft\VisualStudio\MSPDB
SOLID
source
source component %d in temp r%d not initialized. Opcode #%d (count is 1-based)
Source compression algorithm.
Source filename.
Source for texcrd requires component selector .xyw(==.rga), or .xyz(==.rgb). Note: Using no selector is treated same as .xyz here.
source indexable temp register component %d in x%d[*] never initialized anywhere.Opcode #%d (count is 1-based)
Source modifier not allowed on sampler (s#) parameter to texld* instruction.
source modifiers are not allowed on destination parameters
source modifiers are not allowed on predicates
source modifiers incompatible with SUB instruction
Source parameter can't specify min precision unless shader is from D3D10+ target.
Source parameter for instruction writing to oCn cannot use a modifier.
Source parameter for instruction writing to oCn cannot use swizzles.
Source parameter for instruction writing to oDepth cannot use a modifier.
Source parameter for instruction writing to oDepth must use a replicate source swizzle. i.e.: .x | .y | .z | .w or .r | .g | .b | .a.  This identifies the scalar component of the source to send to oDepth.
Source predicate must be p0 register.
Source predicate p0 must use one of the following swizzles: .x | .y | .z | .w | .xyzw (same as swizzle not present)
source register relative index indexable-temp register component %d in x[%d][%d] uninitialized. Opcode #%d (count is 1-based)
source register relative index temp register component %d in r%d uninitialized. Opcode #%d (count is 1-based)
Source selector for first source parameter for SINCOS must be .x, .y, .z or .w.
Source swizzle not allowed for tex* instruction (%s source param).
source_mark
source_mark is most useful in /Od builds.  Without /Od source_mark can be moved around in the final shader by optimizations.
sourceFile
sourceFileID
SourceFileName
SourceFiles
space
space is only supported for shader targets 5.1 and higher
SPDBP
SPDBt\
Specular
SPECULAR
SPECULARENABLE
SPECULARMATERIALSOURCE
SPHEREMAP
SPhLFS0
SPhRDEF
split literal sum ishl to allow literalization <| MR.GenSimplifyInstructionsOpt1_Excl
split literal sum ishr to allow literalization <| MR.GenSimplifyInstructionsOpt1_Excl
split literal sum ushr to allow literalization <| MR.GenSimplifyInstructionsOpt1_Excl
sqrt float_literal <| SFPS
sqrt fp_flags <| SFPS
sqrt fp_range <| SFPS
sqrt fp_specials <| SFPS
sqrt times sqrt of positive value equals the original value identity <| MR.GenSimplifyInstructionsOpt1_NoExcl
sqrt(x)/dz -> 0.5 / sqrt(x) * (dx/dz) <| SR.GenDerivatives_Unary
Src and dest registers for NRM cannot be the same.
Src reg for tex* instruction must be t# register (%s source param).
Src selector .b (%s source param) is only valid for instructions that occur in the alpha pipe.
SRC_ALPHA
SRC_ALPHA_SAT
SRC_COLOR
SRC1_ALPHA
SRC1_COLOR
SRCALPHA
SRCALPHASAT
SrcBlend
SRCBLEND
SrcBlendAlpha
SRCBLENDALPHA
SRCCOLOR
SRGBTEXTURE
SRGBWRITEENABLE
SRV reference t%d must have a structure byte stride that is a multiple of 4 that is greater than 0 but no greater than %d when declared as structured (%d specified).  Opcode #%d (count is 1-based). 
SSSSj'
SSSSj-
SSSSj%
SSSSj&
SSSSj(
SSSSj)
SSSSj*
SSSSj,
SSSSj.
SSSSj/
SSSSj0
SSSSj1
SSSSj2
SSSSj3
SSSSj4
SSSSj5
SSSSj6
SSSSj7
SSSSj8
SSSSj9
SSSSP
ST;WT
Stack
Stage linkage warning: Semantic %s has been inconsistently defined in the two stages.
Stage linkage warning: Semantic %s has been placed in different registers in the two stages.
Stage linkage warning: Semantic %s is read from, but it's never written to.
State '%s' belongs in %s blocks, not %s blocks
State '%s' is not indexed
STATEBLOCK
StateBlock
stateblock
stateblock_state
statement
States
static
static 
static function
static instruction count
static interfaces cannot have initializers
static method %s cannot refer to instance members
Static sampler: A NULL pSamplerDesc was specified.
Static sampler: AddressU unrecognized.
Static sampler: AddressV unrecognized.
Static sampler: AddressW unrecognized.
Static sampler: ComparisonFunc unrecognized.
Static sampler: Filter unrecognized.
Static sampler: MaxAnisotropy must be in the range [%d to %d].  %d specified.
Static sampler: MINIMUM or MAXIMUM filters not supported by the device. To see if the device supports this call CheckFeatureSupport with D3D12_FEATURE_D3D12_OPTIONS and check for TiledResourcesTier support of Tier 2+.
Static sampler: MinLOD be in the range [-INF to +INF].  %f specified.
Static sampler: MipLODBias must be in the range [%f to %f].  %f specified.
STATIC_BORDER_COLOR_OPAQUE_BLACK
STATIC_BORDER_COLOR_OPAQUE_WHITE
STATIC_BORDER_COLOR_TRANSPARENT_BLACK
static_cast
StaticSampler
STATu:
status
STENCILENABLE
StencilEnable
STENCILFAIL
STENCILFUNC
STENCILMASK
STENCILPASS
StencilReadMask
STENCILREF
StencilWriteMask
STENCILWRITEMASK
STENCILZFAIL
Stmts
Store
store_raw
store_raw cannot be used on a resource that is not declared as raw (resource index [%d]). Opcode #%d (counts are 1-based).
store_structured
store_structured cannot be used on a resource that is not declared as structured (resource index [%d]). Opcode #%d (counts are 1-based).
store_structured writing to Thread Group Shared Memory for shader models less than 5_0 must use 
store_uav_typed
store_uav_typed cannot be used on a UAV that is not declared as typed (u%d). Opcode #%d (counts are 1-based).
store_uav_typed must write to all four components of the UAV. Opcode #%d (counts are 1-based).
Store2
Store3
Store4
stores to group shared memory for %s targets must be indexed by an SV_GroupIndex only
strchr
Stream index (%u) must between 0 and %u.
stream object '%s' cannot be declared in the global scope
Stream output geometry shaders can only be created from valid 4.0+ vertex and geometry shaders
stream parameter must come from a literal expression
stream parameters can only be single-element types
Stream s%d already declared.  Opcode #%d (count is 1-based). 
StreamOut declarations must be a literal string
StreamOut rasterization stream index must be a literal
StrictGSCheck
stride
string
String
string constant
string continues past end of file
string continues past end of line
StringFileInfo
strncmp
strnlen
strrchr
strstr
struct
struct %s
struct/class members
structure being emitted has elements with no semantic defined
structured buffer element size must be a multiple of %u bytes in %s (actual size %u bytes)
structured buffer elements cannot be larger than %u bytes in %s (actual size %u bytes)
structured_buffer
StructuredBuffer
stuvw
su91t
Sub index list
sub type
sub type ID
Subroutine label #%d never referenced.
Subroutine label number, %d, is too large. Maximum label number is %d. Aborting shader validation.
Subroutine label number: %d already defined earlier. Aborting shader validation.
Subroutine with label #%d called, but never defined.
SUBTRACT
sum of %g and %g cannot be represented accurately in double precision
Sum of temp registers and indexable temp registers exceeds limit of %d..  Opcode #%d (count is 1-based). 
Sum of temp registers and indexable temp registers exceeds limit of %d..  Opcode #%d (count is 1-based). Aborting. 
Sum of temp registers and indexable temp registers exceeds limit of %u
sum of temp registers and indexable temp registers times %u threads exceeds the recommended total %u.  Performance may be reduced
SV_ClipDistance
SV_ClipDistance semantics cannot be used when using the clipplanes attribute
SV_Color
SV_Coverage
SV_COVERAGE
SV_Coverage and SV_InnerCoverage are mutually exclusive
SV_Coverage input not supported on %s
SV_Coverage not supported on %s
SV_CullDistance
SV_DEPTH
SV_Depth
SV_DepthGreaterEqual
SV_DEPTHGREATEREQUAL
SV_DEPTHLESSEQUAL
SV_DepthLessEqual
SV_DispatchThreadID
SV_DomainLocation
SV_GroupID
SV_GroupIndex
SV_GroupThreadID
SV_GSInstanceID
SV_GSInstanceID is an invalid input semantic for geometry shader primitives, it must be its own parameter.
SV_INNERCOVERAGE
SV_InnerCoverage
SV_InnerCoverage input not supported on %s
SV_InsideTessFactor
SV_InstanceID
SV_InstanceId
SV_InstanceID semantic cannot be used with 10Level9 targets
SV_IsFrontFace
SV_OutputControlPointID
SV_Position
SV_Position cannot be constinterp
SV_PrimitiveId
SV_PrimitiveID
SV_PrimitiveId is an invalid input semantic for geometry shader primitives, it must be its own parameter.
SV_RenderTargetArrayIndex
SV_RenderTargetArrayIndex or SV_ViewportArrayIndex from any shader feeding rasterizer
SV_SampleIndex
SV_SampleIndex isn't supported on %s
SV_STENCILREF
SV_StencilRef
SV_Target
SV_TARGET
SV_Target outputs must be contiguous from SV_Target0 to SV_TargetN
SV_Target0
SV_TessFactor
SV_ViewportArrayIndex
SVWh8
SVWhL
SVWj 
SVWj!
SVWj(
SVWj,
SVWj0
SVWj4
SVWjl
SVWjL
SVWjP
SVWPj
Sw t-
swapc
swapc requires destination registers to be different.  Opcode #%d, operand #1 and operand #2 (counts are 1-based).
switch
switch fp_flags <| SFPS
switch must be followed by case or default. Opcode #%d (count 1-based). Aborting validation.
Swizzle
Swizzle not permitted on source parameters to CRS.
Swizzle not permitted on source paramters to CRS.
SWPP3
SWQPj
Symbols
symbols\
SymbolSearchPath
SymbolServerSetOptions
SymbolServerStoreFileW
SymbolServerW
SymbolsFileName
SymIndex
symmetric cmp <| Explicit
symmetric cmp <| MR.GenSimplifyInstructionsOpt1_NoExcl
SYMSRV*
SYMSRV.DLL
SYMSRV.DLL*
SymTag
sync can't specify both _ugroup and _uglobal. If both are needed, just specify _uglobal. Opcode #%d (counts are 1-based).
sync in a non-Compute Shader must only sync UAV (sync_uglobal).Opcode #%d (counts are 1-based).
sync must include some form of memory barrier - _u (UAV) and/or _g (Thread Group Shared Memory).  Only _t (thread group sync) is optional. Opcode #%d (counts are 1-based).
sync_g fp_flags <| SFPS
sync_g_t fp_flags <| SFPS
sync_g_ug fp_flags <| SFPS
sync_g_ug_t fp_flags <| SFPS
sync_g_up fp_flags <| SFPS
sync_g_up_t fp_flags <| SFPS
sync_ug fp_flags <| SFPS
sync_ug_t fp_flags <| SFPS
sync_up fp_flags <| SFPS
sync_up_t fp_flags <| SFPS
syntax error
syntax error : unexpected %s
syntax error: unexpected %s
systemExceptionHandling
SystemRoot
t ^_3
t VhD
t!hp"
t!iK 
t!SPW
t!SWh(
t";t$ t
t"3t$
t"h(}
t"h@}
t"h\}
t"h4}
t"hL}
t"Php
t"PVh
t"Qhp
t"RSh
t"Sh0,
t"Sh0k
t"WVj
t# registers must appear in sequence (i.e. t0 before t2 OK, but t1 before t0 not valid).
t#f;M
t#RhH
t#Wh@
t$ 9s
t$ 9t$`|
t$ Ph
t$ Pj
T$ PR
t$ PS
T$ QR
T$ RPQ
T$ t!
T$ t0j
t$ VW
T$$;L$,r
T$$;W
t$$@;
T$$9QP
T$$C;
t$$Pj
t$$PQ
T$$uX
T$$VS
t$$WV
T$(;T$4s
T$(;Z
T$(9W
t$(h0000
t$(hP
t$(PQ
t$(RPj
t$(SR
t$(SW
t$(VPPR
t$(WV
T$,;T$
t$,9s,
T$,9T$
t$,A;
t$,C;\$Dr
t$,hH
T$,j4R
T$,RQP
T$,SV
t$,uu
t$,WV
T$':T$
T$@#T$
T$@;ZPs
T$@+T$$
T$@9\$0
t$@jPj
t$@Rt
T$@t(
t$@Wj
T$\RP
t$`h$j
t$`WW
t$|QP
t$|SQ
t$|SV
t$<9t$t
t$<hHz
t$<jX
t$<RP
t$<Rt
T$<VWR
T$0;B
T$0;L$<uE
T$0;S
t$09<
t$0PQ
T$0t#
T$0tt
T$4;\$
T$4;L$,r
t$4Pj
t$4PV
T$4RPQ
T$4RQ
t$4Vh
t$4Vh@u
t$83t$(
T$89D$
T$89T$D
T$89T$Ds
T$8F;
t$8PQ
t$8Q3
t$8QP
T$8QR
t$8SW
T$d9P 
t$dh0j
t$DPh
t$DPQ
t$dQPVW
t$DRS
t$dSV
t$f9H
T$H;D$p
T$H;T$(
t$h3D$D
T$H9|$0
T$HF;
t$HhxT
t$HjPj
T$HRQ
T$K:T$J
t$L;\$ 
t$Lh8V
t$LPh
T$lRQ
t$lt 
T$LVW
t$LWP
T$P#T$
T$p;L$ 
t$P;u
t$PC;
t$PVRQ
T$T9T$Lw
t$tB;
T$tRPQ
t$X;t$,
t$x93t
T$xC;\$(
T$XVR
t%;>s
t%<<u!
t%N;u
t%Pj,
t%Rhx
t%SVW
t%WSV
t&hdE
t(9_Lv
t(9qht
t)f;M
t)hxi
t*SVS
t/WQWj
t:;>u/
t:QWQ
t;SVW
t-;WDt(;WHt#
t?y;^
t[_^3
t\;F,tW
t];p|s
t^93uAj
t^h0L2
t^hT0
t_jiP
t_VhT0
t{Phl
t+hP;
t+j(S
t0;}0s+
t09_Lv
t1WVP
t4hP>
t4s"3
t58D$
t5h0q
t5WPV
t8f;M
t8SVW
TANGENT
Tangent
tangent
TARGET
target does not support relative addressing
TargetOffset
TargetRelativeVirtualAddress
TargetSection
TargetVirtualAddress
tARSQV
tbuffer
tbuffer requires a 't' register
tCRQj
tcRQP
tdSWV
technique
technique10
technique10 
technique11
Temp decl already encountered.  Repeated declaration on opcode #%d (count is 1-based). 
template
temporary and constant registers are not allowed in assembly fragments
temporary, constant, and output registers are not allowed in vs_3_0 assembly fragments
TerminateProcess
Tess factor processing functions only available on shader model 4+
Tessellation factor scale will be clamped to the range [0, 1]
Tessellator domain already declared. Aborting. Opcode #%d (count is 1-based). 
Tessellator Output Primitive already declared. Aborting. Opcode #%d (count is 1-based). 
Tessellator Partitioning already declared. Aborting. Opcode #%d (count is 1-based). 
Tessfactor
TESSFACTOR
tessfactor
tessfactor semantic out of order
tessfactor semantics must be in the same component
TessFactors must each be declared with a single component.  Opcode #%d (count is 1-based). 
TestString
Tex register t%d already declared.
tex* instructions cannot be after arithmetic instructions within one phase of a ps_1_4 shader.  Each phase can have a block of tex* instructions followed by a block of arithmetic instructions. 
tex* instructions must write all components.
tex1D
tex1d fp_flags <| SFPS
tex1D will be considered dependent since texcoord was not declared as at least float2
tex1d_bias fp_flags <| SFPS
tex1d_dd fp_flags <| SFPS
tex1d_lod fp_flags <| SFPS
tex1d_proj fp_flags <| SFPS
tex1Dbias
tex1Dgrad
tex1Dlod
tex1Dproj
tex2D
tex2d fp_flags <| SFPS
tex2d_bias fp_flags <| SFPS
tex2d_dd fp_flags <| SFPS
tex2d_lod fp_flags <| SFPS
tex2d_proj fp_flags <| SFPS
tex2Dbias
tex2Dgrad
tex2Dlod
tex2Dproj
tex3D
tex3d fp_flags <| SFPS
tex3d_bias fp_flags <| SFPS
tex3d_dd fp_flags <| SFPS
tex3d_lod fp_flags <| SFPS
tex3d_proj fp_flags <| SFPS
tex3Dbias
tex3Dgrad
tex3Dlod
tex3Dproj
texbem
texbeml
texcoord
TEXCOORD
Texcoord
texcoord/texcrd
TEXCOORDINDEX
TEXCOORDSIZE1_0
TEXCOORDSIZE1_1
TEXCOORDSIZE1_2
TEXCOORDSIZE1_3
TEXCOORDSIZE1_4
TEXCOORDSIZE1_5
TEXCOORDSIZE1_6
TEXCOORDSIZE1_7
TEXCOORDSIZE2_0
TEXCOORDSIZE2_1
TEXCOORDSIZE2_2
TEXCOORDSIZE2_3
TEXCOORDSIZE2_4
TEXCOORDSIZE2_5
TEXCOORDSIZE2_6
TEXCOORDSIZE2_7
TEXCOORDSIZE3_0
TEXCOORDSIZE3_1
TEXCOORDSIZE3_2
TEXCOORDSIZE3_3
TEXCOORDSIZE3_4
TEXCOORDSIZE3_5
TEXCOORDSIZE3_6
TEXCOORDSIZE3_7
TEXCOORDSIZE4_0
TEXCOORDSIZE4_1
TEXCOORDSIZE4_2
TEXCOORDSIZE4_3
TEXCOORDSIZE4_4
TEXCOORDSIZE4_5
TEXCOORDSIZE4_6
TEXCOORDSIZE4_7
texcrd
texcrd must use .xyz(=.rgb) destination writemask.
texcrd with _dw(=_da) source modifier must use .xy(=.rg) destination writemask.
texCUBE
texcube fp_flags <| SFPS
texcube_bias fp_flags <| SFPS
texcube_dd fp_flags <| SFPS
texcube_lod fp_flags <| SFPS
texcube_proj fp_flags <| SFPS
texCUBEbias
texCUBEgrad
texCUBElod
texCUBEproj
texdepth
texdp3
texdp3tex
texkill
texkill must write all components.
texld
texld* must not specify a writemask (same as full mask). texld* instructions always write 4 components, including defaults if the source texture being sampled contains fewer than 4 components. 
texld/texkill/texdepth instructions must write all components.
texld/texldb/texldp/dsx/dsy instructions with r# as source cannot be used inside dynamic conditional 'if' blocks, dynamic conditional subroutine calls, or loop/rep with break*. 
texld/texldb/texldp/dsx/dsy instructions with r# as source cannot be used inside dynamic conditional 'if' blocks, dynamic conditional subroutine calls, or rep with break*. 
texld[b|p]*
texldb
texldd
texldl
texldp
texlod not supported on this target
texm3x2depth
texm3x2pad
texm3x2tex
texm3x3
texm3x3pad
texm3x3spec
texm3x3tex
texm3x3vspec
texreg2ar
texreg2gb
texreg2rgb
TEXT_1BIT
TEXTURE
Texture
texture
texture access must have literal offset and multisample index
TEXTURE assignments inside of samplers cannot be expression indexed
TEXTURE assignments inside of samplers cannot be variable indexed
Texture coordinate register t%d read more than once in shader with different source selector (swizzle). Multiple reads of identical texture coordinate register throughout shader must all use identical source selector. Note this does not restrict mixing use and non-use of a source modifier (i.e. _dw/_da or _dz/_db, depending what the swizzle allows) on these coordinate register reads.
texture mismatch: texture used inconsistently, can only use one DX9-style texture intrinsic on individual samplers or sampler arrays
texture register (t%u) used more than once
Texture register result of texbem or texbeml instruction must not be read by tex* instruction. Affected components(*) of %s source param: %s
Texture register result of texkill%s or texm*pad instructions must not be read. Affected components(*) of %s source param: %s
texture requires a 't' or 's' register
Texture sample will be considered dependent since texcoord was not declared as at least float%d
texture slot start
Texture:   t%u
TEXTURE_ADDRESS_BORDER
TEXTURE_ADDRESS_CLAMP
TEXTURE_ADDRESS_MIRROR
TEXTURE_ADDRESS_MIRROR_ONCE
TEXTURE_ADDRESS_WRAP
texture1d
texture1D
Texture1D
Texture1D Load method for tiled resources requires shader model 5 or higher
Texture1D Sample method for tiled resources requires shader model 5 or higher
Texture1D SampleBias method for tiled resources requires shader model 5 or higher
Texture1D SampleCmp method for tiled resources requires shader model 5 or higher
Texture1D SampleCmpLevelZero method for tiled resources requires shader model 5 or higher
Texture1D SampleLevel method for tiled resources requires shader model 5 or higher
Texture1D types are unsupported on %s
texture1darray
Texture1DArray
Texture1DArray Load method for tiled resources requires shader model 5 or higher
Texture1DArray Sample method for tiled resources requires shader model 5 or higher
Texture1DArray SampleBias method for tiled resources requires shader model 5 or higher
Texture1DArray SampleCmp method for tiled resources requires shader model 5 or higher
Texture1DArray SampleCmpLevelZero method for tiled resources requires shader model 5 or higher
Texture1DArray SampleLevel method for tiled resources requires shader model 5 or higher
Texture2D
texture2d
texture2D
Texture2D GatherAlpha method for tiled resources requires shader model 5 or higher
Texture2D GatherBlue method for tiled resources requires shader model 5 or higher
Texture2D GatherCmpAlpha method for tiled resources requires shader model 5 or higher
Texture2D GatherCmpBlue method for tiled resources requires shader model 5 or higher
Texture2D GatherCmpGreen method for tiled resources requires shader model 5 or higher
Texture2D GatherCmpRed method for tiled resources requires shader model 5 or higher
Texture2D GatherGreen method for tiled resources requires shader model 5 or higher
Texture2D GatherRed method for tiled resources requires shader model 5 or higher
Texture2D Load method for tiled resources requires shader model 5 or higher
Texture2D Sample method for tiled resources requires shader model 5 or higher
Texture2D SampleBias method for tiled resources requires shader model 5 or higher
Texture2D SampleCmp method for tiled resources requires shader model 5 or higher
Texture2D SampleCmpLevelZero method for tiled resources requires shader model 5 or higher
Texture2D SampleLevel method for tiled resources requires shader model 5 or higher
texture2darray
Texture2DArray
Texture2DArray Gather method for tiled resources requires shader model 5 or higher
Texture2DArray GatherAlpha method for tiled resources requires shader model 5 or higher
Texture2DArray GatherBlue method for tiled resources requires shader model 5 or higher
Texture2DArray GatherCmpAlpha method for tiled resources requires shader model 5 or higher
Texture2DArray GatherCmpBlue method for tiled resources requires shader model 5 or higher
Texture2DArray GatherCmpGreen method for tiled resources requires shader model 5 or higher
Texture2DArray GatherCmpRed method for tiled resources requires shader model 5 or higher
Texture2DArray GatherGreen method for tiled resources requires shader model 5 or higher
Texture2DArray Load method for tiled resources requires shader model 5 or higher
Texture2DArray Sample method for tiled resources requires shader model 5 or higher
Texture2DArray SampleBias method for tiled resources requires shader model 5 or higher
Texture2DArray SampleCmp method for tiled resources requires shader model 5 or higher
Texture2DArray SampleCmpLevelZero method for tiled resources requires shader model 5 or higher
Texture2DArray SampleLevel method for tiled resources requires shader model 5 or higher
Texture2DArrayMS
Texture2DMS
texture2dms
texture2DMS cannot be more than %u samples
Texture2DMS resources are only available for input to Pixel Shaders. Opcode #%d (count is 1-based). 
Texture2DMS[Array] or TextureCube[Array] resources are not supported with UAVs (Unordered Access Views). Opcode #%d (count is 1-based). 
Texture2DMSArray
texture2dmsarray
Texture3D
texture3d
texture3D
Texture3D Sampler method for tiled resources requires shader model 5 or higher
Texture3D SamplerBias method for tiled resources requires shader model 5 or higher
Texture3D SamplerLevel method for tiled resources requires shader model 5 or higher
TextureBuffer
TextureCube
texturecube
textureCUBE
TextureCube GatherAlpha method for tiled resources requires shader model 5 or higher
TextureCube GatherBlue method for tiled resources requires shader model 5 or higher
TextureCube GatherCmpAlpha method for tiled resources requires shader model 5 or higher
TextureCube GatherCmpBlue method for tiled resources requires shader model 5 or higher
TextureCube GatherCmpGreen method for tiled resources requires shader model 5 or higher
TextureCube GatherCmpRed method for tiled resources requires shader model 5 or higher
TextureCube GatherGreen method for tiled resources requires shader model 5 or higher
TextureCube GatherRed method for tiled resources requires shader model 5 or higher
TextureCube Sample method for tiled resources requires shader model 5 or higher
TextureCube SampleBias method for tiled resources requires shader model 5 or higher
TextureCube SampleCmp method for tiled resources requires shader model 5 or higher
TextureCube SampleCmpLevelZero method for tiled resources requires shader model 5 or higher
TextureCube SampleLevel method for tiled resources requires shader model 5 or higher
TextureCubeArray
texturecubearray
TextureCubeArray GatherAlpha method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherBlue method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherCmpAlpha method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherCmpBlue method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherCmpGreen method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherCmpRed method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherGreen method for tiled resources requires shader model 5 or higher
TextureCubeArray GatherRed method for tiled resources requires shader model 5 or higher
TextureCubeArray Sample method for tiled resources requires shader model 5 or higher
TextureCubeArray SampleBias method for tiled resources requires shader model 5 or higher
TextureCubeArray SampleCmp method for tiled resources requires shader model 5 or higher
TextureCubeArray SampleCmpLevelZero method for tiled resources requires shader model 5 or higher
TextureCubeArray SampleLevel method for tiled resources requires shader model 5 or higher
TextureCubeArray textures aren't supported on this target
TEXTUREFACTOR
textures
Textures:  t%u-t%u
TEXTURETRANSFORM
TEXTURETRANSFORMFLAGS
TFACTOR
tFhd*
tfhT0
tG<.tC<$t?
The array element count of GetDimensions on TextureCubeArray objects is unavailable on %s
the clip planes (up to 6) to use
The current tex* instruction reads from %c%d, which was written earlier by another tex* instruction in the same block of tex* instructions.  Dependent reads are not permitted within a single block of tex* instructions.  To perform a dependent read, separate texture coordinate derivation from the tex* instruction using the coordinates with a 'phase' marker.
the debug info flag can only be set globally
the dimensions of the thread group
the final dimension specified (%u) for %s must be less than or equal to %u
The first stream declaration cannot appear after any output or output topology declarations.  Opcode #%d (count is 1-based). 
The intersection of all masks on output registers in an index range cannot be empty. Index range from o%d to o%d has empty mask intersecion. 
The maximum number of constant buffer slots is exceeded for a library (slot index=%u, max slots=%u)
The maximum number of sampler slots is exceeded for a library (slot index=%u, max slots=%u)
The maximum number of texture slots is exceeded for a library (slot index=%u, max slots=%u)
The maximum number of UAV slots is exceeded for a library (slot index=%u, max slots=%u)
the maximum number of vertices emitted by this shader
the maximum tessellation factor to allow
the name of the patch constant value evaluation function
the number of control points to emit
the number of instances of this shader to execute simultaneously
The only instruction allowed to write to the predicate register is setp.
The only modifier allowed for source predicate p0 is the not (!) modifier.
The only valid modifiers for the first source parameter of lrp are: reg (no mod) or 1-reg (complement).
The only valid write masks for the FRC instruction are .xy and .y.
the 'pixelshader' keyword is deprecated and reserved in strict mode
the product of the arguments of %s(%u,%u,%u) must be at least %u
the product of the arguments of %s(%u,%u,%u) must be less than or equal to %u
the 'sampler1D' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'sampler2D' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'sampler3D' keyword is deprecated in strict mode; use 'SamplerState' instead
the 'samplerCUBE' keyword is deprecated in strict mode; use 'SamplerState' instead
The setp instruction must write to the predicate register.
the size of constant buffer %s is %d 16-byte entries, which exceeds maximum allowed size of %d entries
the 'stateblock' keyword is deprecated in strict mode
The total amount of group shared memory (%u bytes) exceeds the %s limit of %d bytes
the 'vertexshader' keyword is deprecated and reserved in strict mode
There was a problem getting annotations
There was an error compiling expression
There was an error compiling HLSL shader variable
There was an unexpected error in the parse tree
thh8>
tHh8>
third
Third and fourth parameter for texldd can't specify min precision unless shader is from D3D10+ target.
Third and fourth parameters to texldd must be temp (r#), input (v#) or constant (c#) register.
Third and fourth parameters to texldd must be temp (r#), texture (t#), input (v#) or constant (c#) register.
Third or fourth parameter for texldd using unrecognized min precision.
Third source parameter for dp2add must use a replicate swizzle (.r, .g, .b, .a) to select a scalar component.
Third source parameter for SINCOS must be a constant register.
Third source paramter for SINCOS must be a constant register.
this FX API is not available in this part your program (%s)
this loop dependent on potentially %s data <| I%u (B%u), A%u (B%u)
this memory access dependent on potentially %s data <| I%u (B%u), A%u (B%u)
This object can only be bound to one slot in this version of Effects
this operation
this operation cannot be used directly on resources containing doubles.
this operation with respect to %s
this variable dependent on potentially %s data: %s%s <| I%u (B%u), A%u (B%u)
this variable depends on potentially %s data on loop exit: %s <| I%u (B%u), A%u (B%u)
this variable holds return value
this variable is optimized away
ThisAdjust
Thread Group Shared Memory reference g%d already declared.  Opcode #%d (count is 1-based). 
Thread Group Shared Memory reference g%d byteCount (%d specified) must be a nonzero multiple of 4.  Opcode #%d (count is 1-based). 
Thread Group Shared Memory reference g%d must have a structure byte stride that is a nonzero multiple of 4 when declared as structured (%d specified).  Opcode #%d (count is 1-based). 
Thread local temp register storage in Compute Shader (per thread) %d. The shader declares too much temp storage (%d registers). 
thread sync operation found in varying flow control, consider reformulating your algorithm so all threads will hit the sync simultaneously
thread sync operation must be in non-varying flow control, due to a potential race condition this sync is illegal, consider adding a sync after reading any values controlling shader execution at this point
throw
ThunkOrdinal
tHVh@
tIhT0
Tiled resources
time stamp
TimeStamp
t'j\h
tjPj(
tJSVW
TkiP0
tkSj0
tload fp_flags <| SFPS
TlsAlloc
TlsFree
TlsGetValue
TlsSetValue
tM;2sI
tN_^]
tNQWQ
token
Token
token '%s'
TOKENRIDMAP
Too many %s signature parameters of type SV_ClipDistance or SV_CullDistance.  Maximum number of registers usable is %i.
Too many (%d) arithmetic instruction slots used after phase marker. Max. allowed in a phase (counting any co-issued pairs as 1) is %d.
Too many (%d) arithmetic instruction slots used before phase marker. Max. allowed in a phase (counting any co-issued pairs as 1) is %d.
Too many (%d) arithmetic instruction slots used. Max. allowed (counting any co-issued pairs as 1) is %d. Note that adding a phase marker to the shader would double the number of instructions available.
Too many (%d) standard (non tex*) instruction slots used. Max. allowed is %d.
Too many (%d) tex* instruction slots used after phase marker. Max. allowed in a phase is %d.
Too many (%d) tex* instruction slots used before phase marker. Max. allowed in a phase is %d.
Too many (%d) tex* instruction slots used. Max. allowed is %d.
Too many (%d) tex* instruction slots used. Max. allowed is %d. Note that adding a phase marker to the shader would double the number of instructions available.
Too many (%d) total instruction slots used. Max. allowed is %d.
too many arguments to target TX
Too many arithmetic instruction slots used: %d. Max. allowed (counting any co-issued pairs as 1) is %d.
Too many instruction slots (%d) used by shader. Max. allowed is %d.
too many nested #includes
Too many nested flow control constructs
Too many output registers declared (%d).  When no output register has been declared with the semantic 'psize0', %d o# registers are available.  When an o# register has been declared with the semantic 'psize0' (same as 'psize'), %d registers are available.
too many outputs to target TX
Too many temp registers declared (%d).  Max allowed is %d.  Opcode #%d (count is 1-based). 
Too many texture addressing instruction slots used: %d. Max. allowed is %d. (Note that some texture addressing instructions may use up more than one instruction slot)
Too many total clip/cull distance values.  At most %d allowed (clip+cull total).  Opcode #%d (count is 1-based). 
Too many unique registers contain clip/cull distance values.  At most %d unique registers can have clip/cull distance in components.  Opcode #%d (count is 1-based). 
Too may static flow control instructions (%d) for this shader model.  Maximum allowed is %d. The shader instructions that count as 1 static flow control instruction each are: (1)call, (2)callnz (with static condition), (3)if (static branch), (4)else (paired with static if), (5)loop, (6)rep. 
topology type
total invocation count in PGO training
Total number of instruction slots used too high: %d. Max. allowed (counting any co-issued pairs as 1) is %d.
Total number of scalars across all DS input control points must not exceed %d. Current input control point declaration specifies %d scalars of output per control point with %d output control points, resulting in %d total scalars of input control point data. 
Total number of scalars across all HS output control points must not exceed %d. Current output control point declaration specifies %d scalars of output per control point with %d output control points, resulting in %d total scalars of output control point data. 
Total Thread Group Shared Memory storage exceeded by g# declarations so far up to g%d.  Opcode #%d (count is 1-based). 
tP)L$,+
tQ9P(uL
tR=SMIDtK=RDEFtD
tR9x 
Translation
transpose
Triangle
triangle
triangle_ccw
triangle_cw
triangleadj
TriangleStream
TRIEDGE
TRIINT
trunc
trunc float_literal <| SFPS
trunc fp_flags <| SFPS
trunc fp_range <| SFPS
trunc fp_specials <| SFPS
trunc(itof(x)) -> itof(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
trunc(utod(x)) -> utod(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
trunc(utof(x)) -> utof(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
Try swizzling literal arrays to fit them together <| Explicit
Try to combine like instructions <| Explicit
Try to match temp array loads to their original store <| Explicit
Try to reduce known values to movs <| Explicit
t'Shx!
t'SVW
tttttttttuuuuvvvwx
TU"opqr\]!
tUf;>tP
tuh(G
Tunnel through temp arrays on load <| Explicit
tunnelable move(a) -> append_arg(a) <| SMR.RangeDataAnalysis
tv?@{Bsu
tVhP4
tW;V(wR
TWEENFACTOR
TWEENING
TWOSIDEDSTENCILMODE
tWQWQj
tX;B$
tx_1_0
tXh@s
type mismatch
type mismatch between conditional values
Type of Virtual Base Offset Table
Typed UAV Load Additional Formats
typed UAV loads are only allowed for single-component 32-bit element types
typed UAV stores must write all declared components.
typedef
typedef 
TypeId
typename
tZ9x 
tZC;_
u _^[
u 9p 
U 9P 
u F;u
u Sh(
u Vhp
u!8F8u28F9u
u!hP-
u"#L$4#
u"WhX
u#9C t
u#h@`
u$h`N
u$hx$
u%9^pt 8]$u
u&9>u"
U(;U0
u(VPP
u);s 
u,;3s(
u,;P(u'
u,PQRS
u.j h
u/ishl/r(a, 0) -> mov(a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(and(a, m), n) : if( and_is_identity_ignore_lower_n_bits(a, m, n) -> u/ishr(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(and(m, a), n) : if( and_is_identity_ignore_lower_n_bits(a, m, n) -> u/ishr(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(or(a, m), n) : if( or_is_identity_ignore_lower_n_bits(a, m, n) -> u/ishr(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr(or(m, a), n) : if( or_is_identity_ignore_lower_n_bits(a, m, n) -> u/ishr(a, n) <| MR.GenSimplifyInstructionsOpt1_NoExcl
u/ishr/l(and(a, iv1), iv2) -> and(u/ishr/l(a, iv2), u/ishr/l(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
u/ishr/l(or(a, iv1), iv2) -> or(u/ishr/l(a, iv2), u/ishr/l(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
u/ishr/l(xor(a, iv1), iv2) -> xor(u/ishr/l(a, iv2), u/ishr/l(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_Excl
U;U(tP
u[;L$xuU
u]9P uX
u}^[3
u+h0\
u+SWh
u08G 
u1M5s5
u'3\$4
u4RQh6u
u5QQQQ
u6QQQj
u7Vjc
u-8\$
u9_^3
u98] 
uaddc
uaddc bits_known <| SFPS
uaddc fp_flags <| SFPS
uaddc int_literal <| SFPS
uaddc int_range <| SFPS
UAV reference u%d has invalid flag.  Opcode #%d (count is 1-based). 
UAV reference u%d must have a structure byte stride that is a multiple of 4 that is greater than 0 but no greater than %d when declared as structured (%d specified).  Opcode #%d (count is 1-based). 
UAV reference u%d specified with invalid flag.  Opcode #%d (count is 1-based). 
UAV reference u%d: order preserving counter flag valid only on structured buffers.  Opcode #%d (count is 1-based). 
UAV reference u%d: ROV requires Rasterizer Ordered feature flag.  Opcode #%d (count is 1-based). 
UAV register (u%u) used more than once
UAV requires a 'u' register
UAV slot start
UAV u%d already declared.  Opcode #%d (count is 1-based). 
UAV-related
UAVs at every shader stage
UAVs must be declared in slots greater than PS outputs.  UAV declared in slot %d while output declared in slot %d.  Opcode #%d (count is 1-based). 
ubfe bits_known <| SFPS
ubfe fp_flags <| SFPS
ubfe int_literal <| SFPS
ubfe(i) -> extraction sequence <| MR.Gen_RequiredTranslate
ubfe(w, 0i, a >> s) -> ubfe(w, s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(w, 0i, a) << o -> bfi(w, o, a, 0i) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(w, o, (a >> s) & m) : if( o + s < 32 ) -> ubfe(w, o + s, a & (m << s)) <| MR.GenSimplifyInstructionsOpt1_Excl
ubfe(w, o, a >> s) : if( o + s < 32 ) -> ubfe(w, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(w, o, a) >> s : if( o + s < 32 && w >= s ) -> ubfe(w - s, o + s, a) <| MR.GenSimplifyInstructionsOpt1_NoExcl
ubfe(w, o, a) >> s -> ubfe(w, o + s, a) <| MR.GenSimplifyInstructionsOpt1_Excl
ubh0\
ubhxY
uc_^2
uc8L$
udiv bits_known <| SFPS
udiv fp_flags <| SFPS
udiv int_literal <| SFPS
udiv int_range <| SFPS
udiv(a, iv_pow2) -> ushr(a, get_lowest_bit(iv_pow2)) <| MR.GenD3D10_OptimizeEarlyTranslate
UDT has constructor or destructor, or func is a constructor
UDTKind
uG9qDtB
UGE a,a -> true <| MR.GenSimplifyInstructionsOpt1_NoExcl
uh;NPs
uH_^2
u-h0|
uint1
uint1x1
uint1x2
uint1x3
uint1x4
uint2
uint2x1
uint2x2
uint2x3
uint2x4
uint3
uint3x1
uint3x2
uint3x3
uint3x4
uint4
uint4x1
uint4x2
uint4x3
uint4x4
uJ_^2
ulong
ulRvaStart
ULT a,a -> false <| MR.GenSimplifyInstructionsOpt1_NoExcl
umax bits_known <| SFPS
umax fp_flags <| SFPS
umax int_literal <| SFPS
umax int_range <| SFPS
umax(i0, i1): if (i0 >= i1) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umax(i0, i1): if (i1 >= i0) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umax(umax(i0, l1), l2) -> umax(i0, umax(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umax(x,y) where one is >= the other <| Explicit
umin bits_known <| SFPS
umin fp_flags <| SFPS
umin int_literal <| SFPS
umin int_range <| SFPS
umin(i0, i1): if (i0 >= i1) -> mov(i1) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umin(i0, i1): if (i1 >= i0) -> mov(i0) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umin(umin(i0, l1), l2) -> umin(i0, umin(l1, l2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
umin(x,y) where one is <= the other <| Explicit
umod bits_known <| SFPS
umod fp_flags <| SFPS
umod int_literal <| SFPS
umod int_range <| SFPS
umod(x,y) where x < y <| Explicit
umul bits_known <| SFPS
umul fp_flags <| SFPS
umul int_literal <| SFPS
umul int_range <| SFPS
Unable to calculate derivative of %s. %s
Unable to create warning string
unable to unroll loop, loop does not appear to terminate in a timely manner (%d iterations)
unable to unroll loop, loop does not appear to terminate in a timely manner (%d iterations) or unrolled loop is too large, use the [unroll(n)] attribute to force an exact higher number
UnalignedType
unary negate of unsigned value is still unsigned
unbounded
undecipherable custom data
undeclared identifier '%s'
UndecoratedName
undef
undefined
Undefined
Undefined shader variable '%s'
unexpected #elif
unexpected #elif following #else
unexpected #else
unexpected #else following #else
unexpected #endif
Unexpected component type
Unexpected DWORD count for instruction.  Aborting validation.
unexpected end of file
unexpected end of file in macro expansion
unexpected error in GetTypeArgFlags
Unexpected filter value: '%s'.
Unexpected indexing dimension for operand #%d of opcode #%d (counts are 1-based). Aborting.
Unexpected node encountered when trying to determine type
Unexpected source parameter.
Unexpected template type
Unexpected texture address mode value: '%s'.
Unexpected token '%s'
Unexpected token '%s' when parsing root signature
unexpected tokens following preprocessor directive
Unexpected visibility value: '%s'.
UnhandledExceptionFilter
uNhX9
uniform
uninitialized
uninitializedData
union
Unique id for input assembly file (in this data store)
Unique id for the source file (in this data store).
UNKNOWN
unknown
unknown attribute %s, or attribute invalid for this statement
unknown attribute %s, or attribute invalid for this statement, valid attributes are: %s
Unknown creator
unknown error
Unknown library function
Unknown Value
UnmapViewOfFile
unmodified type
unmodified type ID
Unnamed objects are not allowed
unorm
unorm 
Unreachable
unrecognized compiler target '%s'
unrecognized feature '%s' requested in '#pragma feature(...)'
Unrecognized FX function call (%s)
Unrecognized global flags.  Opcode #%d (count is 1-based). 
unrecognized identifier '%s'
Unrecognized instruction or instruction not valid in a library function.
Unrecognized instruction or instruction not valid in Compute Shader.
Unrecognized instruction or instruction not valid in Domain Shader.
Unrecognized instruction or instruction not valid in geometry shader.
Unrecognized instruction or instruction not valid in Hull Shader.
Unrecognized instruction or instruction not valid in pixel shader.
Unrecognized instruction or instruction not valid in vertex shader.
Unrecognized instruction. Aborting pixel shader validation.
Unrecognized instruction. Aborting vertex shader validation.
Unrecognized min precision on dest parameter.
Unrecognized min precision on source parameter.
Unrecognized min precision type for operand #%d of opcode #%d (counts are 1-based).
Unrecognized RHS value in assignment: '%s'
Unrecognized shader type.
unrecognized shader version
Unrecognized state '%s'
Unrecognized token %s
Unrecognized usage type in dcl statement.
unroll
UnroundedInsideFactor
UnroundedInsideFactors
unsigned
unsigned 
unsigned __int128
unsigned __int16
unsigned __int32
unsigned __int64
unsigned __int8
unsigned can not be used with type
unsigned char
unsigned int
Unsigned integer divide by zero
unsigned integer literal %I64u too large, truncated
unsigned integer movc((a<b),b,a) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
unsigned integer movc((a>=b),a,b) -> max(a,b) <| MR.GenSimplifyInstructionsOpt1_NoExcl
unsigned long
unsigned short
Unsized MSAA textures aren't supported on this target
Unsupported bit-flag set (descriptor range flags %x).
Unsupported bit-flag set (root descriptor flags %x).
Unsupported bit-flag set (root signature flags %x).
unsupported compiler target '%s'
Unsupported function parameter "%s" type.
Unsupported function parameter ("%s") type.
Unsupported ParameterType value %u (root parameter %u)
Unsupported RangeType value %u (descriptor table slot [%u], root parameter [%u]).
Unsupported ShaderVisibility value %u (root parameter [%u]).
Unsupported ShaderVisibility value %u (static sampler [%u]).
Unsupported texture type for %s
untyped textures are deprecated in strict mode
uO8E 
UpperBound
UpperBoundId
uPVWSR
uRh(G
urhP>
usage semantics do not apply to %ss
use flow control and logical conditions to tighten ranges <| Explicit
use of potentially uninitialized variable (%s)
Use replicate swizzles to squish literal arrays <| Explicit
User defined %s buffer slots cannot be target specific
uses custom calling convention
ushort
ushr bits_known <| SFPS
ushr fp_flags <| SFPS
ushr int_literal <| SFPS
ushr(ishl(a, bv), cv) : if( ge_mod_32(cv, bv) ) -> and(ushr(a, cv - bv), (1 << (32-cv))-1) <| MR.GenSimplifyInstructionsOpt1_Excl
ushr(ushr(a, b), c) : if( nooverflow_mod_32(b, c) ) -> ushr(a, iadd(b, c)) <| MR.GenSimplifyInstructionsOpt1_Excl
using
Using a temp register (r#) as source for texld requires component selector .xyz(==.rgb). Note: Using no selector is treated same as .xyz here.
Using a texture coordinate register (t#) as source for texld requires component selector .xyw(=.rga), or .xyz(=.rgb). Note: Using no selector is treated same as .xyz here.
Using sampler arrays with texture objects on DX9 targets is not yet implemented.
usSWj
usubb
usubb bits_known <| SFPS
usubb fp_flags <| SFPS
usubb int_literal <| SFPS
usubb int_range <| SFPS
utod fp_flags <| SFPS
utof fp_flags <| SFPS
utof(sampleinfo_uint(x)) -> sampleinfo(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
utof(sampleinfo_uint_rt(x)) -> sampleinfo_rt(x) <| MR.GenSimplifyInstructionsSampleMask_Both
utVWS
UuidCreate
uvwxyz{|
uW!92
Uw(tLI
UWX++++
uxh@6
uY;_4s
v# register read by instruction(s) before phase marker.  This is not permitted. When a phase marker is present, v# register reads are only permitted after the phase marker.
v%hpp+
v(PVhp
v)PQSh
V;O0s
v?SW3
v[SV3
v{SW3
V0@;FPr
V2k2'3~5
v58\$
Validation Error: %s
Value
value
Value
value cannot be infinity, isfinite() may not be necessary.  /Gis may force isfinite() to be performed
value cannot be infinity, isinf() may not be necessary.  /Gis may force isinf() to be performed
value cannot be NaN, isnan() may not be necessary.  /Gis may force isnan() to be performed
Values
VarFileInfo
variable
variable '%s' has a minimum precision type and cannot be marked precise <| A%u (B%u)
variable '%s' used without having been completely initialized <| A%u (B%u), I%u (B%u)
Variable has an invalid type; is the structure definition empty?
VARIANT
varying
vCoverage
vCycleCounter
vCycleCounter can only be used with the mov instruction.  Opcode #%d, operand #%d (counts are 1-based). 
vCycleCounter is only supported on 5_0+ shaders.  Opcode #%d (count is 1-based). 
vDomain
vector
vector dimension must be a literal scalar expression
vector dimension must be between 1 and %u
vector element type must be a scalar type
vectorize tunnel through add <| Explicit
vectorize tunnel through mul <| Explicit
vectorize tunnel through neg <| Explicit
version token
Version token 0x%x does not represent a pixel library function.
Version token 0x%x does not represent a vertex library function.
Version token 0x%x does not represent a vertex shader.
Version token: 0x%x indicates a pixel shader.  Vertex shader version token must be of the form 0xfffe****.
Version Token: 0x%x indicates a vertex shader.  Pixel shader version token must be of the form 0xffff****.
Version Token: 0x%x is invalid. Pixel shader version token must be of the form 0xffff****. Aborting pixel shader validation.
Version Token: 0x%x is invalid. Vertex shader version token must be of the form 0xfffe****. Aborting vertex shader validation.
Version Token: Pixel shader version ps_2_sw is for software rasterizers only (e.g. the reference device). Aborting shader validation.
Version Token: Pixel shader version ps_3_sw is for use with software rasterizers only (e.g. the reference device). Aborting shader validation.
Version Token: Shader version %s is not supported by device. 
Version Token: Shader version %s is not supported by hardware. 
Version Token: Shader version %s is not supported. Aborting pixel shader validation.
Version Token: Shader version %s is not supported. Aborting vertex shader validation.
Version Token: Shader version %s is not supported. Aborting vertex shader validation. 
Version Token: Vertex shader version vs_2_sw is for software use only. Aborting shader validation.
Version Token: Vertex shader version vs_3_sw is for software use only. Aborting shader validation.
VERTEX
vertex count must be non-zero
Vertex shader must minimally write all four components (xyzw) of oPos output register.  Missing component%s(*): %s
vertex shader must minimally write all four components of POSITION
vertex shader must minimally write all four components of SV_Position
Vertex shader must write all four components (xyzw) of oPos output register.
Vertex shader output dcl with usage 'tessfactor' must have usage index 0, and register must have .x write mask. This semantic is for special purpose use only: creating vertex data that is to be used with tesselation, where a scalar tessfactor is needed.  If you are not doing tesselation, do not bother using this semantic. 
Vertex shader output is not permitted to be dcl'd with the usage+index positiont0.
Vertex Shader position offset
vertex_id
VERTEXBLEND
vertexfragment
vertexID already declared for input.  Opcode #%d (count is 1-based). 
vertexshader
VertexShader
VERTEXSHADER
VERTEXSHADERCONSTANT
VERTEXSHADERCONSTANT1
VERTEXSHADERCONSTANT2
VERTEXSHADERCONSTANT3
VERTEXSHADERCONSTANT4
VERTEXSHADERCONSTANTB
VERTEXSHADERCONSTANTF
VERTEXSHADERCONSTANTI
VERTID
VFACE
vFace
VFace
vFace being read, but not declared. vFace must be declared if it is used:  dcl vFace
vFace or vPos registers cannot be used as sources for matrix operations.
vFace register can only be used as one of the sources to if_(cond), break_(cond), setp_(cond), or the condition in a cmp.
vFace register must not specify a swizzle (i.e. default swizzle), as it is an implied scalar.
vForkInstanceID
vFSW3
vfunctab
vGroupIndex
vGSInstanceID
vH90u
vHSInstanceID
VhSTAT
viewport_array_index
viewportArrayIndex already declared for input.  Opcode #%d (count is 1-based). 
viewportArrayIndex already declared for output.  Opcode #%d (count is 1-based). 
VIEWTRANSFORM
vInnerCoverage
virtual
Virtual
Virtual filename.
VirtualAddress
VirtualAlloc
VirtualBaseClass
VirtualBaseDispIndex
VirtualBaseOffset
VirtualBasePointerOffset
VirtualFree
VirtualTableShape
VirtualTableShapeId
visibility
vJoinInstanceID
vjt}e
VLw@t)
VLwBt/
vmPShh
void main(
void main()
volatile
VolatileType
volume
vOutputControlPointID
vOutputControlPointId
VPINDEX
vPos does not have .z or .w channels in this shader model. Attempt to read following unavailable component(s) (*): %s
vPrim
VPRQj
VQhX$
VRhpR
VRPh4
vs.1.0
vs.1.1
vs.2.0
vs.2.a
vs.2.sw
vs.2.x
vs.3.0
vs.3.sw
vs_%d_%d
vs_1_0
vs_1_0 is no longer supported.  It turned out that vertex shader capable hardware will always support at least vs_1_1 (which is not as limited a model as vs_1_0 was). To convert a vs_1_0 shader up to vs_1_1, the only change needed is to make the version number 1_1. 
vs_1_0 is no longer supported; using vs_1_1
vs_1_1
vs_2_0
vs_2_0 does not support predication.
vs_2_a
vs_2_sw
vs_2_x
vs_2_x extended instruction not supported by the hardware (dynamic flow control not supported).
vs_2_x extended instruction not supported by the hardware (predication not supported).
vs_2_x predication not supported by the hardware.
vs_3_0
vs_3_sw
vs_4_0
vs_4_0_level_9_0
vs_4_0_level_9_1
vs_4_0_level_9_3
vs_4_1
vs_5_0
vs_5_1
VS_VERSION_INFO
VShOSG1
VShSDBG
vThreadGroupID
vThreadID
vThreadIDInGroup
vThreadIDInGroupFlattened
vThreadIDInGroupFlattened as the structure index (second) parameter. Opcode #%d (counts are 1-based).
VVVVP
VVVWR
VWu53
VWXY{Z
VWXYZ[
VWXYZ[\]^_`a
vZ8L$
w tA=
w!t-=
w)t =
w;t)=\
w@hx/
W@PhX
w@t.=
W\9_Ps
w_tL=
W`9_Ps
w`h D
w`h$D
w|tUA
w+t =
w=t,=
W0+W,
w5HPQh
WaitForSingleObjectEx
WakeAllConditionVariable
warning
warning location reached from this location
warning treated as error
WasInlined
WasSpecifiedAsInline
wBtG=
wchar_t
wcschr
wcsncmp
wcsrchr
wCt0=
wDt;=
wGt4=
When a %s shader writes to oCn, it must write to all of oC(n-1) down to oC0 (no gaps).
When a phase marker is present in a shader, texdepth is only permitted after the phase marker.
When a phase marker is present in a shader, texkill is only permitted after the phase marker.
When aL is used as a relative address, it must not specify any swizzle, as it is a scalar register. Aborting validation.
When code ends in subroutine definition, it must end with ret.
When constant registers are read multiple times in a single instruction, the _abs modifier must either be present on all of the constants, or none of them. 
when multiple GS output streams are used they must be pointlists
When multple usages are declared for various components of a given input v# register, the _centroid hint can only be specified on either (a) all usages declared for the register, or (b) on none of them.  Also note that the usage 'color' (with any index) has special behavior: even if the centroid hint is not specified for color, it is assumed to be set. 
When predicate register is used as the condition for a %s instruction, a replicate swizzle must be specified, to select a component. i.e. .x | .y | .z | .w (or rgba equivalent)
When relative addressing of output o# registers is used, position0 must be declared in o%d only, psize0 (if present) must be declared in o%d only, and indexing from/into o%d, or o%d (psize0 case only) is undefined. Indexing into any other declared o# is fine. If relative addressing of o# is not used in the shader, these restrictions on register numbers do not apply. 
When streams are declared, you must use emit_stream, cut_stream, and emitthencut_stream instead of emit, cut, and emitthencut.  Opcode #%d (count is 1-based). 
When the Hull Shader doesn't have a Control Point Phase, the declared Input Control Point Count (%d) must match the declared Output Control Point Count (%d), indicating the control points will pass through, or the Output Control Point Count can be set 0. 
When there is no Control Point phase in the HS, the control points are pass-through to the DS, but the Fork/Join phases in the HS cannot use 'output control points' (vocp[][] registers).  Instead just use vcp[][] input control points (which are the same anyway in the passthrough case). Opcode #%d (count is 1-based).
When using the bias source modifier on a register, the previous writer should apply the saturate modifier. This would ensure consistent behaviour across different hardware. Affected components(*) of %s source param: %s
When using the complement source modifier on a register, the previous writer should apply the saturate destination modifier. This would ensure consistent behaviour across different hardware. Affected components(*) of %s source param: %s
When writing to oDepth with predication, p0 must use a replicate swizzle to select a single component: .x | .y | .z | .w
When writing to oDepth, %s instruction must use replicate swizzle on source parameter(s), in order to select single component. i.e. .x | .y | .z | .w (or rgba equivalent)
When writing to scalar output (oFog, oPts) with predication, p0 must use a replicate swizzle to select a single component: .x | .y | .z | .w
When writing to scalar output (psize) with predication, p0 must use a replicate swizzle to select a single component: .x | .y | .z | .w
When writing to scalar output register, %s instruction must use replicate swizzle on source parameter(s), in order to select single component. i.e. .x | .y | .z | .w (or rgba equivalent)
WhIFCE
while
WideCharToMultiByte
width
WIREFRAME
wKt==
wn>Jj
WORLDTRANSFORM
wOt5=
wp_^3
WPhIFCE
wPt:=
WRAP0
WRAP1
WRAP10
WRAP11
WRAP12
WRAP13
WRAP14
WRAP15
WRAP2
WRAP3
WRAP4
WRAP5
WRAP6
WRAP7
WRAP8
WRAP9
write
Write allowed.
Write mask for CRS must be one of: .x | .y | .z | .xy | .xz | .yz | .xyz (or rgba equivalent)
Write to oCn register cannot use _sat instruction modifier.
Write to oCn register must use full writemask (equivalent to not specifying writemask at all).
Write to oDepth register cannot use _sat instruction modifier.
Write to oDepth register must not specify any writemask. (Note, this is equivalent to using a full writemask) oDepth is a scalar output, however a specific rgba/xyzw channel does not apply -> the writemask is meaningless. 
Write to oDepth register must not specify any writemask. (Note, this is equivalent to using a full writemask) oDepth is a scalar output, however a specific rgba/xyzw channel does not apply; the writemask is meaningless. 
WriteFile
Writemask cannot be empty.
Writemask for bem must be '.rg'
wRt?=
WRVPQ
WSh6u
w-tS-
wvt`=
Ww%t:
wZtD=
x / x -> 1 <| MR.GenSimplifyInstructionsOpt1_NoExcl
x ? firstbit*(x) : -1 -> firstbit*(x) <| MR.GenSimplifyInstructionsOpt1_NoExcl
X AND ~X => 0 <| MR.GenSimplifyInstructionsOpt1_NoExcl
X AND Y : if( and_is_identity(x,y) => X <| MR.GenSimplifyInstructionsOpt1_NoExcl
X AND Y : if( and_is_identity(y,x) => Y <| MR.GenSimplifyInstructionsOpt1_NoExcl
X OR ~X => btrue <| MR.GenSimplifyInstructionsOpt1_NoExcl
X OR Y : if( or_is_identity(x,y) => X <| MR.GenSimplifyInstructionsOpt1_NoExcl
X OR Y : if( or_is_identity(y,x) => Y <| MR.GenSimplifyInstructionsOpt1_NoExcl
x -u,
x!_[3
x"8\$'t
x#VSW
x$9^,vi
X,Y,Z
x/G;y(r
x/ShSHEX
x?SVW
x@jHP
x0$r&
X0\0L5
X0\0X1_1
x0_^[
X0j0k1r1&9
X1\1`1d1h1
XDATA
xdC;_
xESVW
XFt&=
XFt1=
x'G;}
xjh(k
XNA Prepass
xor bits_known <| SFPS
xor fp_flags <| SFPS
xor int_flags <| SFPS
xor int_literal <| SFPS
xor(xor(a, iv1), iv2) -> xor(a, xor(iv1, iv2)) <| MR.GenSimplifyInstructionsOpt1_NoExcl
XSVW3
XTu%h
xtVShISG1
xtVShPSG1
Xu1SWh(
xvQSVhRTS0
xWhX9
XYZ[\]^_`
xyz{|}~
XYZB1
XYZB2
XYZB3
XYZB4
XYZB5
xyzhi
XYZRHW
xyzw (same as not specifying mask)
y"_^[
y%j W
Y(;C<
y(_^[
y,QWV
y^_^[
Y__^[
y__^[
y<}uu
y=_^[
y0_^[
Y0y0:1Z1:2Z2
y1%2S2
y5jth
y7Shx
yA_^[
yF_^Y]
yj_^[
yk_^[
Yw?ty
YwFtA
YY_^]
YZ[\]^_`
yz_^[
YZ_ab
z .u5
z ;x 
z or w components of vPos register are not available in this shader version, and cannot be dcl'd.
Z[\]^_
Z[\]^_`
z|;|$0v
Z2i2{2
ZENABLE
Zero character semantics aren't allowed
ZFUNC
Zh_ijdk
zl@;F
zTPSj
ZWRITEENABLE
